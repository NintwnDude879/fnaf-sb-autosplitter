<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="42">
  <CheatEntries>
    <CheatEntry>
      <ID>26213</ID>
      <Description>"Dumpers (Created By Cake-San) Thank you for this awsome dumper!"</Description>
      <Options moHideChildren="1"/>
      <Color>004000</Color>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>26077</ID>
          <Description>"Dumper V4"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>25330</ID>
              <Description>"Unreal Engine"</Description>
              <Options moHideChildren="1"/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
function ue4config()
 local sub=targetIs64Bit() and 0 or 4
 UObject = {}
 if UE4ver&lt;=2 and targetIs64Bit() then ue4determineversion() end
-----------------------------
----------UE4 struct---------
 if UE4ver&gt;2 then

    UObject.ObjectId= 0xC-sub
    UObject.Class = 0x10-sub
    UObject.FNameIndex = 0x18-(sub*2)
    UObject.Outer = 0x20-(sub*2)

    UObject.enumMul= 0x10

  if UE4ver&gt;=25 then
    UObject.super= 0x40
    UObject.member= 0x50
    UObject.nextmember= 0x20
    UObject.Offset= 0x4C
    UObject.propsize=0x3C
    UObject.bitmask= 0x7A

    UObject.Property= 0x78

  elseif UE4ver&gt;=22 then
    UObject.super= 0x40
    UObject.member= 0x48
  else
    UObject.super= 0x30 -(sub*4)
    UObject.member= 0x38 -(sub*5)
  end

  if UE4ver&lt;25 then
    UObject.nextmember=0x28-(sub*3)
    UObject.Offset= 0x44-(sub*4)
    UObject.propsize= 0x34-(sub*3/2)
    UObject.bitmask= 0x72-(sub*8)

    UObject.Property= 0x70

  end

  if UE4ver&lt;11 then
    UObject.Offset= 0x4C
    UObject.enumMul= 0xC
  end

----------------------------
---------UE3 struct---------
--1.25
 elseif UE4ver&gt;=1 then
    UObject.ObjectId= 0x4
    UObject.Outer = 0x14
    UObject.FNameIndex = 0x18
    UObject.Class = 0x20
    UObject.Offset= 0x48
    UObject.super= 0x34
    UObject.member= 0x38
    UObject.nextmember=0x28
    UObject.propsize= 0x30
    UObject.bitmask= 0x60
    UObject.Property= 0x58
    UObject.enumMul= 0x8


--0.10246
 else
    UObject.ObjectId= 0x20
    UObject.Outer = 0x28
    UObject.FNameIndex = 0x2C
    UObject.Class = 0x34

    UObject.Offset= 0x60

    UObject.super= 0x48
    UObject.member= 0x4C

    UObject.nextmember=0x3C
    UObject.propsize= 0x44
    UObject.bitmask= 0x70
 end

---------------------------
end


local ue4type={
		['BoolProperty']=vtByte,
		['ByteProperty']=vtByte,
		['FloatProperty']=vtSingle,
        ['StructProperty']=vtDword,
		['IntProperty']=vtDword,
        ['NameProperty']=vtQword,
        ['Int64Property']=vtQword,
		['TextProperty']=vtPointer,
        ['StrProperty']=vtPointer,
        ['ArrayProperty']=vtPointer,
        ['MapProperty']=vtPointer,
        ['ClassProperty']=vtPointer,
		['ObjectProperty']=vtPointer}

function ue4versioncheck()
 local fileversion,info =getFileVersion(enumModules()[1].PathToFile)
 if not info then UE4ver=0 return end
--return info.minor
 UE4ver=tonumber(info.minor..'.'..info.release)
end

function FNameStringAlgo(FName,IndexOnly)
 if not FName then return nil end
 local UEver=UE4ver
 local sub=targetIs64Bit() and 0 or 4
 local number,str,datatable
 if not IndexOnly then
   number=UEver&gt;2 and readInteger(FName+4) or 0
   FName=readInteger(FName)
 else number=FName&gt;&gt;32 FName=FName&amp;0xFFFFFFFF
 end
 if not FName then return nil end
 if FNameList[FName] then
   if number&gt;0 then return FNameList[FName]..'_'..number-1 end
   return FNameList[FName]
 end
 local CFName=FName
 if UEver&gt;=23 then
  local i=(FName&gt;&gt;0x10)+1
  FName=(FName&amp;0xFFFF)*2
  if i&gt;#FNameDict or FName&gt;#FNameDict[i] then return nil end
  datatable={}
  for m=1,2 do
    datatable[m]=FNameDict[i][FName+m]
  end

  local le = byteTableToWord(datatable)
  if not le then return nil end
  le=le&gt;&gt;6
  if le&gt;200 then return nil end
  local widechar=true and FNameDict[i][FName+1]&amp;1==1 or false
  if widechar then
    datatable={}
    for m=1,le*2 do
      datatable[m]=FNameDict[i][FName+2+m]
    end
    str=byteTableToWideString(datatable)
  else
    datatable={}
    for m=1,le do
      datatable[m]=FNameDict[i][FName+2+m]
    end
    str=byteTableToString(datatable)
  end
 else
  local i
  if UEver&gt;2 then
   i=(FName&gt;&gt;0xE)+1
   FName=(FName&amp;0x3FFF)*(8-sub)
  else i=1 FName=FName*(8-sub) end
  if i&gt;#FNameDict or FName&gt;#FNameDict[i] then return nil end
  local pointer
  if targetIs64Bit() then
    datatable={}
    for m=1,8 do
      datatable[m]=FNameDict[i][FName+m]
    end
    pointer=byteTableToQword(datatable)
  else
    datatable={}
    for m=1,4 do
      datatable[m]=FNameDict[i][FName+m]
    end
    pointer=byteTableToDword(datatable)
  end
  if not pointer or pointer==0 then return nil end

  --local offset=UE4ver&gt;=22 and 0xC-sub or 0x10-(sub*2)
  if FName==1 and not stringoffset or not stringoffsetid then
     str=readString(pointer+8,13)
     if str=='ByteProperty' then stringoffset=8
     else str=readString(pointer+0xC,13)
         if str=='ByteProperty' then stringoffset=0xC
         else str=readString(pointer+0x10,13)
             if str=='ByteProperty' then stringoffset=0x10 end
         end
     end

     for j=0, stringoffset-4,4 do
       if readInteger(pointer+j)==2 then stringoffsetid=j end
     end
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
  --print(string.format('%X',offset))

  else
  local widechar=true and readInteger(pointer+stringoffsetid)&amp;1==1 and UEver&gt;2 or false
  str= readString(pointer+stringoffset,200,widechar)
  if not str then str= readString(pointer+stringoffset,100,widechar) end
  if not str then str= readString(pointer+stringoffset,50,widechar) end
  if not str then str= readString(pointer+stringoffset,30,widechar) end
  if not str then
   local le=0
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
   while(true)do
    if le&gt;50 then break end
    if readBytes(pointer+stringoffset+le)==0 then break end
    le=le+1
   end
   str= readString(pointer+stringoffset,le)
  end
   --print(string.format('%X',pointer+0xC))
 end end
 if not str then return nil end
 if number&gt;0 then return str..'_'..number-1 end
 --print(str)
 FNameList[CFName]=str
 return str
end

function GetNameAlgo(object)
 if not object then return nil end
 if ObjectList[object] then --print(ObjectList[object])
   return ObjectList[object]
 end
 local fnameoffset=UObject.FNameIndex
 local typeoffset=UObject.Class
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 --print(string.format('%X',fnameoffset))
 --print(string.format('%X',object+fnameoffset))
 local str1=FNameStringAlgo(pointer+fnameoffset)
 local str2=FNameStringAlgo(object+fnameoffset)
 if not str2 then str2=FNameStringAlgo(object+fnameoffset-8)end
 if not str1 or str1=='None' or not str2 or str2=='None' then return nil end
 str1=str1..' '..str2
 --print(ObjectList[object])
 ObjectList[object]=str1
 return str1
end

function GetFullNameAlgo(object)
 if not object then return nil end
 --if ObjectList[object] then return ObjectList[object] end
 local pathoffset=UObject.Outer
 local fnameoffset=UObject.FNameIndex
 local str=GetNameAlgo(object)
 if not str then return nil end
 local number=readInteger(object+fnameoffset+4)
 local typ=str:sub(1,string.find(str,' ')-1)
 local isProperty=string.find(typ,'Property')
 if not isProperty then isProperty=string.find(typ,'Function') end
 local pointer=readPointer(object+pathoffset)
 while(true)do
  if not pointer or pointer==0 then break end
  local stri=GetNameAlgo(pointer)
  if not stri then break end
  typ=stri:sub(1,string.find(stri,' ')-1)
  local isPropertyc=string.find(typ,'Property')
  if not isPropertyc then isPropertyc=string.find(typ,'Function') end
  stri=string.sub(str,1,string.find(str,' '))..stri:sub(string.find(stri,' ')+1,stri:len())
  local num=readInteger(pointer+fnameoffset+4)

  if number~=num and num==0 or  not isPropertyc and isProperty then stri=stri..':'
  else stri=stri..'.' end
  number=num
  isProperty=isPropertyc

  str=stri..string.sub(str,string.find(str,' ')+1,str:len())
  pointer=readPointer(pointer+pathoffset)

  if string.find(str,'%./') then
    stri=string.sub(str,1,string.find(str,' '))
    str=stri..str:sub(string.find(str,'%./')+1,str:len())
  break end

 end
 if not str then return nil end
 --ObjectList[object]=str
 return str
end

function GetFullNameSuperAlgo(object)
  local super=UObject.super
  local str1 = GetFullNameAlgo(object)
  if not str1 then return nil end
  local pointer = readPointer(object+super)
  if pointer then
    local str2 = GetFullNameAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function GetFullNameSafeAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str3 then str3=GetFullNameSafeAlgo(pointer)end

 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 local str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end

function FindString(namestr,start,stop)
  for i=start,stop do
    local name=FNameStringAlgo(i,true)
    if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
      --print(name)
      if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
        if namestr==name then FNameResult=i return end
      end
    end
  end
end


function FindStringFName(namestr)
  local size
  if UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
  elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
  else size=math.floor(#FNameDict[1]/4) end
  local count=0x200
  size=math.floor((size/count)+0.5)
  ue4parsetablecheck()
  FNameResult=nil
  local result
  local num,start,stop=count,0,0
  for i=0,size do
    start=stop
    stop=stop+num
    if FNameResult then break end
    createThread(FindString(namestr,start,stop-1))
  end
  result=FNameResult
  FNameResult=nil
  return result
end

function hasProperty(object)
  local str1
  if UE4ver&gt;=25 then str1=GetFullNameSafeAlgo(object)
  else str1=GetFullNameAlgo(object) end
  if not str1 then return nil end
  local pointer =readPointer(object+UObject.Property)
  if pointer then
    local str2 = GetFullNameAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function printInheritC(class)
  for i=0,10 do
    if not class or class==0 then break end
    print(GetFullNameSuperAlgo(class))
    class=readPointer(class+UObject.super)
  end
end

function printInheritI(instance)
  instance=readPointer(instance+UObject.Class)
  printInheritC(instance)
end

function getregionsize(address)
local allregion=enumMemoryRegions()
 for i=#allregion,1,-1 do
  if allregion[i].BaseAddress&lt;=address then
   local BaseAddress=allregion[i].BaseAddress
   local RegionSize=allregion[i].RegionSize
   local curSize=BaseAddress+RegionSize-address
   return curSize,RegionSize,BaseAddress
  end
 end
end
--[[
function parsefrombig(tab,index,size)
 local datatable={}
 if not tab then return nil end
 for i=1,size do
  datatable[i]=tab[index+i]
 end
 return datatable
end
]]

function ue4parsetable()
 FNameList={}
 ObjectList={}
 FullNameList={}
 sub=targetIs64Bit() and 0 or 4
 local pool=getAddressSafe('FNamePool')
 local pool2=getAddressSafe('GUObjectArray')
 if pool and pool2 then
  if UE4ver&gt;=20 then GUObjectsize=readInteger(getAddress('GUObjectArray+24')-(sub*2))
  elseif UE4ver&gt;11 then  GUObjectsize=readInteger('GUObjectArray+1C')
  else GUObjectsize=readInteger(getAddress('GUObjectArray+8')-(sub*2))
  end
  FNameDict={}
  GUObjectDict={}
  for i=0,100 do
   local pointer
   if UE4ver&gt;=23 then pointer=readPointer(pool+i*(8-sub)+0x10)
   elseif UE4ver&gt;2 then  pointer=readPointer(readPointer(pool)+i*(8-sub))
   else pointer=readPointer(pool+i*(8-sub)) end
   if pointer and pointer~=0 then
    local size=getregionsize(pointer)
    if not size or size==0 then break end
    FNameDict[i+1]=readBytes(pointer,size-1,true)
   else break
   end
  end
  for i=0,100 do
   if UE4ver&gt;=20 then
    pointer=readPointer(readPointer(pool2+0x10)+i*(8-sub))
    if pointer and pointer~=0 then
    --print(string.format('%X',pointer))
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true)
    else break
    end
   elseif UE4ver&gt;11 then pointer=readPointer(pool2+0x10)
    if pointer and pointer~=0 then
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true) break
    else break end
   elseif UE4ver&gt;2 then pointer=readPointer(readPointer(pool2)+i*8+0x10)
    if pointer and pointer~=0 then
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true)
    else break end
   else pointer=readPointer(pool2)
    if pointer and pointer~=0 then
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true) break
    else break end
   end
  end
 end
end


function ue4parsetablecheck()
 if not FNameDict or not GUObjectDict then ue4parsetable()
 else
 local pointer,pointei,datatable,m
 if targetIs64Bit() then
   datatable={}
   for m=1,8 do datatable[m]=GUObjectDict[1][m]end
   pointer=byteTableToQword(datatable)
 else
   datatable={}
   for m=1,4 do datatable[m]=GUObjectDict[1][m]end
   pointer=byteTableToDword(datatable)
 end
 if UE4ver&gt;=20 then pointei=readPointer('[[GUObjectArray+10]]')
 elseif UE4ver&gt;11 then pointei=readPointer('[GUObjectArray+10]')
 elseif UE4ver&gt;2 then pointei=readPointer('[[GUObjectArray]+10]')
 else pointei=readPointer('[GUObjectArray]') end
 --print(string.format('%X',pointei))
 --print(string.format('%X',pointer))
 if pointei ~= pointer then ue4parsetable() end
 local GUObjectsizes
 if UE4ver&gt;=20 then GUObjectsizes=readInteger(getAddress('GUObjectArray+24')-(sub*2))
 elseif UE4ver&gt;11 then GUObjectsizes=readInteger('GUObjectArray+1C')
 else GUObjectsizes=readInteger(getAddress('GUObjectArray+8')-(sub*2)) end
 if GUObjectsizes~=GUObjectsize then ue4parsetable() end
 end
end

function FindObject(threadlist,ObjectId,address,size,i,start,stop,fullname)
  local pointer,datatable
  for j=start,stop do
    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end
    if pointer and pointer~=0 then
      local objid=readInteger(pointer+ObjectId)
      if objid and objid&lt;size then
        local name=GetFullNameAlgo(pointer)
        if name and string.find(name,' ') then
          name=string.sub(name,string.find(name,' ')+1,name:len())
          if not FullNameList[name]then FullNameList[name]=pointer end
          if FullNameList[fullname] then
            ObjectResult=FullNameList[fullname]
            for k,v in ipairs(threadlist) do v.terminate() end
            return
          end
        end
      end
    end
  end
end

function StaticFindObjectAlgo(fullname)
 ue4parsetablecheck()
 if FullNameList[fullname] then return FullNameList[fullname]end
 local threadlist={}
 local k=1
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local ObjectId=UObject.ObjectId
 ObjectResult=nil
 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess) do
    start=stop
    stop=stop+num
    if ObjectResult then break end
    threadlist[k]=createThread(FindObject(threadlist,ObjectId,GUObjectDict[i],size,i,start,stop-1,fullname))
    k=k+1
  end
 end
 local result=ObjectResult
 ObjectResult=nil
 return result
end

function registerFunc(ObjectId,address,size,i,start,stop)
  local funct=UObject.funct
  for j=start,stop do
    local pointer
    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end
    if pointer and pointer~=0 then
      local objid=readInteger(pointer+ObjectId)
      if objid and objid&lt;size then
        local name=GetFullNameAlgo(pointer)
        if name and string.find(name,' ') then
          local typ=string.sub(name,1,string.find(name,' ')-1)
          if typ=='Function' then
            local fullname=string.sub(name,string.find(name,' ')+1,name:len())
            local func=readPointer(pointer+funct)
            if func and func~=0 then extralist.addSymbol('UE',fullname,func,1)end
          end
        end
      end
    end
  end
end

function registerFuncAlgo()
 local funct=UObject.funct
 ue4parsetablecheck()
 if not extralist then
   extralist=createSymbolList()
   extralist.register()
 end
 if not enumUEObjIsRunning and UEObj then
   for i,v in ipairs(UEObj) do
     if v.Type=='Function' then
       local func=readPointer(v.Address+funct)
       if func and func~=0 then extralist.addSymbol('UE',v.FullName,func,1)end
     end
   end
 else
   local k=1
   local count=0x200
   local size=GUObjectsize
   local sizess= UE4ver&gt;2 and (targetIs64Bit() and 0x18*count or 0x10*count) or 0x4*count
   local ObjectId=UObject.ObjectId
   for i=1,#GUObjectDict do
    local num,start,stop=count,0,0
    for j=0,math.floor(#GUObjectDict[i]/sizess) do
      start=stop
      stop=stop+num
      if ObjectResult then break end
      createThread(registerFunc(ObjectId,GUObjectDict[i],size,i,start,stop-1))
      k=k+1
    end
   end
 end
end

function isStructExist(name)
for i=0,getStructureCount()-1 do
if(getStructure(i).getName()==name)then return getStructure(i) end
end
return false
end

function deletestruct(name)
local count=getStructureCount()
local structure
for i=0,count-1 do
structure=getStructure(i)
if(structure.getName()==name)then structure.removeFromGlobalStructureList() break end
end end

function ChildStructStart(structname,elementname)
local struct=isStructExist(structname)
if struct then
for i=0,struct.Count-1 do
if struct.Element[i].Name==elementname then return struct.Element[i].ChildStructStart end end
else return nil end
end

function findAddress(name,number,AddressOrAOBString,modulename,stopaddress,Nth,aobscanOnly,gethead,nop)
	local size,address=0x100
    AddressOrAOBString,address=string.lower(AddressOrAOBString):gsub('banana','')
	if(address&gt;0)then
		local f
		if(modulename==0 or modulename==nil or modulename=='')then f=AOBScan(AddressOrAOBString)
		else
			local ms = createMemScan()
			if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
				stopaddress=getNameFromAddress(modulename,true,false)
                if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
				if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
                modulename=getAddress(stopaddress)
				stopaddress=modulename+getModuleSize(stopaddress)
			end
			ms.firstScan(soExactValue,vtByteArray,rtTruncated,AddressOrAOBString,'',getAddress(modulename),getAddress(stopaddress),'',fsmNotAligned,'',true,false,false,false)
			ms.waitTillDone()
			f = createFoundList(ms)
			f.initialize()
			ms.destroy()
		end
		address={}
		for i=0,f.Count-1 do address[i+1]=f[i]end
		f.destroy()
        if Nth==nil or Nth==0 or Nth=='' then Nth=1 end
        if gethead then
           local addresss=GetAddressSafe(address[Nth])
           if not addresss then addresss=GetAddressSafe(address[Nth-1])end
           if addresss and addresss~=0 then
           for i=0,0x1000 do
               addresss=addresss-1
               if readBytes(addresss,1)==0xCC then break end
               if nop then local ext, opc, byt, add=splitDisassembledString(disassemble(addresss)) if string.find(opc,'nop') then addresss=addresss+getInstructionSize(addresss)-1 break end end
           end
           address[Nth]=addresss+1 end
        end
		if number==nil or number==0 or number=='' then
			if aobscanOnly then return address end
		else
            if(#address==0)then error(name..' aob no result found') end
            if(getAddress(address[Nth])==nil)then error(name..' aob result '..Nth..' doesnt exist') end
            unregisterSymbol(name)
            registerSymbol(name,getAddressSafe(address[Nth]),true)
            if aobscanOnly then return end
		end
		AddressOrAOBString=GetAddressSafe(address[Nth])
	end
    AddressOrAOBString=getAddressSafe(AddressOrAOBString)
	if(AddressOrAOBString==nil)then error(name..' still cant be found')end
	local addr={}
	local i=0
	local j=1
	while(i&lt;size) do
		local ext, opc, byt, add=splitDisassembledString(disassemble(getAddressSafe(AddressOrAOBString)+i))
		if(ext~="")then
			if(opc:find(",")~=nil)then
				opc=opc:sub(opc:find(",")+1,opc:len())
			else
				opc=opc:sub(opc:find(" ")+1,opc:len())
			end
			addr[j]=opc:gsub("%[",""):gsub("]","") j=j+1
		end
        if opc:find('],') then
            opc=opc:sub(opc:find("%[")+1,opc:find("]")-1)
            if tonumber(opc,16) then addr[j]=opc j=j+1 end
        end
		i=i+getInstructionSize(AddressOrAOBString+i)
	end
    --for i=1,#addr do print(addr[i]) end
	if number==nil or number==0 or number=='' then return addr end
	local offset
	if(type(number)==type(''))then
		offset=string.find(number,',')
		if(offset==nil)then number=getAddress(number)
		else offset=getAddress(string.sub(number,offset+1,number:len()))
			number=getAddress(string.sub(number,1,string.find(number,',')-1))
		end
	end
	if offset==nil then offset=0 end
	unregisterSymbol(name)
	registerSymbol(name,getAddressSafe(addr[number])-offset,true)
end

function ue4determineversion()
 local address=findAddress('FNamePool',0,'48 8D 0D *  *  *  *  E8 *  *  *  * 4C 8B C0 C6banana',process,nil,0,true)[1]
 if address then findAddress('FNamePool',1,address) UE4ver=25 ue4parsetable() ue4config()
  local address=getAddressSafe(StaticFindObjectAlgo('/Script/Engine.GameEngine'))
  if not address or address==0 then error('StaticFindObject not functioning as expected...')end
  UE4ver=nil
  local pointer=readPointer(address+UObject.member)
  if pointer then pointer=readPointer(pointer) if pointer then UE4ver=25 end end
  if not UE4ver then UE4ver=23 end
 else
  address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[1]
  if address then findAddress('FNamePool',1,address)
  else findAddress('FNamePool',1,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20banana',process,nil,2)end
  local address=readPointer('[[GUObjectArray+10]]+18')
  if address&gt;0x10000 then
   UE4ver=22
   ue4parsetable()
   ue4config()
   FNameStringAlgo(1,true)
   local address=getAddressSafe(StaticFindObjectAlgo('/Script/Engine.GameEngine'))
   if not address or address==0 then error('StaticFindObject not functioning as expected...')end
   UE4ver=nil
   local pointer=readPointer(address+UObject.member)
   if pointer then pointer=readPointer(pointer) if pointer then UE4ver=22 end end
   if not UE4ver then UE4ver=20 end
  else UE4ver=18 end
 end
end


function ue4createstruct(FullNameOrAddress,StructName,isGlobal,isfullname,Structu,AddedOffset,AddedName)
  if StructName and isStructExist(StructName) and isGlobal then return end
  local member,Offset,Property,bitmask,nextmember,super=UObject.member,UObject.Offset,UObject.Property,UObject.bitmask,UObject.nextmember,UObject.super
  local Object,Name,Class,PropName,Typ,Off,pointer,e,f=FullNameOrAddress
  local isUE425=UE4ver&gt;=25
  if type(FullNameOrAddress)==type('') then Object=StaticFindObjectAlgo(FullNameOrAddress) end
  if not Object then print(FullNameOrAddress..' not found...') return end
  Name=GetNameAlgo(Object)
  if not Name or not string.find(Name,' ') then print(FullNameOrAddress..' invalid Object?') return end
  if not StructName then
    Class=Name:sub(1,string.find(Name,' ')-1)
    Name=Name:sub(string.find(Name,' ')+1,Name:len())
  else Name=StructName end
  local Struct=Structu
  if not Struct then Struct=createStructure(Name)end
  if not AddedOffset then AddedOffset=0 end
  if not AddedName then AddedName='' end
  while(true)do
    if not Object or Object==0 then break end
    Name=GetNameAlgo(Object)
    if not Name then break end
    Name=Name:sub(string.find(Name,' ')+1,Name:len())
    if Name=='Object' then break end
    --print(GetFullNameAlgo(Object))
    pointer=readPointer(Object+UObject.member)
    while(true)do
      if not pointer or pointer==0 then break end
      PropName=isUE425 and GetFullNameSafeAlgo(pointer) or GetFullNameAlgo(pointer)
      if PropName and string.find(PropName,' ') then
        Typ=PropName:sub(1,string.find(PropName,' ')-1)
        if not string.find(Typ,'Function')then
          if not isfullname then PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())
          else PropName=PropName:sub(string.find(PropName,' ')+1,PropName:len())end
          PropName=AddedName..PropName
          Off=readInteger(pointer+Offset)+AddedOffset
          if Class=='UserDefinedStruct' and string.find(PropName,'_') then PropName=PropName:sub(1,string.find(PropName,'_')-1)end
          if Typ=='StructProperty' then ue4createstruct(readPointer(pointer+Property),nil,nil,isfullname,Struct,Off,PropName..'.')
          else
            e=Struct.addElement()
            e.Offset=Off
            e.Name=PropName
            if not ue4type[Typ] then e.Vartype=vtDword
            else e.Vartype=ue4type[Typ]end
            if Typ=='ArrayProperty' then
              f=Struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=Struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
            end
            if Typ=='BoolProperty' then e.ChildStructStart=readBytes(pointer+bitmask,1)end
          end
        end
      end
      pointer=readPointer(pointer+nextmember)
    end
    Object=readPointer(Object+super)
  end

  if Struct.Count==0 then return end
  if AddedOffset&gt;0 then return end

  if Struct.Element[Struct.Count-1].Offset&lt;=0x5000 then
    local count=Struct.Count-1
    local list,k,element1,element2,size,bytesize={},1
    for i=0,count do
        element1=Struct.Element[i]
        element2=Struct.Element[i+1]
        if element2 then
          bytesize=element1.Bytesize
          if bytesize&lt;4 then bytesize=4 end
          size=element2.Offset-element1.Offset-bytesize
          if size&gt;0 then
             if size%4&gt;0 then size=4-size%4+size end
             local start=element1.Offset
             if start%4&gt;0 then start=4-start%4+start
             else start=start+4 end
             size=size/4
             for j=0,size-1 do
               if (start+j*4)&gt;=(element1.Offset+bytesize) then
                 list[k]=start+j*4
                 k=k+1
               end
             end
           end
        end
      end
      for i,v in ipairs(list) do local e=Struct.addElement() e.Offset=v e.Vartype=vtDword end
    end

    if isGlobal then Struct.addToGlobalStructureList()end
end


function ue4createstructfast(fullnameortable,StructName,isGlobal,isfullname,structu,AddedOffset,AddedName)
  if StructName and isStructExist(StructName) and isGlobal then return end
  if not UEObj then enumUEObj() end
  local tabl=fullnameortable
  if type(fullnameortable)==type('') then
    for i,v in ipairs(UEObj) do if v.FullName==fullnameortable then tabl=v break end end
  end
  --[[
  if not tabl or type(tabl)~=type({})  then
    enumUEObj()
    if type(fullnameortable)==type('') then
      for i,v in ipairs(UEObj) do if v.FullName==fullnameortable then tabl=v break end end
    end
  end
  ]]
  if not tabl or type(tabl)~=type({})  then
    print(tostring(fullnameortable)..' not found...')
    return
  end
  local name=StructName
  if not name then name=tabl.Name end
  if not AddedOffset then AddedOffset=0 end
  local struct=structu
  if not struct then struct=createStructure(name)end
  if not AddedName then AddedName='' end
  --print(tostring(tabl))
  local isUserDefinedStruct=string.find(tabl.Type,'UserDefinedStruct')
  local e,typ,propname
  while(true)do
    if not tabl then break end
    if type(tabl)==type(1) or tabl.Name=='Object' then break end
    print(tostring(tabl.Type)..' '..tostring(tabl.FullName))
    if tabl.Member then
      for i=1,#tabl.Member do
        if tabl.Member[i].Type~='Function' then
          if isfullname then e.Name=string.format('%s %s%s',tabl.Member[i].Type,AddedName,tabl.Member[i].FullName)
          else
            propname=AddedName..tabl.Member[i].Name
            if isUserDefinedStruct then propname=propname:sub(1,string.find(propname,'_')-1) end
          end
          if tabl.Member[i].Type=='StructProperty' then ue4createstructfast(tabl.Member[i].Property,nil,nil,isfullname,struct,tabl.Member[i].Offset+AddedOffset,propname..'.')
          else
            e=struct.addElement()
            e.Offset=tabl.Member[i].Offset+AddedOffset
            typ=tabl.Member[i].Type
            e.Name=propname
            e.Vartype=ue4type[typ]
            if e.Vartype==nil then e.Vartype=vtDword end
          --if typ=='StructProperty' then for i=2,(v.Size/4) do local f=struct.addElement() f.Offset=e.Offset+i*4-4 f.Name=e.Name..'_'..i f.Vartype=e.Vartype end e.Name=e.Name
            if typ=='ArrayProperty' then
              local f=struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
              --[[
              if tabl.Member[i].Property.Name and tabl.Member[i].Property.Property.Name then
                local struc=createStructure(tabl.Member[i].Property.Name)
                ue4createstructfast(tabl.Member[i].Property.Property,isfullname and tabl.Member[i].Property.Property.FullName..'.' or tabl.Member[i].Property.Property.Name..'.',10,isfullname,struc)
                if struc.Count&gt;1 then e.ChildStruct=struc end
              end]]
            elseif typ=='BoolProperty' then e.ChildStructStart=tabl.Member[i].BitField end
          end
        end
      end
    end
    tabl=tabl.Parent
  end
  if struct.Count==0 then return end
  if AddedOffset&gt;0 then return end
  if struct.Element[struct.Count-1].Offset&lt;=0x5000 then
    local count=struct.Count-1
    local list,k,element1,element2,size,bytesize={},1
    for i=0,count do
      element1=struct.Element[i]
      element2=struct.Element[i+1]
      if element2 then
        bytesize=element1.Bytesize
        if bytesize&lt;4 then bytesize=4 end
        size=element2.Offset-element1.Offset-bytesize
        if size&gt;0 then
           if size%4&gt;0 then size=4-size%4+size end
           local start=element1.Offset
           if start%4&gt;0 then start=4-start%4+start
           else start=start+4 end
           size=size/4
           for j=0,size-1 do
             if (start+j*4)&gt;=(element1.Offset+bytesize) then
               list[k]=start+j*4
               k=k+1
             end
           end
        end
      end
    end
    for i,v in ipairs(list) do local e=struct.addElement() e.Offset=v e.Vartype=vtDword end
  end
  if isGlobal then struct.addToGlobalStructureList()end
end

function uecreatestruct(instance,name,depth,isfullname)
  local pointer=readPointer(instance+UObject.Class)
  local classname=GetFullNameAlgo(pointer)
  if not classname then print('instance is invalid') return end
  if classname:find(' ') then classname=classname:sub(classname:find(' ')+1) end

  print(string.format("createThread(ue4createstruct(\'%s\',\'%s\',0))",classname,name))
  ue4createstruct(pointer,name,depth,isfullname)
end

function ue_structureDissectOverrideCallback(Struct, Instance)
  --print('banana2')
  local name,fullname
  address,name,fullname=ue_findRealStartOfObject(Instance)

  if name then
   -- print('banana3')
    ue4createstructfast(fullname,nil,10,nil,Struct)
    if Struct.Count&gt;1 then return true
    else return false end
  end

  --ue_fillstruct(readPointer(Instance+UObject.Class),structure)
  --print('banana4')

  return nil
end

function ue_structureNameLookupCallback(address)
  --print('banana1')
  local name,fullname
  address,name,fullname=ue_findRealStartOfObject(address)
  if name then return name,address end
  return nil
end

function ue_findRealStartOfObject(address)
  local pointer=readPointer(address+UObject.Class)
  if pointer then
    local FullName=GetFullNameAlgo(pointer)
    if FullName then
      local Name=GetNameAlgo(pointer)
      FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
      Name=Name:sub(string.find(Name,' ')+1,Name:len())
      return address,Name,FullName
    end
  end

  if not UEObj then enumUEObj() end
  for i=1,#UEObj do
    if UEObj[i].MemberSize and UEObj[i].Class and UEObj[i].Class.MemberSize and UEObj[i].Class.MemberSize&gt;0 and not string.find(UEObj[i].Class.FullName,'/Script/CoreUObject.') then
       if address&gt;=UEObj[i].Address and address&lt;UEObj[i].Address+UEObj[i].Class.MemberSize then
         local name
         return UEObj[i].Address,UEObj[i].Class.Name,UEObj[i].Class.FullName
       end
    end
  end

  return address
end


function enumUEObjT(file,size,i,start,stop)
 local datatable,Address,FName,Name,FullName,typ,typ1,isProperty,l,pointer,stri,num,isPropertyc,EObj,k=0
 local Class,ObjectId,super,Offset,nextmember,member,propsize,bitmask,Property=UObject.Class,UObject.ObjectId,UObject.super,UObject.Offset,UObject.nextmember,UObject.member,UObject.propsize,UObject.bitmask,UObject.Property
 local UEver=UE4ver
 local pointersize= targetIs64Bit() and 8 or 4

 for j=start,stop do
    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      Address=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      Address=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      Address=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      Address=byteTableToDword(datatable)
    end

    if Address and Address~=0 then
       objid=readInteger(Address+ObjectId)
       if objid then
          if objid&lt;size then
             FullName=GetFullNameAlgo(Address)

             if FullName then
               typ1=FullName:sub(1,string.find(FullName,' ')-1)
               FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
               if string.find(FullName,'%.') then Name=FullName:sub(string.find(FullName,'%.')+1,FullName:len())
               else Name=FullName end
               if UEObjIndex[FullName] and UEObj[UEObjIndex[FullName]] then UEObj[UEObjIndex[FullName]].Address=Address
               else
                 EObj={}
                 EObj.Address=Address
                 EObj.Id=objid
                 EObj.Class=temp[readPointer(Address+Class)]
                 EObj.Type=typ1
                 EObj.FullName=FullName
                 EObj.Name=Name
                 Parent=readPointer(Address+super)
                 if Parent and Parent~=0 then EObj.Parent=Parent end
                 temp[Address]=EObj
                 k=1
                 EObj.MemberSize=readInteger(Address+member+pointersize)
                 Address=readPointer(Address+member)

                 EObj.Member={}
                 while(true)do
                   if UEver&gt;=25 then FullName=GetFullNameSafeAlgo(Address)
                   else FullName=GetFullNameAlgo(Address) end
                   if not FullName then break end

                   typ=FullName:sub(1,string.find(FullName,' ')-1)
                   FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
                   if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len())
                   else Name=FullName end
                   EObj.Member[k]={}
                   EObj.Member[k].Address=Address
                   EObj.Member[k].Type=typ
                   EObj.Member[k].FullName=FullName
                   EObj.Member[k].Name=Name
                   EObj.Member[k].Size=readInteger(Address+propsize)
                   EObj.Member[k].Offset=readInteger(Address+Offset)
                   if typ=='BoolProperty' then EObj.Member[k].BitField=readBytes(Address+bitmask,1)
                   elseif typ=='StructProperty' or typ=='ObjectProperty' or typ=='ArrayProperty' then EObj.Member[k].Property=readPointer(Address+Property)end
                   Address=readPointer(Address+nextmember)
                   k=k+1
                 end
                 if #EObj.Member==0 then EObj.Member=nil end
                 UEObj[#UEObj+1]=EObj
                 UEObjIndex[EObj.FullName]=#UEObj+1
               end
             end
          end
       end
    end
 end
--print(i..':'..k)
end

function enumUEObj(isSilent,isUpdateOnly)
 enumUEObjIsRunning=true
 local sub=targetIs64Bit() and 0 or 4
 ue4parsetablecheck()
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local starttime=os.time()
 if not isUpdateOnly then
   UEObj={}
   UEObjIndex={}
 end
 temp={}
 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess+0.5) do
   start=stop
   stop=stop+num
   createThread(enumUEObjT(file,size,i,start,stop-1))
  end
 end
 if not isUpdateOnly then
   for i=1,#UEObj do
     if UEObj[i].Parent then
       if temp[UEObj[i].Parent] then
         UEObj[i].Parent=temp[UEObj[i].Parent]
       end
     end
     if UEObj[i].Member then
       for j=1,#UEObj[i].Member do
         if UEObj[i].Member[j].Property then
           if temp[UEObj[i].Member[j].Property] then
             UEObj[i].Member[j].Property=temp[UEObj[i].Member[j].Property]
             local typ=UEObj[i].Member[j].Property.Type
             if typ and ( typ=='StructProperty' or typ=='ObjectProperty' or typ=='ArrayProperty' ) then
               typ=temp[readPointer(UEObj[i].Member[j].Property.Address+UObject.Property)]
               if typ then
                 UEObj[i].Member[j].Property.Property=typ
               end
             end
           end
         end
       end


     end
   end
 end
 temp=nil
 enumUEObjIsRunning=false
 if not isSilent then print(string.format('\nA Total of %u objects had been enumerated in %u seconds',#UEObj,os.time()-starttime))end
end



function findOpcodes(address,opcode,size)
  if not size then size=0x50 end
  address=getAddressSafe(address)
  if not address then return nil end
  local addr={}
  local i=0
  local j=1
  while(i&lt;size) do
    local ext, opc, byt, add=splitDisassembledString(disassemble(address+i))
    if string.find(opc,opcode) then
      addr[j]=address+i
      j=j+1
    end
    i=i+getInstructionSize(address+i)
  end
  return addr
end

--local ext, opc, byt, add=splitDisassembledString(disassemble(findOpcodes('/Script/Astro.PrinterComponent:UpdatePreprinting_exec','call')[1]))
--return opc:sub(string.find(opc,' ')+1,opc:len())

function groupscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtGrouped,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function UEfindInstancesOfClass(fullnameOrAddress)
  local class,address=UObject.Class
  if type(fullnameOrAddress)==type('')then address=StaticFindObjectAlgo(fullnameOrAddress)
  else address=fullnameOrAddress end
  local fname=readInteger(address+UObject.FNameIndex)
  local result=groupscan(string.format('%u:%u 4:%u',targetIs64Bit() and 8 or 4,address,fname))
  for i,v in ipairs(result) do result[i]=tonumber(v,16)-class end
  return result
end

function StructAddToListSymbol(StructName,StartOffset,StopOffset,BaseAddress,OffsetOnly)
  if not StartOffset then StartOffset=0 end
  if not StopOffset then StopOffset=0xFFFFFF end
  local structCount=getStructureCount()
  local struct
  for i=0,structCount-1 do
    local stru=getStructure(i)
    if stru.Name==StructName then struct=stru break end
  end
  if struct then
    for i=0,struct.Count-1 do
      local e=struct.Element[i]
      if e.Offset&gt;=StartOffset and e.Offset&lt;=StopOffset then
        local rec=getAddressList().createMemoryRecord()
        rec.setDescription(e.Name)
        if OffsetOnly then
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.Offset[0]=e.Offset
          else rec.setAddress(string.format('+%X',e.Offset))end
        else
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.OffsetText[0]=StructName..'.'..e.Name
          else rec.setAddress(string.format('+%s.%s',StructName,e.Name))end
        end
        rec.Type=e.Vartype
      end
    end
  end
end

function getInsForJump(address,registername,destination,allocsize,SharedMemoryName)
  address = getAddressSafe(address)
  if not address then error('getInsForJump address nil') return end
  if not allocsize then allocsize=4096 end
  destination=getAddressSafe(destination)
  if not destination then
	if not SharedMemoryName then destination = allocateMemory(allocsize,address)
	else destination = allocateSharedMemory(SharedMemoryName,allocsize) end
  end
  local size = (address+5-destination&gt;0x7FFFFFFF) and 14 or 5
  if registername then
	unregisterSymbol(registername)
	registerSymbol(registername,destination,true)
  end
  local opcodes = {}
  local i = 0
  while(i&lt;size) do
    local ext, opc=splitDisassembledString(disassemble(address+i))
    opcodes[#opcodes+1] = opc
    i=i+getInstructionSize(address+i)
  end
  local copy = table.concat(opcodes,'\r\n')
  local readAsTable = true
  local byt = readBytes(address,i,readAsTable)
  for j=1,#byt do byt[j] = ('%02X'):format(byt[j]) end
  local bytes = table.concat(byt, ' ')
  return i,copy,bytes,size,destination
end

function enablescript(name,registername,addressname,script,disable)
    local address=getAddress(addressname)
    if disable then script=(script):format(address,registername,readBytes(registername,1))
    else
        local i,copy,bytes,size =getInsForJump(address,name)
        script=(script):format(registername, registername, name, copy, registername, i, bytes, address)..string.rep('nop\n',i-size)..'returnhere:'
    end
    local success,erro=autoAssembleCheck(script)
    if not success then print('\n'..erro..'\n')local scriptstr=createStringlist()scriptstr.Text=script for j=0,scriptstr.Count-1 do print(string.format('%u\t%s',j+1,scriptstr[j])) end
    if not disable then deAlloc(name)unregisterSymbol(name)end error(name..' autoAssemble failed')end
    autoAssemble(script)
    if disable then deAlloc(name)unregisterSymbol(name)unregisterSymbol(registername)end
end

function cycleFullCompact(sender,force)
local state = not(compactmenuitem.Caption == 'Compact View Mode')
if force~=nil
then state = not force
end
compactmenuitem.Caption = state and 'Compact View Mode' or 'Full View Mode'
getMainForm().Splitter1.Visible = state
getMainForm().Panel4.Visible = state
getMainForm().Panel5.Visible = state
end

function addCompactMenu()
if compactmenualreadyexists
then return end
local parent = getMainForm().Menu.Items
compactmenuitem = createMenuItem(parent)
parent.add(compactmenuitem)
compactmenuitem.Caption = 'Compact View Mode'
compactmenuitem.OnClick = cycleFullCompact
compactmenualreadyexists = 'yes'
end

addCompactMenu()
--cycleFullCompact(nil,true)

if syntaxcheck then return end

[ENABLE]
if not process or not enumModules()[1] then print('Error: No process selected...') error('process is nil') end
local starttime=os.time()
ue4versioncheck()

if targetIs64Bit() then

 local address=findAddress('GUObjectArray',0,'44 8B * * * 48 8D 05 * * * * * * * * * 48 89 71 10banana',process,nil,0,true)[1]
 if not address then address=findAddress('GUObjectArray',0,'40 53 48 83 EC 20 48 8B D9 48 85 D2 74 * 8Bbanana',process,nil,0,true)[1]end
 if not address then address=findAddress('GUObjectArray',0,'4C 8B 05 * * * * 45 3B 88banana',process,nil,0,true)[1]end
 if not address then error('GUObjectArray aob not found...')end
 findAddress('GUObjectArray',1,address)

 ue4config()

 if UE4ver&gt;=23 then findAddress('FNamePool',1,'48 8D 0D *  *  *  *  E8 *  *  *  * 4C 8B C0 C6banana',process)
 else
  address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[2]
  if not address then address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[1] end
  if address then findAddress('FNamePool',1,address)
  else findAddress('FNamePool',1,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20banana',process,nil,2)end
 end

 local address=findAddress('GEngine',0,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process,nil,0,true)[1]
 if not address then address=findAddress('GEngine',0,'48 8B 1D * * * * 48 85 DB 74 * 48 8Dbanana',process,nil,0,true)[1]end
 if not address then error('GEngine aob not found...')end
 findAddress('GEngine',1,address)
 --findAddress('GEngine',1,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process)

else
 ue4config()
 if UE4ver&gt;2 then
  findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  findAddress('GUObjectArray',1,'8B 44 24 04 56 8B F1 85 C0 74 17 8B 40 08banana',process)
  findAddress('FNamePool',1,'33 F6 89 35 * * * * 8B C6 5Ebanana',process,nil,1,nil,true,true)
 else
  findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  findAddress('FNamePool',1,'8B 07 8B 0D * * * * 8B 04 81banana',process)
  findAddress('GUObjectArray',1,'8B 15 * * * * 8B 04 82 85banana',process)
 end
end
print('AOBScan done : '..os.time()-starttime)
ue4parsetable()
--findAddress('GWorld',1,'4D 8B 94 24 50 0C 00 00banana',process)

FNameStringAlgo(1,true)

print('Table parsing done : '..os.time()-starttime)
if UE4ver&gt;2 then

 createThread(ue4createstruct('/Script/Engine.GameEngine','GameEngine',1))
 createThread(ue4createstruct('/Script/Engine.GameViewportClient','GameViewportClient',0))

 createThread(ue4createstruct('/Script/Engine.GameInstance','GameInstance',0))
 createThread(ue4createstruct('/Script/Engine.LocalPlayer','LocalPlayer',1))
 createThread(ue4createstruct('/Script/Engine.PlayerController','PlayerController',2))
 createThread(ue4createstruct('/Script/Engine.CharacterMovementComponent','MovementComponent',0))
 createThread(ue4createstruct('/Script/Engine.CapsuleComponent','CapsuleComponent',3))
 createThread(ue4createstruct('/Script/Engine.Character','GPlayer',0))

 createThread(ue4createstruct('/Script/Engine.World','World',0))

end

print('All done : '..os.time()-starttime..'\n')
sleep(1000)
GetLuaEngine().close()
[DISABLE]
--cycleFullCompact(nil,false)
unregisterSymbol('GEngine')
unregisterSymbol('GUObjectArray')
unregisterSymbol('FNamePool')

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>26076</ID>
                  <Description>"Enable ue_structureDissectCallback (Experimental)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
if not ue_structureDissectOverrideCallbackID then
  ue_structureDissectOverrideCallbackID=registerStructureDissectOverride(ue_structureDissectOverrideCallback)
end

if not ue_structureNameLookupCallbackID then
  ue_structureNameLookupCallbackID=registerStructureNameLookup(ue_structureNameLookupCallback)
end

 
 
[DISABLE]
unregisterStructureDissectOverride(ue_structureDissectOverrideCallbackID)
unregisterStructureNameLookup(ue_structureNameLookupCallbackID)
ue_structureDissectOverrideCallbackID=nil
ue_structureNameLookupCallbackID=nil
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26050</ID>
                  <Description>"Basic UE Object Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local Offset,ObjectId,nextmember,member,enumMul,Property=UObject.Offset,UObject.ObjectId,UObject.nextmember,UObject.member,UObject.enumMul,UObject.Property

function ue4dump(file,address,size,i,start,stop)
 local k=0
 local addy= targetIs64Bit() and 8 or 4
 local en= targetIs64Bit() and 0x40 or 0x2C
 local pointer,datatable,pointers,propname,offset,list,str,strid,name,objid
 for j=start,stop do

    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end

    if pointer and pointer~=0 then
       local objid=readInteger(pointer+ObjectId)
       if objid then
          if objid&lt;size then
             str=string.format('%016X',pointer)
             strid=string.format('%08u',objid)
             name=GetFullNameSuperAlgo(pointer,true)
             if name then
                 typ=name:sub(1,string.find(name,' ')-1)
                 if string.find(typ,'Property') then
                     if (typ=='StructProperty' or string.find(typ,'ObjectProperty') or string.find(typ,'ArrayProperty') ) and Property then
                       name=hasProperty(pointer)
                     end
                     strid=string.format('%8X',readInteger(pointer+Offset))
                 end

                 file:write(string.format('[%s] %s %s\n',strid,str,name))


                 if (typ=='UserDefinedEnum' or typ=='Enum') and enumMul then
                   list=pointer+en
                   for i=0,readInteger(list+8)-1 do
                     pointers=readPointer(list)+i*enumMul
                     offset=readBytes(pointers+addy,1)
                     if offset==0 then offset=i end
                     propname=FNameStringAlgo(pointers)
                     strid=string.format('%8X',offset)
                     str=string.format('%016X',pointers)
                     file:write(string.format('[%s] %s %s\n',strid,str,propname))
                   end
                 elseif typ=='MapProperty' and Property then
                   for n=0,1 do
                     pointers=readPointer(pointer+n*8+Property)
                     propname=hasProperty(pointers)
                     if propname then
                       offset=readInteger(pointers+Offset)
                       strid=string.format('%8X',offset)
                       str=string.format('%016X',pointers)
                       file:write(string.format('[%s] %s %s\n',strid,str,propname))
                     end
                   end
                 end

                 if UE4ver&gt;=25 then
                     local pointers= readPointer(pointer+member)
                     while(true)do
	                     propname=GetFullNameSafeAlgo(pointers)
	                     if not propname then break end
	                     offset=readInteger(pointers+Offset)
	                     strid=string.format('%8X',offset)
                         str=string.format('%016X',pointers)

                         typ=propname:sub(1,string.find(propname,' ')-1)
                         if typ=='StructProperty' or string.find(typ,'ObjectProperty') or string.find(typ,'ArrayProperty') then
                           propname=hasProperty(pointers)
                         end

	                     file:write(string.format('[%s] %s %s\n',strid,str,propname))

                         if typ=='MapProperty' then
                           for n=0,1 do
                             pointer=readPointer(pointers+n*8+Property)
                             propname=hasProperty(pointer)
                             if propname then
                               offset=readInteger(pointer+Offset)
                               strid=string.format('%8X',offset)
                               str=string.format('%016X',pointer)
                               file:write(string.format('[%s] %s %s\n',strid,str,propname))
                             end
                           end
                         end

	                     pointers=readPointer(pointers+nextmember)
                     end
                 end
                 k=k+1
             end
          end
       end
    end
 end
    totalobject=totalobject+k
--print(i..':'..k)
end


 local sub=targetIs64Bit() and 0 or 4
 ue4parsetablecheck()
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local starttime=os.time()
 local Path = 'C:\\test\\'
 local filename= string.format('[%s] ObjectsDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
--local re={rei1,rei2,rei3,rei4,rei5}
 totalobject=0
--allobject=createStringlist()

 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess+0.5) do
   start=stop
   stop=stop+num
   createThread(ue4dump(file,GUObjectDict[i],size,i,start,stop-1))
  end
 end


 file:close()
 print(string.format('\nA Total of %u objects had been dumped in %u seconds',totalobject,os.time()-starttime))
 print(Path..filename)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26051</ID>
                  <Description>"Basic UE Name Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function uenamedump(file,start,stop)
  for i=start,stop do
    local name=FNameStringAlgo(i,true)
    if name and name:len()&lt;200 and name:len()&gt;3 and not string.find(name,'%c')  then
      --print(name)
      local strid=string.format('%08X',i)

      file:write(string.format('[%s] %s\n',strid,name))
      totalname=totalname+1
    end
  end
end


 local size
 if UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
 elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
 else size=math.floor(#FNameDict[1]/4) end
 local count=0x200
 size=math.floor((size/count)+0.5)

 local starttime=os.time()
 local Path = 'C:\\test\\'
 local filename= string.format('[%s] NamesDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
 totalname=0
 ue4parsetablecheck()
 local num,start,stop=count,0,0
 for i=0,size do
   start=stop
   stop=stop+num
   createThread(uenamedump(file,start,stop-1))
 end
 file:close()
 print(string.format('\nA Total of %u names had been dumped in %u seconds',totalname,os.time()-starttime))
 print(Path..filename)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26040</ID>
                  <Description>"NoClip &amp; Fly                                            Numpad6 :Toggle, Space :Up, LeftCtrl :Down"</Description>
                  <Options moHideChildren="1" moDeactivateChildrenAsWell="1"/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end

[ENABLE]

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) &amp; ~ ChildStructStart('PlayerController','bActorEnableCollision')
writeBytes(address,bActorEnableCollision)
end

--[[
Enum /Script/Engine.EMovementMode
0:MOVE_None
1:MOVE_Walking
2:MOVE_NavWalking
3:MOVE_Falling
4:MOVE_Swimming
5:MOVE_Flying
6:MOVE_Custom
7:MOVE_MAX

local list=+0x40
for i=0,readInteger(list+8)-1 do
local pointer=readPointer(list)+i*0x10
local enum=readInteger(pointer+8)
local name=FNameString(pointer)
print(enum..':'..name)
end
]]


if not RelativeLocationZoffset then
  local address=getAddress('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  local value=readInteger(address+getAddress('CapsuleComponent.RelativeLocation.Z'))
  local list=groupscan(string.format('4:%u',value),address,address+0x1000)
  RelativeLocationZoffset={}
  for i=1,#list do
    RelativeLocationZoffset[i]=getAddress(list[i])-address
  end
end

updown = createTimer()
updown.Interval = 5
updown.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_SPACE) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])+20)
      end
    end
    if isKeyPressed(VK_LCONTROL) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])-20)
      end
    end
  end
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MovementMode')
  if address then
  writeBytes(address,5)
  end
end




[DISABLE]
updown.destroy()

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) | ChildStructStart('PlayerController','bActorEnableCollision')
writeBytes(address,bActorEnableCollision)
end

local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MovementMode')
if address then
writeBytes(address,1)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Toggle Activation</Action>
                      <Keys>
                        <Key>102</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                  </Hotkeys>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26041</ID>
                      <Description>"WASD"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
wasd = createTimer()
wasd.Interval = 5
wasd.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_S) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)+20)
      end
    end
    if isKeyPressed(VK_W) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)-20)
      end
    end
    if isKeyPressed(VK_A) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)+20)
      end
    end
    if isKeyPressed(VK_D) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)-20)
      end
    end
  end
end

[DISABLE]
wasd.destroy()
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>26039</ID>
                  <Description>"bCanBeDamaged false (Godmode)      Numpad4 :Deactive, Numpad5 :Active"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end

[ENABLE]
--CanBeDamaged = createTimer()
--CanBeDamaged.setInterval(1000)
--CanBeDamaged.OnTimer = function()
local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bCanBeDamaged')
if address then
local bCanBeDamaged=readBytes(address,1) &amp; ~ ChildStructStart('PlayerController','bCanBeDamaged')
writeBytes(address,bCanBeDamaged)
end
--end
 
 
[DISABLE]
--CanBeDamaged.destroy()

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bCanBeDamaged')
if address then
local bCanBeDamaged=readBytes(address,1) | ChildStructStart('PlayerController','bCanBeDamaged')
writeBytes(address,bCanBeDamaged)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>101</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>100</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26025</ID>
                  <Description>"Jump Multiplier                                       Numpad0 :Deactive, Numpad1 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
jumpmultiplier=1
if syntaxcheck then return end
if not jumpdefault then jumpdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')end
if not MaxAccelerationdefault then MaxAccelerationdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')end
if not AirControldefault then AirControldefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')end
[ENABLE]
jumpmuti=createHotkey(function()jumpmultiplier=jumpmultiplier+0.5 end,VK_NUMPAD1)
jump = createTimer()
jump.setInterval(1000)
jump.OnTimer = function()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')
local address2=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')
local address3=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')
if address then writeFloat(address,jumpdefault*jumpmultiplier)
writeFloat(address2,MaxAccelerationdefault*jumpmultiplier)
writeFloat(address3,AirControldefault*jumpmultiplier)
end
end
[DISABLE]
jump.destroy()
jumpmuti.destroy()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')
local address2=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')
local address3=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')
if address then writeFloat(address,jumpdefault)
writeFloat(address2,MaxAccelerationdefault)
writeFloat(address3,AirControldefault)
end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>97</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>96</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26026</ID>
                  <Description>"WalkSpeed Multiplier                             Numpad2 :Deactive, Numpad3 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
walkmultiplier=1
if syntaxcheck then return end
if not walkdefault then walkdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')end
[ENABLE]
walkpmuti=createHotkey(function() walkmultiplier=walkmultiplier+0.5 end,VK_NUMPAD3)
walk = createTimer()
walk.setInterval(1000)
walk.OnTimer = function()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')
if address then writeFloat(address,walkdefault*walkmultiplier)end
end
[DISABLE]
walk.destroy()
walkpmuti.destroy()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')
if address then writeFloat(address,walkdefault)end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>99</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>98</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26052</ID>
                  <Description>"UWorld"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>GameViewportClient.World</Offset>
                    <Offset>GameEngine.GameViewport</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>25848</ID>
                  <Description>"Player"</Description>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>PlayerController.Character</Offset>
                    <Offset>LocalPlayer.PlayerController</Offset>
                    <Offset>0</Offset>
                    <Offset>GameInstance.LocalPlayers</Offset>
                    <Offset>GameEngine.GameInstance</Offset>
                  </Offsets>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>25853</ID>
                      <Description>"CharacterMovement"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <GroupHeader>1</GroupHeader>
                      <Address>+GPlayer.CharacterMovement</Address>
                      <Offsets>
                        <Offset>0</Offset>
                      </Offsets>
                      <CheatEntries>
                        <CheatEntry>
                          <ID>25854</ID>
                          <Description>"JumpZVelocity"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.JumpZVelocity</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>25855</ID>
                          <Description>"MaxWalkSpeed"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxWalkSpeed</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>25857</ID>
                          <Description>"MaxWalkSpeedCrouched"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxWalkSpeedCrouched</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>25858</ID>
                          <Description>"MaxAcceleration"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxAcceleration</Address>
                        </CheatEntry>
                      </CheatEntries>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>26049</ID>
              <Description>"Tools"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>26048</ID>
                  <Description>"FNamePool scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
function stringscan(value,modulename,stopaddress,isUnicode)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtString,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,isUnicode,true)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end



createThread(function()
print('------------------')
local isUnicode=false
local strlist,result,result2,result3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  result=stringscan('IntProperty',getAddressSafe(strlist[i]),getAddressSafe(strlist[i]..'+50'),isUnicode)
  if #result&gt;0 then
    result=stringscan('None',getAddressSafe(strlist[i]..'-50'),getAddressSafe(strlist[i]),isUnicode)
    print(strlist[i])
    if #result&gt;0 then
      if string.sub(strlist[i],strlist[i]:len()-3,strlist[i]:len()-2)=='00' then
        result=pointerscan(getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00'))
        for j=1,#result do
          print(strlist[i]..'&lt;-'..result[j])
          if string.sub(result[j],result[j]:len()-1,result[j]:len())=='00' then
            result2=pointerscan(getAddressSafe(result[j]))
            for k=1,#result2 do
              print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
              result3=pointerscan(getAddressSafe(result2[k]),getAddress(process),getAddress(process)+getModuleSize(process))
              for l=1,#result3 do print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l]) end
            end
          end
        end
      end
    end
  end
end
print('done')
end)
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26029</ID>
                  <Description>"DissectCode (Memory View -&gt; Ctrl+J or (Tools -&gt; Dissect code) )"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26028</ID>
                      <Description>"Save DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
getDissectCode().saveToFile(path)
--getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>26030</ID>
                      <Description>"Load DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
--getDissectCode().saveToFile(path)
getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>26099</ID>
          <Description>"Dumper V4.1"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>26078</ID>
              <Description>"Unreal Engine"</Description>
              <Options moHideChildren="1"/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
function ue4config()
 local sub=targetIs64Bit() and 0 or 4
 UObject = {}
 if UE4ver&lt;=2 and targetIs64Bit() then ue4determineversion() end
-----------------------------
----------UE4 struct---------
 if UE4ver&gt;2 then

    UObject.ObjectId= 0xC-sub
    UObject.Class = 0x10-sub
    UObject.FNameIndex = 0x18-(sub*2)
    UObject.Outer = 0x20-(sub*2)

    UObject.enumMul= 0x10

  if UE4ver&gt;=25 then
    UObject.super= 0x40
    UObject.member= 0x50
    UObject.nextmember= 0x20
    UObject.Offset= 0x4C
    UObject.propsize=0x3C
    UObject.bitmask= 0x7A

    UObject.Property= 0x78

  elseif UE4ver&gt;=22 then
    UObject.super= 0x40
    UObject.member= 0x48
  else
    UObject.super= 0x30 -(sub*4)
    UObject.member= 0x38 -(sub*5)
  end

  if UE4ver&lt;25 then
    UObject.nextmember=0x28-(sub*3)
    UObject.Offset= 0x44-(sub*4)
    UObject.propsize= 0x34-(sub*3/2)
    UObject.bitmask= 0x72-(sub*8)

    UObject.Property= 0x70

  end

  if UE4ver&lt;11 then
    UObject.Offset= 0x4C
    UObject.enumMul= 0xC
  end

----------------------------
---------UE3 struct---------
--1.25
 elseif UE4ver&gt;=1 then
    UObject.ObjectId= 0x4
    UObject.Outer = 0x14
    UObject.FNameIndex = 0x18
    UObject.Class = 0x20
    UObject.Offset= 0x48
    UObject.super= 0x34
    UObject.member= 0x38
    UObject.nextmember=0x28
    UObject.propsize= 0x30
    UObject.bitmask= 0x60
    UObject.Property= 0x58
    UObject.enumMul= 0x8


--0.10246
 else
    UObject.ObjectId= 0x20
    UObject.Outer = 0x28
    UObject.FNameIndex = 0x2C
    UObject.Class = 0x34

    UObject.Offset= 0x60

    UObject.super= 0x48
    UObject.member= 0x4C

    UObject.nextmember=0x3C
    UObject.propsize= 0x44
    UObject.bitmask= 0x70
 end

---------------------------
end


local ue4type={
		['BoolProperty']=vtByte,
		['ByteProperty']=vtByte,
		['FloatProperty']=vtSingle,
        ['StructProperty']=vtDword,
		['IntProperty']=vtDword,
        ['NameProperty']=vtQword,
        ['Int64Property']=vtQword,
		['TextProperty']=vtPointer,
        ['StrProperty']=vtPointer,
        ['ArrayProperty']=vtPointer,
        ['MapProperty']=vtPointer,
        ['ClassProperty']=vtPointer,
		['ObjectProperty']=vtPointer}

function ue4versioncheck()
 local fileversion,info =getFileVersion(enumModules()[1].PathToFile)
 if not info then UE4ver=0 return end
--return info.minor
 UE4ver=tonumber(info.minor..'.'..info.release)
end

function FNameStringAlgo(FName,IndexOnly)
 if not FName then return nil end
 local UEver=UE4ver
 local sub=targetIs64Bit() and 0 or 4
 local number,str,datatable
 if not IndexOnly then
   number=UEver&gt;2 and readInteger(FName+4) or 0
   FName=readInteger(FName)
 else number=FName&gt;&gt;32 FName=FName&amp;0xFFFFFFFF
 end
 if not FName then return nil end
 if FNameList[FName] then
   if number&gt;0 then return FNameList[FName]..'_'..number-1 end
   return FNameList[FName]
 end
 local CFName=FName
 if UEver&gt;=23 then
  local i=(FName&gt;&gt;0x10)+1
  FName=(FName&amp;0xFFFF)*2
  if i&gt;#FNameDict or FName&gt;#FNameDict[i] then return nil end
  datatable={}
  for m=1,2 do
    datatable[m]=FNameDict[i][FName+m]
  end

  local le = byteTableToWord(datatable)
  if not le then return nil end
  le=le&gt;&gt;6
  if le&gt;200 then return nil end
  local widechar=true and FNameDict[i][FName+1]&amp;1==1 or false
  if widechar then
    datatable={}
    for m=1,le*2 do
      datatable[m]=FNameDict[i][FName+2+m]
    end
    str=byteTableToWideString(datatable)
  else
    datatable={}
    for m=1,le do
      datatable[m]=FNameDict[i][FName+2+m]
    end
    str=byteTableToString(datatable)
  end
 else
  local i
  if UEver&gt;2 then
   i=(FName&gt;&gt;0xE)+1
   FName=(FName&amp;0x3FFF)*(8-sub)
  else i=1 FName=FName*(8-sub) end
  if i&gt;#FNameDict or FName&gt;#FNameDict[i] then return nil end
  local pointer
  if targetIs64Bit() then
    datatable={}
    for m=1,8 do
      datatable[m]=FNameDict[i][FName+m]
    end
    pointer=byteTableToQword(datatable)
  else
    datatable={}
    for m=1,4 do
      datatable[m]=FNameDict[i][FName+m]
    end
    pointer=byteTableToDword(datatable)
  end
  if not pointer or pointer==0 then return nil end

  --local offset=UE4ver&gt;=22 and 0xC-sub or 0x10-(sub*2)
  if FName==1 and not stringoffset or not stringoffsetid then
     str=readString(pointer+8,13)
     if str=='ByteProperty' then stringoffset=8
     else str=readString(pointer+0xC,13)
         if str=='ByteProperty' then stringoffset=0xC
         else str=readString(pointer+0x10,13)
             if str=='ByteProperty' then stringoffset=0x10 end
         end
     end

     for j=0, stringoffset-4,4 do
       if readInteger(pointer+j)==2 then stringoffsetid=j end
     end
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
  --print(string.format('%X',offset))

  else
  local widechar=true and readInteger(pointer+stringoffsetid)&amp;1==1 and UEver&gt;2 or false
  str= readString(pointer+stringoffset,200,widechar)
  if not str then str= readString(pointer+stringoffset,100,widechar) end
  if not str then str= readString(pointer+stringoffset,50,widechar) end
  if not str then str= readString(pointer+stringoffset,30,widechar) end
  if not str then
   local le=0
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
   while(true)do
    if le&gt;50 then break end
    if readBytes(pointer+stringoffset+le)==0 then break end
    le=le+1
   end
   str= readString(pointer+stringoffset,le)
  end
   --print(string.format('%X',pointer+0xC))
 end end
 if not str then return nil end
 if number&gt;0 then return str..'_'..number-1 end
 --print(str)
 FNameList[CFName]=str
 return str
end

function GetNameAlgo(object)
 if not object then return nil end
 if ObjectList[object] then --print(ObjectList[object])
   return ObjectList[object]
 end
 local fnameoffset=UObject.FNameIndex
 local typeoffset=UObject.Class
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 --print(string.format('%X',fnameoffset))
 --print(string.format('%X',object+fnameoffset))
 local str1=FNameStringAlgo(pointer+fnameoffset)
 local str2=FNameStringAlgo(object+fnameoffset)
 if not str2 then str2=FNameStringAlgo(object+fnameoffset-8)end
 if not str1 or str1=='None' or not str2 or str2=='None' then return nil end
 str1=str1..' '..str2
 --print(ObjectList[object])
 ObjectList[object]=str1
 return str1
end

function GetFullNameAlgo(object)
 if not object then return nil end
 --if ObjectList[object] then return ObjectList[object] end
 local pathoffset=UObject.Outer
 local fnameoffset=UObject.FNameIndex
 local str=GetNameAlgo(object)
 if not str then return nil end
 local number=readInteger(object+fnameoffset+4)
 local typ=str:sub(1,string.find(str,' ')-1)
 local isProperty=string.find(typ,'Property')
 if not isProperty then isProperty=string.find(typ,'Function') end
 local pointer=readPointer(object+pathoffset)
 while(true)do
  if not pointer or pointer==0 then break end
  local stri=GetNameAlgo(pointer)
  if not stri then break end
  typ=stri:sub(1,string.find(stri,' ')-1)
  local isPropertyc=string.find(typ,'Property')
  if not isPropertyc then isPropertyc=string.find(typ,'Function') end
  stri=string.sub(str,1,string.find(str,' '))..stri:sub(string.find(stri,' ')+1,stri:len())
  local num=readInteger(pointer+fnameoffset+4)

  if number~=num and num==0 or  not isPropertyc and isProperty then stri=stri..':'
  else stri=stri..'.' end
  number=num
  isProperty=isPropertyc

  str=stri..string.sub(str,string.find(str,' ')+1,str:len())
  pointer=readPointer(pointer+pathoffset)

  if string.find(str,'%./') then
    stri=string.sub(str,1,string.find(str,' '))
    str=stri..str:sub(string.find(str,'%./')+1,str:len())
  break end

 end
 if not str then return nil end
 --ObjectList[object]=str
 return str
end

function GetFullNameSuperAlgo(object)
  local super=UObject.super
  local str1 = GetFullNameAlgo(object)
  if not str1 then return nil end
  local pointer = readPointer(object+super)
  if pointer then
    local str2 = GetFullNameAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function GetFullNameSafeAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str3 then str3=GetFullNameSafeAlgo(pointer)end

 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 local str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end

function FindString(namestr,start,stop)
  for i=start,stop do
    local name=FNameStringAlgo(i,true)
    if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
      --print(name)
      if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
        if namestr==name then FNameResult=i return end
      end
    end
  end
end


function FindStringFName(namestr)
  local size
  if UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
  elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
  else size=math.floor(#FNameDict[1]/4) end
  local count=0x200
  size=math.floor((size/count)+0.5)
  ue4parsetablecheck()
  FNameResult=nil
  local result
  local num,start,stop=count,0,0
  for i=0,size do
    start=stop
    stop=stop+num
    if FNameResult then break end
    createThread(FindString(namestr,start,stop-1))
  end
  result=FNameResult
  FNameResult=nil
  return result
end

function hasProperty(object)
  local str1
  if UE4ver&gt;=25 then str1=GetFullNameSafeAlgo(object)
  else str1=GetFullNameAlgo(object) end
  if not str1 then return nil end
  local pointer =readPointer(object+UObject.Property)
  if pointer then
    local str2 = GetFullNameAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function printInheritC(class)
  for i=0,10 do
    if not class or class==0 then break end
    print(GetFullNameSuperAlgo(class))
    class=readPointer(class+UObject.super)
  end
end

function printInheritI(instance)
  instance=readPointer(instance+UObject.Class)
  printInheritC(instance)
end

function getregionsize(address)
local allregion=enumMemoryRegions()
 for i=#allregion,1,-1 do
  if allregion[i].BaseAddress&lt;=address then
   local BaseAddress=allregion[i].BaseAddress
   local RegionSize=allregion[i].RegionSize
   local curSize=BaseAddress+RegionSize-address
   return curSize,RegionSize,BaseAddress
  end
 end
end
--[[
function parsefrombig(tab,index,size)
 local datatable={}
 if not tab then return nil end
 for i=1,size do
  datatable[i]=tab[index+i]
 end
 return datatable
end
]]

function ue4parsetable()
 FNameList={}
 ObjectList={}
 FullNameList={}
 sub=targetIs64Bit() and 0 or 4
 local pool=getAddressSafe('FNamePool')
 local pool2=getAddressSafe('GUObjectArray')
 if pool and pool2 then
  if UE4ver&gt;=20 then GUObjectsize=readInteger(getAddress('GUObjectArray+24')-(sub*2))
  elseif UE4ver&gt;11 then  GUObjectsize=readInteger('GUObjectArray+1C')
  else GUObjectsize=readInteger(getAddress('GUObjectArray+8')-(sub*2))
  end
  FNameDict={}
  GUObjectDict={}
  for i=0,100 do
   local pointer
   if UE4ver&gt;=23 then pointer=readPointer(pool+i*(8-sub)+0x10)
   elseif UE4ver&gt;2 then  pointer=readPointer(readPointer(pool)+i*(8-sub))
   else pointer=readPointer(pool+i*(8-sub)) end
   if pointer and pointer~=0 then
    local size=getregionsize(pointer)
    if not size or size==0 then break end
    FNameDict[i+1]=readBytes(pointer,size-1,true)
   else break
   end
  end
  for i=0,100 do
   if UE4ver&gt;=20 then
    pointer=readPointer(readPointer(pool2+0x10)+i*(8-sub))
    if pointer and pointer~=0 then
    --print(string.format('%X',pointer))
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true)
    else break
    end
   elseif UE4ver&gt;11 then pointer=readPointer(pool2+0x10)
    if pointer and pointer~=0 then
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true) break
    else break end
   elseif UE4ver&gt;2 then pointer=readPointer(readPointer(pool2)+i*8+0x10)
    if pointer and pointer~=0 then
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true)
    else break end
   else pointer=readPointer(pool2)
    if pointer and pointer~=0 then
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true) break
    else break end
   end
  end
 end
end


function ue4parsetablecheck()
 if not FNameDict or not GUObjectDict then ue4parsetable()
 else
 local pointer,pointei,datatable,m
 if targetIs64Bit() then
   datatable={}
   for m=1,8 do datatable[m]=GUObjectDict[1][m]end
   pointer=byteTableToQword(datatable)
 else
   datatable={}
   for m=1,4 do datatable[m]=GUObjectDict[1][m]end
   pointer=byteTableToDword(datatable)
 end
 if UE4ver&gt;=20 then pointei=readPointer('[[GUObjectArray+10]]')
 elseif UE4ver&gt;11 then pointei=readPointer('[GUObjectArray+10]')
 elseif UE4ver&gt;2 then pointei=readPointer('[[GUObjectArray]+10]')
 else pointei=readPointer('[GUObjectArray]') end
 --print(string.format('%X',pointei))
 --print(string.format('%X',pointer))
 if pointei ~= pointer then ue4parsetable() end
 local GUObjectsizes
 if UE4ver&gt;=20 then GUObjectsizes=readInteger(getAddress('GUObjectArray+24')-(sub*2))
 elseif UE4ver&gt;11 then GUObjectsizes=readInteger('GUObjectArray+1C')
 else GUObjectsizes=readInteger(getAddress('GUObjectArray+8')-(sub*2)) end
 if GUObjectsizes~=GUObjectsize then ue4parsetable() end
 end
end

function FindObject(threadlist,ObjectId,address,size,i,start,stop,fullname)
  local pointer,datatable
  for j=start,stop do
    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end
    if pointer and pointer~=0 then
      local objid=readInteger(pointer+ObjectId)
      if objid and objid&lt;size then
        local name=GetFullNameAlgo(pointer)
        if name and string.find(name,' ') then
          name=string.sub(name,string.find(name,' ')+1,name:len())
          if not FullNameList[name]then FullNameList[name]=pointer end
          if FullNameList[fullname] then
            ObjectResult=FullNameList[fullname]
            for k,v in ipairs(threadlist) do v.terminate() end
            return
          end
        end
      end
    end
  end
end

function StaticFindObjectAlgo(fullname)
 ue4parsetablecheck()
 if FullNameList[fullname] then return FullNameList[fullname]end
 local threadlist={}
 local k=1
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local ObjectId=UObject.ObjectId
 ObjectResult=nil
 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess) do
    start=stop
    stop=stop+num
    if ObjectResult then break end
    threadlist[k]=createThread(FindObject(threadlist,ObjectId,GUObjectDict[i],size,i,start,stop-1,fullname))
    k=k+1
  end
 end
 local result=ObjectResult
 ObjectResult=nil
 return result
end

function registerFunc(ObjectId,address,size,i,start,stop)
  local funct=UObject.funct
  for j=start,stop do
    local pointer
    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end
    if pointer and pointer~=0 then
      local objid=readInteger(pointer+ObjectId)
      if objid and objid&lt;size then
        local name=GetFullNameAlgo(pointer)
        if name and string.find(name,' ') then
          local typ=string.sub(name,1,string.find(name,' ')-1)
          if typ=='Function' then
            local fullname=string.sub(name,string.find(name,' ')+1,name:len())
            local func=readPointer(pointer+funct)
            if func and func~=0 then extralist.addSymbol('UE',fullname,func,1)end
          end
        end
      end
    end
  end
end

function registerFuncAlgo()
 local funct=UObject.funct
 ue4parsetablecheck()
 if not extralist then
   extralist=createSymbolList()
   extralist.register()
 end
 if not enumUEObjIsRunning and UEObj then
   for i,v in ipairs(UEObj) do
     if v.Type=='Function' then
       local func=readPointer(v.Address+funct)
       if func and func~=0 then extralist.addSymbol('UE',v.FullName,func,1)end
     end
   end
 else
   local k=1
   local count=0x200
   local size=GUObjectsize
   local sizess= UE4ver&gt;2 and (targetIs64Bit() and 0x18*count or 0x10*count) or 0x4*count
   local ObjectId=UObject.ObjectId
   for i=1,#GUObjectDict do
    local num,start,stop=count,0,0
    for j=0,math.floor(#GUObjectDict[i]/sizess) do
      start=stop
      stop=stop+num
      if ObjectResult then break end
      createThread(registerFunc(ObjectId,GUObjectDict[i],size,i,start,stop-1))
      k=k+1
    end
   end
 end
end

function isStructExist(name)
for i=0,getStructureCount()-1 do
if(getStructure(i).getName()==name)then return getStructure(i) end
end
return false
end

function deletestruct(name)
local count=getStructureCount()
local structure
for i=0,count-1 do
structure=getStructure(i)
if(structure.getName()==name)then structure.removeFromGlobalStructureList() break end
end end

function ChildStructStart(structname,elementname)
local struct=isStructExist(structname)
if struct then
for i=0,struct.Count-1 do
if struct.Element[i].Name==elementname then return struct.Element[i].ChildStructStart end end
else return nil end
end

function findAddress(name,number,AddressOrAOBString,modulename,stopaddress,Nth,aobscanOnly,gethead,nop)
	local size,address=0x100
    AddressOrAOBString,address=string.lower(AddressOrAOBString):gsub('banana','')
	if(address&gt;0)then
		local f
		if(modulename==0 or modulename==nil or modulename=='')then f=AOBScan(AddressOrAOBString)
		else
            if type(modulename)==type(0) then modulename=string.format('%X',modulename)
            elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
			local ms = createMemScan()
			if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
				stopaddress=getNameFromAddress(getAddress(modulename),true,false)
                if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
				if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
                modulename=getAddress([["]]..stopaddress..[["]])
				stopaddress=modulename+getModuleSize(stopaddress)
                modulename=string.format('%X',modulename)
			end
			ms.firstScan(soExactValue,vtByteArray,rtTruncated,AddressOrAOBString,'',getAddress(modulename),getAddress(stopaddress),'',fsmNotAligned,'',true,false,false,false)
			ms.waitTillDone()
			f = createFoundList(ms)
			f.initialize()
			ms.destroy()
		end
		address={}
		for i=0,f.Count-1 do address[i+1]=f[i]end
		f.destroy()
        if Nth==nil or Nth==0 or Nth=='' then Nth=1 end
        if gethead then
           local addresss=GetAddressSafe(address[Nth])
           if not addresss then addresss=GetAddressSafe(address[Nth-1])end
           if addresss and addresss~=0 then
           for i=0,0x1000 do
               addresss=addresss-1
               if readBytes(addresss,1)==0xCC then break end
               if nop then local ext, opc, byt, add=splitDisassembledString(disassemble(addresss)) if string.find(opc,'nop') then addresss=addresss+getInstructionSize(addresss)-1 break end end
           end
           address[Nth]=addresss+1 end
        end
		if number==nil or number==0 or number=='' then
			if aobscanOnly then return address end
		else
            if(#address==0)then error(name..' aob no result found') end
            if(getAddress(address[Nth])==nil)then error(name..' aob result '..Nth..' doesnt exist') end
            unregisterSymbol(name)
            registerSymbol(name,getAddressSafe(address[Nth]),true)
            if aobscanOnly then return end
		end
		AddressOrAOBString=GetAddressSafe(address[Nth])
	end
    AddressOrAOBString=getAddressSafe(AddressOrAOBString)
	if(AddressOrAOBString==nil)then error(name..' still cant be found')end
	local addr={}
	local i=0
	local j=1
	while(i&lt;size) do
		local ext, opc, byt, add=splitDisassembledString(disassemble(getAddressSafe(AddressOrAOBString)+i))
		if(ext~="")then
			if(opc:find(",")~=nil)then
				opc=opc:sub(opc:find(",")+1,opc:len())
			else
				opc=opc:sub(opc:find(" ")+1,opc:len())
			end
			addr[j]=opc:gsub("%[",""):gsub("]","") j=j+1
		end
        if opc:find('],') then
            opc=opc:sub(opc:find("%[")+1,opc:find("]")-1)
            if tonumber(opc,16) then addr[j]=opc j=j+1 end
        end
		i=i+getInstructionSize(AddressOrAOBString+i)
	end
    --for i=1,#addr do print(addr[i]) end
	if number==nil or number==0 or number=='' then return addr end
	local offset
	if(type(number)==type(''))then
		offset=string.find(number,',')
		if(offset==nil)then number=getAddress(number)
		else offset=getAddress(string.sub(number,offset+1,number:len()))
			number=getAddress(string.sub(number,1,string.find(number,',')-1))
		end
	end
	if offset==nil then offset=0 end
	unregisterSymbol(name)
	registerSymbol(name,getAddressSafe(addr[number])-offset,true)
end

function ue4determineversion()
 local address=findAddress('FNamePool',0,'48 8D 0D *  *  *  *  E8 *  *  *  * 4C 8B C0 C6banana',process,nil,0,true)[1]
 if address then findAddress('FNamePool',1,address) UE4ver=25 ue4parsetable() ue4config()
  local address=getAddressSafe(StaticFindObjectAlgo('/Script/Engine.GameEngine'))
  if not address or address==0 then error('StaticFindObject not functioning as expected...')end
  UE4ver=nil
  local pointer=readPointer(address+UObject.member)
  if pointer then pointer=readPointer(pointer) if pointer then UE4ver=25 end end
  if not UE4ver then UE4ver=23 end
 else
  address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[1]
  if address then findAddress('FNamePool',1,address)
  else findAddress('FNamePool',1,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20banana',process,nil,2)end
  local address=readPointer('[[GUObjectArray+10]]+18')
  if address&gt;0x10000 then
   UE4ver=22
   ue4parsetable()
   ue4config()
   FNameStringAlgo(1,true)
   local address=getAddressSafe(StaticFindObjectAlgo('/Script/Engine.GameEngine'))
   if not address or address==0 then error('StaticFindObject not functioning as expected...')end
   UE4ver=nil
   local pointer=readPointer(address+UObject.member)
   if pointer then pointer=readPointer(pointer) if pointer then UE4ver=22 end end
   if not UE4ver then UE4ver=20 end
  else UE4ver=18 end
 end
end


function ue4createstruct(FullNameOrAddress,StructName,isGlobal,isfullname,Structu,AddedOffset,AddedName)
  if StructName and isStructExist(StructName) and isGlobal then return end
  local member,Offset,Property,bitmask,nextmember,super=UObject.member,UObject.Offset,UObject.Property,UObject.bitmask,UObject.nextmember,UObject.super
  local Object,Name,Class,PropName,Typ,Off,pointer,e,f=FullNameOrAddress
  local isUE425=UE4ver&gt;=25
  if type(FullNameOrAddress)==type('') then Object=StaticFindObjectAlgo(FullNameOrAddress) end
  if not Object then print(FullNameOrAddress..' not found...') return end
  Name=GetNameAlgo(Object)
  if not Name or not string.find(Name,' ') then print(FullNameOrAddress..' invalid Object?') return end
  if not StructName then
    Class=Name:sub(1,string.find(Name,' ')-1)
    Name=Name:sub(string.find(Name,' ')+1,Name:len())
  else Name=StructName end
  local Struct=Structu
  if not Struct then Struct=createStructure(Name)end
  if not AddedOffset then AddedOffset=0 end
  if not AddedName then AddedName='' end
  while(true)do
    if not Object or Object==0 then break end
    Name=GetNameAlgo(Object)
    if not Name then break end
    Name=Name:sub(string.find(Name,' ')+1,Name:len())
    if Name=='Object' then break end
    --print(GetFullNameAlgo(Object))
    pointer=readPointer(Object+UObject.member)
    while(true)do
      if not pointer or pointer==0 then break end
      PropName=isUE425 and GetFullNameSafeAlgo(pointer) or GetFullNameAlgo(pointer)
      if PropName and string.find(PropName,' ') then
        Typ=PropName:sub(1,string.find(PropName,' ')-1)
        if not string.find(Typ,'Function')then
          if not isfullname then PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())
          else PropName=PropName:sub(string.find(PropName,' ')+1,PropName:len())end
          PropName=AddedName..PropName
          Off=readInteger(pointer+Offset)+AddedOffset
          if Class=='UserDefinedStruct' and string.find(PropName,'_') then PropName=PropName:sub(1,string.find(PropName,'_')-1)end
          if Typ=='StructProperty' then ue4createstruct(readPointer(pointer+Property),nil,nil,isfullname,Struct,Off,PropName..'.')
          else
            e=Struct.addElement()
            e.Offset=Off
            e.Name=PropName
            if not ue4type[Typ] then e.Vartype=vtDword
            else e.Vartype=ue4type[Typ]end
            if Typ=='ArrayProperty' then
              f=Struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=Struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
            end
            if Typ=='BoolProperty' then e.ChildStructStart=readBytes(pointer+bitmask,1)end
          end
        end
      end
      pointer=readPointer(pointer+nextmember)
    end
    Object=readPointer(Object+super)
  end

  if Struct.Count==0 then return end
  if AddedOffset&gt;0 then return end

  if Struct.Element[Struct.Count-1].Offset&lt;=0x5000 then
    local count=Struct.Count-1
    local list,k,element1,element2,size,bytesize={},1
    for i=0,count do
        element1=Struct.Element[i]
        element2=Struct.Element[i+1]
        if element2 then
          bytesize=element1.Bytesize
          if bytesize&lt;4 then bytesize=4 end
          size=element2.Offset-element1.Offset-bytesize
          if size&gt;0 then
             if size%4&gt;0 then size=4-size%4+size end
             local start=element1.Offset
             if start%4&gt;0 then start=4-start%4+start
             else start=start+4 end
             size=size/4
             for j=0,size-1 do
               if (start+j*4)&gt;=(element1.Offset+bytesize) then
                 list[k]=start+j*4
                 k=k+1
               end
             end
           end
        end
      end
      for i,v in ipairs(list) do local e=Struct.addElement() e.Offset=v e.Vartype=vtDword end
    end

    if isGlobal then Struct.addToGlobalStructureList()end
end


function ue4createstructfast(fullnameortable,StructName,isGlobal,isfullname,structu,AddedOffset,AddedName)
  if StructName and isStructExist(StructName) and isGlobal then return end
  if not UEObj then enumUEObj() end
  local tabl=fullnameortable
  if type(fullnameortable)==type('') then
    for i,v in ipairs(UEObj) do if v.FullName==fullnameortable then tabl=v break end end
  end
  --[[
  if not tabl or type(tabl)~=type({})  then
    enumUEObj()
    if type(fullnameortable)==type('') then
      for i,v in ipairs(UEObj) do if v.FullName==fullnameortable then tabl=v break end end
    end
  end
  ]]
  if not tabl or type(tabl)~=type({})  then
    print(tostring(fullnameortable)..' not found...')
    return
  end
  local name=StructName
  if not name then name=tabl.Name end
  if not AddedOffset then AddedOffset=0 end
  local struct=structu
  if not struct then struct=createStructure(name)end
  if not AddedName then AddedName='' end
  --print(tostring(tabl))
  local isUserDefinedStruct=string.find(tabl.Type,'UserDefinedStruct')
  local e,typ,propname
  while(true)do
    if not tabl then break end
    if type(tabl)==type(1) or tabl.Name=='Object' then break end
    print(tostring(tabl.Type)..' '..tostring(tabl.FullName))
    if tabl.Member then
      for i=1,#tabl.Member do
        if tabl.Member[i].Type~='Function' then
          if isfullname then e.Name=string.format('%s %s%s',tabl.Member[i].Type,AddedName,tabl.Member[i].FullName)
          else
            propname=AddedName..tabl.Member[i].Name
            if isUserDefinedStruct then propname=propname:sub(1,string.find(propname,'_')-1) end
          end
          if tabl.Member[i].Type=='StructProperty' then ue4createstructfast(tabl.Member[i].Property,nil,nil,isfullname,struct,tabl.Member[i].Offset+AddedOffset,propname..'.')
          else
            e=struct.addElement()
            e.Offset=tabl.Member[i].Offset+AddedOffset
            typ=tabl.Member[i].Type
            e.Name=propname
            e.Vartype=ue4type[typ]
            if e.Vartype==nil then e.Vartype=vtDword end
          --if typ=='StructProperty' then for i=2,(v.Size/4) do local f=struct.addElement() f.Offset=e.Offset+i*4-4 f.Name=e.Name..'_'..i f.Vartype=e.Vartype end e.Name=e.Name
            if typ=='ArrayProperty' then
              local f=struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
              --[[
              if tabl.Member[i].Property.Name and tabl.Member[i].Property.Property.Name then
                local struc=createStructure(tabl.Member[i].Property.Name)
                ue4createstructfast(tabl.Member[i].Property.Property,isfullname and tabl.Member[i].Property.Property.FullName..'.' or tabl.Member[i].Property.Property.Name..'.',10,isfullname,struc)
                if struc.Count&gt;1 then e.ChildStruct=struc end
              end]]
            elseif typ=='BoolProperty' then e.ChildStructStart=tabl.Member[i].BitField end
          end
        end
      end
    end
    tabl=tabl.Parent
  end
  if struct.Count==0 then return end
  if AddedOffset&gt;0 then return end
  if struct.Element[struct.Count-1].Offset&lt;=0x5000 then
    local count=struct.Count-1
    local list,k,element1,element2,size,bytesize={},1
    for i=0,count do
      element1=struct.Element[i]
      element2=struct.Element[i+1]
      if element2 then
        bytesize=element1.Bytesize
        if bytesize&lt;4 then bytesize=4 end
        size=element2.Offset-element1.Offset-bytesize
        if size&gt;0 then
           if size%4&gt;0 then size=4-size%4+size end
           local start=element1.Offset
           if start%4&gt;0 then start=4-start%4+start
           else start=start+4 end
           size=size/4
           for j=0,size-1 do
             if (start+j*4)&gt;=(element1.Offset+bytesize) then
               list[k]=start+j*4
               k=k+1
             end
           end
        end
      end
    end
    for i,v in ipairs(list) do local e=struct.addElement() e.Offset=v e.Vartype=vtDword end
  end
  if isGlobal then struct.addToGlobalStructureList()end
end

function uecreatestruct(instance,name,depth,isfullname)
  local pointer=readPointer(instance+UObject.Class)
  local classname=GetFullNameAlgo(pointer)
  if not classname then print('instance is invalid') return end
  if classname:find(' ') then classname=classname:sub(classname:find(' ')+1) end

  print(string.format("createThread(ue4createstruct(\'%s\',\'%s\',0))",classname,name))
  ue4createstruct(pointer,name,depth,isfullname)
end

function ue_structureDissectOverrideCallback(Struct, Instance)
  --print('banana2')
  local name,fullname
  address,name,fullname=ue_findRealStartOfObject(Instance)

  if name then
   -- print('banana3')
    ue4createstructfast(fullname,nil,10,nil,Struct)
    if Struct.Count&gt;1 then return true
    else return false end
  end

  --ue_fillstruct(readPointer(Instance+UObject.Class),structure)
  --print('banana4')

  return nil
end

function ue_structureNameLookupCallback(address)
  --print('banana1')
  local name,fullname
  address,name,fullname=ue_findRealStartOfObject(address)
  if name then return name,address end
  return nil
end

function ue_findRealStartOfObject(address)
  local pointer=readPointer(address+UObject.Class)
  if pointer then
    local FullName=GetFullNameAlgo(pointer)
    if FullName then
      local Name=GetNameAlgo(pointer)
      FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
      Name=Name:sub(string.find(Name,' ')+1,Name:len())
      return address,Name,FullName
    end
  end

  if not UEObj then enumUEObj() end
  for i=1,#UEObj do
    if UEObj[i].MemberSize and UEObj[i].Class and UEObj[i].Class.MemberSize and UEObj[i].Class.MemberSize&gt;0 and not string.find(UEObj[i].Class.FullName,'/Script/CoreUObject.') then
       if address&gt;=UEObj[i].Address and address&lt;UEObj[i].Address+UEObj[i].Class.MemberSize then
         local name
         return UEObj[i].Address,UEObj[i].Class.Name,UEObj[i].Class.FullName
       end
    end
  end

  return address
end


function enumUEObjT(file,size,i,start,stop)
 local datatable,Address,FName,Name,FullName,typ,typ1,isProperty,l,pointer,stri,num,isPropertyc,EObj,k=0
 local Class,ObjectId,super,Offset,nextmember,member,propsize,bitmask,Property,Outer=UObject.Class,UObject.ObjectId,UObject.super,UObject.Offset,UObject.nextmember,UObject.member,UObject.propsize,UObject.bitmask,UObject.Property,UObject.Outer
 local UEver=UE4ver
 local pointersize= targetIs64Bit() and 8 or 4

 for j=start,stop do
    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      Address=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      Address=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      Address=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      Address=byteTableToDword(datatable)
    end

    if Address and Address~=0 then
       objid=readInteger(Address+ObjectId)
       if objid then
          if objid&lt;size then
             FullName=GetFullNameAlgo(Address)

             if FullName then
               isProperty=false
               typ1=FullName:sub(1,string.find(FullName,' ')-1)
               FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
               if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len()) isProperty=true
               elseif string.find(FullName,'%.') then Name=FullName:sub(string.find(FullName,'%.')+1,FullName:len())
               else Name=FullName end
               if UEObjIndex[FullName] and UEObj[UEObjIndex[FullName]] then UEObj[UEObjIndex[FullName]].Address=Address
               else
                 EObj={}
                 EObj.Address=Address
                 EObj.Id=objid
                 EObj.Class=temp[readPointer(Address+Class)]
                 EObj.Type=typ1
                 EObj.FullName=FullName
                 EObj.Name=Name
                 if isProperty then
                   isProperty=readPointer(Address+Outer)
                   if isProperty and isProperty~=0 then
                     EObj.Outer=isProperty
                     EObj.Size=readInteger(Address+propsize)
                     EObj.Offset=readInteger(Address+Offset)
                     if typ1=='BoolProperty' then EObj.BitField=readBytes(Address+bitmask,1)
                     elseif typ1=='StructProperty' or typ1=='ObjectProperty' or typ1=='ArrayProperty' then EObj.Property=readPointer(Address+Property)end
                   else print(FullName..' nil outer')
                   end
                 end

                 Parent=readPointer(Address+super)
                 if Parent and Parent~=0 then EObj.Parent=Parent end
                 temp[Address]=EObj
                 if UEver&gt;=25 then
                   k=1
                   EObj.MemberSize=readInteger(Address+member+pointersize)
                   Address=readPointer(Address+member)
                   EObj.Member={}

                   while(true)do
                     if UEver&gt;=25 then FullName=GetFullNameSafeAlgo(Address)
                     else FullName=GetFullNameAlgo(Address) end
                     if not FullName then break end

                     typ=FullName:sub(1,string.find(FullName,' ')-1)
                     FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
                     if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len())
                     else Name=FullName end
                     EObj.Member[k]={}
                     EObj.Member[k].Address=Address
                     EObj.Member[k].Type=typ
                     EObj.Member[k].FullName=FullName
                     EObj.Member[k].Name=Name
                     EObj.Member[k].Size=readInteger(Address+propsize)
                     EObj.Member[k].Offset=readInteger(Address+Offset)
                     if typ=='BoolProperty' then EObj.Member[k].BitField=readBytes(Address+bitmask,1)
                     elseif typ=='StructProperty' or typ=='ObjectProperty' or typ=='ArrayProperty' then EObj.Member[k].Property=readPointer(Address+Property)end
                     Address=readPointer(Address+nextmember)
                     k=k+1
                   end
                   if #EObj.Member==0 then EObj.Member=nil end
                 end
                 UEObj[#UEObj+1]=EObj
                 UEObjIndex[EObj.FullName]=#UEObj+1
               end
             end
          end
       end
    end
 end
--print(i..':'..k)
end

function enumUEObj(isSilent,isUpdateOnly)
 enumUEObjIsRunning=true
 local sub=targetIs64Bit() and 0 or 4
 ue4parsetablecheck()
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local starttime=os.time()
 if not isUpdateOnly then
   UEObj={}
   UEObjIndex={}
 end
 temp={}
 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess+0.5) do
   start=stop
   stop=stop+num
   createThread(enumUEObjT(file,size,i,start,stop-1))
  end
 end
 if not isUpdateOnly then
   if UE4ver&gt;=25 then
     for i=1,#UEObj do
       if UEObj[i].Parent then
         if temp[UEObj[i].Parent] then
           UEObj[i].Parent=temp[UEObj[i].Parent]
         end
       end
       if UEObj[i].Member then
         for j=1,#UEObj[i].Member do
           if UEObj[i].Member[j].Property then
             if temp[UEObj[i].Member[j].Property] then
               UEObj[i].Member[j].Property=temp[UEObj[i].Member[j].Property]
               local typ=UEObj[i].Member[j].Property.Type
               if typ and ( typ=='StructProperty' or typ=='ObjectProperty' or typ=='ArrayProperty' ) then
                 typ=temp[readPointer(UEObj[i].Member[j].Property.Address+UObject.Property)]
                 if typ then
                   UEObj[i].Member[j].Property.Property=typ
                 end
               end
             end
           end
         end
       end
     end
   else
     for i=1,#UEObj do
       if UEObj[i].Parent then
         if temp[UEObj[i].Parent] then
           UEObj[i].Parent=temp[UEObj[i].Parent]
         end
       end
       if UEObj[i].Outer then
         if temp[UEObj[i].Outer]then
           if temp[UEObj[i].Property] then
             UEObj[i].Property=temp[UEObj[i].Property]
             local typ=UEObj[i].Property.Type
             if typ and ( typ=='StructProperty' or typ=='ObjectProperty' or typ=='ArrayProperty' ) then
               typ=temp[readPointer(UEObj[i].Property.Address+UObject.Property)]
               if typ then
                 UEObj[i].Property.Property=typ
               end
             end
           end
           if not temp[UEObj[i].Outer].Member then temp[UEObj[i].Outer].Member={}end
           temp[UEObj[i].Outer].Member[#temp[UEObj[i].Outer].Member+1]=UEObj[i]
         else print(UEObj[i].FullName..' missing outer') end
       end
     end
   end
 end
 temp=nil
 enumUEObjIsRunning=false
 if not isSilent then print(string.format('\nA Total of %u objects had been enumerated in %u seconds',#UEObj,os.time()-starttime))end
end



function findOpcodes(address,opcode,size)
  if not size then size=0x50 end
  address=getAddressSafe(address)
  if not address then return nil end
  local addr={}
  local i=0
  local j=1
  while(i&lt;size) do
    local ext, opc, byt, add=splitDisassembledString(disassemble(address+i))
    if string.find(opc,opcode) then
      addr[j]=address+i
      j=j+1
    end
    i=i+getInstructionSize(address+i)
  end
  return addr
end

--local ext, opc, byt, add=splitDisassembledString(disassemble(findOpcodes('/Script/Astro.PrinterComponent:UpdatePreprinting_exec','call')[1]))
--return opc:sub(string.find(opc,' ')+1,opc:len())

function groupscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtGrouped,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function UEfindInstancesOfClass(fullnameOrAddress)
  local class,address=UObject.Class
  if type(fullnameOrAddress)==type('')then address=StaticFindObjectAlgo(fullnameOrAddress)
  else address=fullnameOrAddress end
  local fname=readInteger(address+UObject.FNameIndex)
  local result=groupscan(string.format('%u:%u 4:%u',targetIs64Bit() and 8 or 4,address,fname))
  for i,v in ipairs(result) do result[i]=tonumber(v,16)-class end
  return result
end

function StructAddToListSymbol(StructName,StartOffset,StopOffset,BaseAddress,OffsetOnly)
  if not StartOffset then StartOffset=0 end
  if not StopOffset then StopOffset=0xFFFFFF end
  local structCount=getStructureCount()
  local struct
  for i=0,structCount-1 do
    local stru=getStructure(i)
    if stru.Name==StructName then struct=stru break end
  end
  if struct then
    for i=0,struct.Count-1 do
      local e=struct.Element[i]
      if e.Offset&gt;=StartOffset and e.Offset&lt;=StopOffset then
        local rec=getAddressList().createMemoryRecord()
        rec.setDescription(e.Name)
        if OffsetOnly then
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.Offset[0]=e.Offset
          else rec.setAddress(string.format('+%X',e.Offset))end
        else
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.OffsetText[0]=StructName..'.'..e.Name
          else rec.setAddress(string.format('+%s.%s',StructName,e.Name))end
        end
        rec.Type=e.Vartype
      end
    end
  end
end

function getInsForJump(address,registername,destination,allocsize,SharedMemoryName)
  address = getAddressSafe(address)
  if not address then error('getInsForJump address nil') return end
  if not allocsize then allocsize=4096 end
  destination=getAddressSafe(destination)
  if not destination then
	if not SharedMemoryName then destination = allocateMemory(allocsize,address)
	else destination = allocateSharedMemory(SharedMemoryName,allocsize) end
  end
  local size = (address+5-destination&gt;0x7FFFFFFF) and 14 or 5
  if registername then
	unregisterSymbol(registername)
	registerSymbol(registername,destination,true)
  end
  local opcodes = {}
  local i = 0
  while(i&lt;size) do
    local ext, opc=splitDisassembledString(disassemble(address+i))
    opcodes[#opcodes+1] = opc
    i=i+getInstructionSize(address+i)
  end
  local copy = table.concat(opcodes,'\r\n')
  local readAsTable = true
  local byt = readBytes(address,i,readAsTable)
  for j=1,#byt do byt[j] = ('%02X'):format(byt[j]) end
  local bytes = table.concat(byt, ' ')
  return i,copy,bytes,size,destination
end

function enablescript(name,registername,addressname,script,disable)
    local address=getAddress(addressname)
    if disable then script=(script):format(address,registername,readBytes(registername,1))
    else
        local i,copy,bytes,size =getInsForJump(address,name)
        script=(script):format(registername, registername, name, copy, registername, i, bytes, address)..string.rep('nop\n',i-size)..'returnhere:'
    end
    local success,erro=autoAssembleCheck(script)
    if not success then print('\n'..erro..'\n')local scriptstr=createStringlist()scriptstr.Text=script for j=0,scriptstr.Count-1 do print(string.format('%u\t%s',j+1,scriptstr[j])) end
    if not disable then deAlloc(name)unregisterSymbol(name)end error(name..' autoAssemble failed')end
    autoAssemble(script)
    if disable then deAlloc(name)unregisterSymbol(name)unregisterSymbol(registername)end
end

function cycleFullCompact(sender,force)
local state = not(compactmenuitem.Caption == 'Compact View Mode')
if force~=nil
then state = not force
end
compactmenuitem.Caption = state and 'Compact View Mode' or 'Full View Mode'
getMainForm().Splitter1.Visible = state
getMainForm().Panel4.Visible = state
getMainForm().Panel5.Visible = state
end

function addCompactMenu()
if compactmenualreadyexists
then return end
local parent = getMainForm().Menu.Items
compactmenuitem = createMenuItem(parent)
parent.add(compactmenuitem)
compactmenuitem.Caption = 'Compact View Mode'
compactmenuitem.OnClick = cycleFullCompact
compactmenualreadyexists = 'yes'
end

addCompactMenu()
--cycleFullCompact(nil,true)

if syntaxcheck then return end

[ENABLE]
if not process or not enumModules()[1] then print('Error: No process selected...') error('process is nil') end
local starttime=os.time()
ue4versioncheck()

if targetIs64Bit() then

 local address=findAddress('GUObjectArray',0,'44 8B * * * 48 8D 05 * * * * * * * * * 48 89 71 10banana',process,nil,0,true)[1]
 if not address then address=findAddress('GUObjectArray',0,'40 53 48 83 EC 20 48 8B D9 48 85 D2 74 * 8Bbanana',process,nil,0,true)[1]end
 if not address then address=findAddress('GUObjectArray',0,'4C 8B 05 * * * * 45 3B 88banana',process,nil,0,true)[1]end
 if not address then error('GUObjectArray aob not found...')end
 findAddress('GUObjectArray',1,address)

 ue4config()

 if UE4ver&gt;=23 then findAddress('FNamePool',1,'48 8D 0D *  *  *  *  E8 *  *  *  * 4C 8B C0 C6banana',process)
 else
  address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[2]
  if not address then address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[1] end
  if address then findAddress('FNamePool',1,address)
  else findAddress('FNamePool',1,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20banana',process,nil,2)end
 end

 local address=findAddress('GEngine',0,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process,nil,0,true)[1]
 if not address then address=findAddress('GEngine',0,'48 8B 1D * * * * 48 85 DB 74 * 48 8Dbanana',process,nil,0,true)[1]end
 if not address then error('GEngine aob not found...')end
 findAddress('GEngine',1,address)
 --findAddress('GEngine',1,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process)

else
 ue4config()
 if UE4ver&gt;2 then
  findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  findAddress('GUObjectArray',1,'8B 44 24 04 56 8B F1 85 C0 74 17 8B 40 08banana',process)
  findAddress('FNamePool',1,'33 F6 89 35 * * * * 8B C6 5Ebanana',process,nil,1,nil,true,true)
 else
  findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  findAddress('FNamePool',1,'8B 07 8B 0D * * * * 8B 04 81banana',process)
  findAddress('GUObjectArray',1,'8B 15 * * * * 8B 04 82 85banana',process)
 end
end
print('AOBScan done : '..os.time()-starttime)
ue4parsetable()
--findAddress('GWorld',1,'4D 8B 94 24 50 0C 00 00banana',process)

FNameStringAlgo(1,true)

print('Table parsing done : '..os.time()-starttime)
if UE4ver&gt;2 then

 createThread(ue4createstruct('/Script/Engine.GameEngine','GameEngine',1))
 createThread(ue4createstruct('/Script/Engine.GameViewportClient','GameViewportClient',0))

 createThread(ue4createstruct('/Script/Engine.GameInstance','GameInstance',0))
 createThread(ue4createstruct('/Script/Engine.LocalPlayer','LocalPlayer',1))
 createThread(ue4createstruct('/Script/Engine.PlayerController','PlayerController',2))
 createThread(ue4createstruct('/Script/Engine.CharacterMovementComponent','MovementComponent',0))
 createThread(ue4createstruct('/Script/Engine.CapsuleComponent','CapsuleComponent',3))
 createThread(ue4createstruct('/Script/Engine.Character','GPlayer',0))

 createThread(ue4createstruct('/Script/Engine.World','World',0))

end

print('All done : '..os.time()-starttime..'\n')
sleep(1000)
GetLuaEngine().close()
[DISABLE]
--cycleFullCompact(nil,false)
unregisterSymbol('GEngine')
unregisterSymbol('GUObjectArray')
unregisterSymbol('FNamePool')

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>26079</ID>
                  <Description>"Enable ue_structureDissectCallback (Experimental)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
if not ue_structureDissectOverrideCallbackID then
  ue_structureDissectOverrideCallbackID=registerStructureDissectOverride(ue_structureDissectOverrideCallback)
end

if not ue_structureNameLookupCallbackID then
  ue_structureNameLookupCallbackID=registerStructureNameLookup(ue_structureNameLookupCallback)
end

 
 
[DISABLE]
unregisterStructureDissectOverride(ue_structureDissectOverrideCallbackID)
unregisterStructureNameLookup(ue_structureNameLookupCallbackID)
ue_structureDissectOverrideCallbackID=nil
ue_structureNameLookupCallbackID=nil
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26080</ID>
                  <Description>"Basic UE Object Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local Offset,ObjectId,nextmember,member,enumMul,Property=UObject.Offset,UObject.ObjectId,UObject.nextmember,UObject.member,UObject.enumMul,UObject.Property

function ue4dump(file,address,size,i,start,stop)
 local k=0
 local addy= targetIs64Bit() and 8 or 4
 local en= targetIs64Bit() and 0x40 or 0x2C
 local pointer,datatable,pointers,propname,offset,list,str,strid,name,objid
 for j=start,stop do

    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end

    if pointer and pointer~=0 then
       local objid=readInteger(pointer+ObjectId)
       if objid then
          if objid&lt;size then
             str=string.format('%016X',pointer)
             strid=string.format('%08u',objid)
             name=GetFullNameSuperAlgo(pointer,true)
             if name then
                 typ=name:sub(1,string.find(name,' ')-1)
                 if string.find(typ,'Property') then
                     if (typ=='StructProperty' or string.find(typ,'ObjectProperty') or string.find(typ,'ArrayProperty') ) and Property then
                       name=hasProperty(pointer)
                     end
                     strid=string.format('%8X',readInteger(pointer+Offset))
                 end

                 file:write(string.format('[%s] %s %s\n',strid,str,name))


                 if (typ=='UserDefinedEnum' or typ=='Enum') and enumMul then
                   list=pointer+en
                   for i=0,readInteger(list+8)-1 do
                     pointers=readPointer(list)+i*enumMul
                     offset=readBytes(pointers+addy,1)
                     if offset==0 then offset=i end
                     propname=FNameStringAlgo(pointers)
                     strid=string.format('%8X',offset)
                     str=string.format('%016X',pointers)
                     file:write(string.format('[%s] %s %s\n',strid,str,propname))
                   end
                 elseif typ=='MapProperty' and Property then
                   for n=0,1 do
                     pointers=readPointer(pointer+n*8+Property)
                     propname=hasProperty(pointers)
                     if propname then
                       offset=readInteger(pointers+Offset)
                       strid=string.format('%8X',offset)
                       str=string.format('%016X',pointers)
                       file:write(string.format('[%s] %s %s\n',strid,str,propname))
                     end
                   end
                 end

                 if UE4ver&gt;=25 then
                     local pointers= readPointer(pointer+member)
                     while(true)do
	                     propname=GetFullNameSafeAlgo(pointers)
	                     if not propname then break end
	                     offset=readInteger(pointers+Offset)
	                     strid=string.format('%8X',offset)
                         str=string.format('%016X',pointers)

                         typ=propname:sub(1,string.find(propname,' ')-1)
                         if typ=='StructProperty' or string.find(typ,'ObjectProperty') or string.find(typ,'ArrayProperty') then
                           propname=hasProperty(pointers)
                         end

	                     file:write(string.format('[%s] %s %s\n',strid,str,propname))

                         if typ=='MapProperty' then
                           for n=0,1 do
                             pointer=readPointer(pointers+n*8+Property)
                             propname=hasProperty(pointer)
                             if propname then
                               offset=readInteger(pointer+Offset)
                               strid=string.format('%8X',offset)
                               str=string.format('%016X',pointer)
                               file:write(string.format('[%s] %s %s\n',strid,str,propname))
                             end
                           end
                         end

	                     pointers=readPointer(pointers+nextmember)
                     end
                 end
                 k=k+1
             end
          end
       end
    end
 end
    totalobject=totalobject+k
--print(i..':'..k)
end


 local sub=targetIs64Bit() and 0 or 4
 ue4parsetablecheck()
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local starttime=os.time()
 local Path = 'C:\\test\\'
 local filename= string.format('[%s] ObjectsDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
--local re={rei1,rei2,rei3,rei4,rei5}
 totalobject=0
--allobject=createStringlist()

 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess+0.5) do
   start=stop
   stop=stop+num
   createThread(ue4dump(file,GUObjectDict[i],size,i,start,stop-1))
  end
 end


 file:close()
 print(string.format('\nA Total of %u objects had been dumped in %u seconds',totalobject,os.time()-starttime))
 print(Path..filename)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26081</ID>
                  <Description>"Basic UE Name Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function uenamedump(file,start,stop)
  for i=start,stop do
    local name=FNameStringAlgo(i,true)
    if name and name:len()&lt;200 and name:len()&gt;3 and not string.find(name,'%c')  then
      --print(name)
      local strid=string.format('%08X',i)

      file:write(string.format('[%s] %s\n',strid,name))
      totalname=totalname+1
    end
  end
end


 local size
 if UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
 elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
 else size=math.floor(#FNameDict[1]/4) end
 local count=0x200
 size=math.floor((size/count)+0.5)

 local starttime=os.time()
 local Path = 'C:\\test\\'
 local filename= string.format('[%s] NamesDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
 totalname=0
 ue4parsetablecheck()
 local num,start,stop=count,0,0
 for i=0,size do
   start=stop
   stop=stop+num
   createThread(uenamedump(file,start,stop-1))
 end
 file:close()
 print(string.format('\nA Total of %u names had been dumped in %u seconds',totalname,os.time()-starttime))
 print(Path..filename)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26082</ID>
                  <Description>"NoClip &amp; Fly                                            Numpad6 :Toggle, Space :Up, LeftCtrl :Down"</Description>
                  <Options moHideChildren="1" moDeactivateChildrenAsWell="1"/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end

[ENABLE]

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) &amp; ~ ChildStructStart('PlayerController','bActorEnableCollision')
writeBytes(address,bActorEnableCollision)
end

--[[
Enum /Script/Engine.EMovementMode
0:MOVE_None
1:MOVE_Walking
2:MOVE_NavWalking
3:MOVE_Falling
4:MOVE_Swimming
5:MOVE_Flying
6:MOVE_Custom
7:MOVE_MAX

local list=+0x40
for i=0,readInteger(list+8)-1 do
local pointer=readPointer(list)+i*0x10
local enum=readInteger(pointer+8)
local name=FNameString(pointer)
print(enum..':'..name)
end
]]


if not RelativeLocationZoffset then
  local address=getAddress('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  local value=readInteger(address+getAddress('CapsuleComponent.RelativeLocation.Z'))
  local list=groupscan(string.format('4:%u',value),address,address+0x1000)
  RelativeLocationZoffset={}
  for i=1,#list do
    RelativeLocationZoffset[i]=getAddress(list[i])-address
  end
end

updown = createTimer()
updown.Interval = 5
updown.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_SPACE) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])+20)
      end
    end
    if isKeyPressed(VK_LCONTROL) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])-20)
      end
    end
  end
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MovementMode')
  if address then
  writeBytes(address,5)
  end
end




[DISABLE]
updown.destroy()

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) | ChildStructStart('PlayerController','bActorEnableCollision')
writeBytes(address,bActorEnableCollision)
end

local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MovementMode')
if address then
writeBytes(address,1)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Toggle Activation</Action>
                      <Keys>
                        <Key>102</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                  </Hotkeys>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26083</ID>
                      <Description>"WASD"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
wasd = createTimer()
wasd.Interval = 5
wasd.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_S) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)+20)
      end
    end
    if isKeyPressed(VK_W) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)-20)
      end
    end
    if isKeyPressed(VK_A) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)+20)
      end
    end
    if isKeyPressed(VK_D) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)-20)
      end
    end
  end
end

[DISABLE]
wasd.destroy()
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>26084</ID>
                  <Description>"bCanBeDamaged false (Godmode)      Numpad4 :Deactive, Numpad5 :Active"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end

[ENABLE]
--CanBeDamaged = createTimer()
--CanBeDamaged.setInterval(1000)
--CanBeDamaged.OnTimer = function()
local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bCanBeDamaged')
if address then
local bCanBeDamaged=readBytes(address,1) &amp; ~ ChildStructStart('PlayerController','bCanBeDamaged')
writeBytes(address,bCanBeDamaged)
end
--end
 
 
[DISABLE]
--CanBeDamaged.destroy()

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bCanBeDamaged')
if address then
local bCanBeDamaged=readBytes(address,1) | ChildStructStart('PlayerController','bCanBeDamaged')
writeBytes(address,bCanBeDamaged)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>101</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>100</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26085</ID>
                  <Description>"Jump Multiplier                                       Numpad0 :Deactive, Numpad1 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
jumpmultiplier=1
if syntaxcheck then return end
if not jumpdefault then jumpdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')end
if not MaxAccelerationdefault then MaxAccelerationdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')end
if not AirControldefault then AirControldefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')end
[ENABLE]
jumpmuti=createHotkey(function()jumpmultiplier=jumpmultiplier+0.5 end,VK_NUMPAD1)
jump = createTimer()
jump.setInterval(1000)
jump.OnTimer = function()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')
local address2=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')
local address3=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')
if address then writeFloat(address,jumpdefault*jumpmultiplier)
writeFloat(address2,MaxAccelerationdefault*jumpmultiplier)
writeFloat(address3,AirControldefault*jumpmultiplier)
end
end
[DISABLE]
jump.destroy()
jumpmuti.destroy()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')
local address2=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')
local address3=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')
if address then writeFloat(address,jumpdefault)
writeFloat(address2,MaxAccelerationdefault)
writeFloat(address3,AirControldefault)
end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>97</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>96</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26086</ID>
                  <Description>"WalkSpeed Multiplier                             Numpad2 :Deactive, Numpad3 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
walkmultiplier=1
if syntaxcheck then return end
if not walkdefault then walkdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')end
[ENABLE]
walkpmuti=createHotkey(function() walkmultiplier=walkmultiplier+0.5 end,VK_NUMPAD3)
walk = createTimer()
walk.setInterval(1000)
walk.OnTimer = function()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')
if address then writeFloat(address,walkdefault*walkmultiplier)end
end
[DISABLE]
walk.destroy()
walkpmuti.destroy()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')
if address then writeFloat(address,walkdefault)end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>99</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>98</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26087</ID>
                  <Description>"UWorld"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>GameViewportClient.World</Offset>
                    <Offset>GameEngine.GameViewport</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>26088</ID>
                  <Description>"Player"</Description>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>PlayerController.Character</Offset>
                    <Offset>LocalPlayer.PlayerController</Offset>
                    <Offset>0</Offset>
                    <Offset>GameInstance.LocalPlayers</Offset>
                    <Offset>GameEngine.GameInstance</Offset>
                  </Offsets>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26089</ID>
                      <Description>"CharacterMovement"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <GroupHeader>1</GroupHeader>
                      <Address>+GPlayer.CharacterMovement</Address>
                      <Offsets>
                        <Offset>0</Offset>
                      </Offsets>
                      <CheatEntries>
                        <CheatEntry>
                          <ID>26090</ID>
                          <Description>"JumpZVelocity"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.JumpZVelocity</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26091</ID>
                          <Description>"MaxWalkSpeed"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxWalkSpeed</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26092</ID>
                          <Description>"MaxWalkSpeedCrouched"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxWalkSpeedCrouched</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26093</ID>
                          <Description>"MaxAcceleration"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxAcceleration</Address>
                        </CheatEntry>
                      </CheatEntries>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>26094</ID>
              <Description>"Tools"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>26095</ID>
                  <Description>"FNamePool scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
function stringscan(value,modulename,stopaddress,isUnicode)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtString,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,isUnicode,true)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end



createThread(function()
print('------------------')
local isUnicode=false
local strlist,result,result2,result3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  result=stringscan('IntProperty',getAddressSafe(strlist[i]),getAddressSafe(strlist[i]..'+50'),isUnicode)
  if #result&gt;0 then
    result=stringscan('None',getAddressSafe(strlist[i]..'-50'),getAddressSafe(strlist[i]),isUnicode)
    print(strlist[i])
    if #result&gt;0 then
      if string.sub(strlist[i],strlist[i]:len()-3,strlist[i]:len()-2)=='00' then
        result=pointerscan(getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00'))
        for j=1,#result do
          print(strlist[i]..'&lt;-'..result[j])
          if string.sub(result[j],result[j]:len()-1,result[j]:len())=='00' then
            result2=pointerscan(getAddressSafe(result[j]))
            for k=1,#result2 do
              print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
              result3=pointerscan(getAddressSafe(result2[k]),getAddress(process),getAddress(process)+getModuleSize(process))
              for l=1,#result3 do print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l]) end
            end
          end
        end
      end
    end
  end
end
print('done')
end)
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26096</ID>
                  <Description>"DissectCode (Memory View -&gt; Ctrl+J or (Tools -&gt; Dissect code) )"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26097</ID>
                      <Description>"Save DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
getDissectCode().saveToFile(path)
--getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>26098</ID>
                      <Description>"Load DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
--getDissectCode().saveToFile(path)
getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>26121</ID>
          <Description>"Dumper V4.2"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>26100</ID>
              <Description>"Unreal Engine"</Description>
              <Options moHideChildren="1"/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
function ue4config()
 local sub=targetIs64Bit() and 0 or 4
 UObject = {}
 if UE4ver&lt;=2 and targetIs64Bit() then ue4determineversion() end
-----------------------------
----------UE4 struct---------
 if UE4ver&gt;2 then

    UObject.ObjectId= 0xC-sub
    UObject.Class = 0x10-sub
    UObject.FNameIndex = 0x18-(sub*2)
    UObject.Outer = 0x20-(sub*2)

    UObject.enumMul= 0x10

  if UE4ver&gt;=25 then
    UObject.super= 0x40
    UObject.member= 0x50
    UObject.nextmember= 0x20
    UObject.Offset= 0x4C
    UObject.propsize=0x3C
    UObject.bitmask= 0x7A

    UObject.Property= 0x78

  elseif UE4ver&gt;=22 then
    UObject.super= 0x40
    UObject.member= 0x48
  else
    UObject.super= 0x30 -(sub*4)
    UObject.member= 0x38 -(sub*5)
  end

  if UE4ver&lt;25 then
    UObject.nextmember=0x28-(sub*3)
    UObject.Offset= 0x44-(sub*4)
    UObject.propsize= 0x34-(sub*3/2)
    UObject.bitmask= 0x72-(sub*8)

    UObject.Property= 0x70

  end

  if UE4ver&lt;11 then
    UObject.Offset= 0x4C
    UObject.enumMul= 0xC
  end

----------------------------
---------UE3 struct---------
--1.25
 elseif UE4ver&gt;=1 then
    UObject.ObjectId= 0x4
    UObject.Outer = 0x14
    UObject.FNameIndex = 0x18
    UObject.Class = 0x20
    UObject.Offset= 0x48
    UObject.super= 0x34
    UObject.member= 0x38
    UObject.nextmember=0x28
    UObject.propsize= 0x30
    UObject.bitmask= 0x60
    UObject.Property= 0x58
    UObject.enumMul= 0x8


--0.10246
 else
    UObject.ObjectId= 0x20
    UObject.Outer = 0x28
    UObject.FNameIndex = 0x2C
    UObject.Class = 0x34

    UObject.Offset= 0x60

    UObject.super= 0x48
    UObject.member= 0x4C

    UObject.nextmember=0x3C
    UObject.propsize= 0x44
    UObject.bitmask= 0x70
 end

---------------------------
end


local ue4type={
		['BoolProperty']=vtByte,
		['ByteProperty']=vtByte,
		['FloatProperty']=vtSingle,
        ['StructProperty']=vtDword,
		['IntProperty']=vtDword,
        ['NameProperty']=vtQword,
        ['Int64Property']=vtQword,
		['TextProperty']=vtPointer,
        ['StrProperty']=vtPointer,
        ['ArrayProperty']=vtPointer,
        ['MapProperty']=vtPointer,
        ['ClassProperty']=vtPointer,
		['ObjectProperty']=vtPointer}

function ue4versioncheck()
 local fileversion,info =getFileVersion(enumModules()[1].PathToFile)
 if not info then UE4ver=0 return end
--return info.minor
 UE4ver=tonumber(info.minor..'.'..info.release)
end

function FNameStringAlgo(FName,IndexOnly)
 if not FName then return nil end
 local UEver=UE4ver
 local sub=targetIs64Bit() and 0 or 4
 local number,str,datatable
 if not IndexOnly then
   number=UEver&gt;2 and readInteger(FName+4) or 0
   FName=readInteger(FName)
 else number=FName&gt;&gt;32 FName=FName&amp;0xFFFFFFFF
 end
 if not FName then return nil end
 if FNameList[FName] then
   if number&gt;0 then return FNameList[FName]..'_'..number-1 end
   return FNameList[FName]
 end
 local CFName=FName
 if UEver&gt;=23 then
  local i=(FName&gt;&gt;0x10)+1
  FName=(FName&amp;0xFFFF)*2
  if i&gt;#FNameDict or FName&gt;#FNameDict[i] then return nil end
  datatable={}
  for m=1,2 do
    datatable[m]=FNameDict[i][FName+m]
  end

  local le = byteTableToWord(datatable)
  if not le then return nil end
  le=le&gt;&gt;6
  if le&gt;200 then return nil end
  local widechar=true and FNameDict[i][FName+1]&amp;1==1 or false
  if widechar then
    datatable={}
    for m=1,le*2 do
      datatable[m]=FNameDict[i][FName+2+m]
    end
    str=byteTableToWideString(datatable)
  else
    datatable={}
    for m=1,le do
      datatable[m]=FNameDict[i][FName+2+m]
    end
    str=byteTableToString(datatable)
  end
 else
  local i
  if UEver&gt;2 then
   i=(FName&gt;&gt;0xE)+1
   FName=(FName&amp;0x3FFF)*(8-sub)
  else i=1 FName=FName*(8-sub) end
  if i&gt;#FNameDict or FName&gt;#FNameDict[i] then return nil end
  local pointer
  if targetIs64Bit() then
    datatable={}
    for m=1,8 do
      datatable[m]=FNameDict[i][FName+m]
    end
    pointer=byteTableToQword(datatable)
  else
    datatable={}
    for m=1,4 do
      datatable[m]=FNameDict[i][FName+m]
    end
    pointer=byteTableToDword(datatable)
  end
  if not pointer or pointer==0 then return nil end

  --local offset=UE4ver&gt;=22 and 0xC-sub or 0x10-(sub*2)
  if FName==1 and not stringoffset or not stringoffsetid then
     str=readString(pointer+8,13)
     if str=='ByteProperty' then stringoffset=8
     else str=readString(pointer+0xC,13)
         if str=='ByteProperty' then stringoffset=0xC
         else str=readString(pointer+0x10,13)
             if str=='ByteProperty' then stringoffset=0x10 end
         end
     end

     for j=0, stringoffset-4,4 do
       if readInteger(pointer+j)==2 then stringoffsetid=j end
     end
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
  --print(string.format('%X',offset))

  else
  local widechar=true and readInteger(pointer+stringoffsetid)&amp;1==1 and UEver&gt;2 or false
  str= readString(pointer+stringoffset,200,widechar)
  if not str then str= readString(pointer+stringoffset,100,widechar) end
  if not str then str= readString(pointer+stringoffset,50,widechar) end
  if not str then str= readString(pointer+stringoffset,30,widechar) end
  if not str then
   local le=0
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
   while(true)do
    if le&gt;50 then break end
    if readBytes(pointer+stringoffset+le)==0 then break end
    le=le+1
   end
   str= readString(pointer+stringoffset,le)
  end
   --print(string.format('%X',pointer+0xC))
 end end
 if not str then return nil end
 if number&gt;0 then return str..'_'..number-1 end
 --print(str)
 FNameList[CFName]=str
 return str
end

function GetNameAlgo(object)
 if not object then return nil end
 if ObjectList[object] then --print(ObjectList[object])
   return ObjectList[object]
 end
 local fnameoffset=UObject.FNameIndex
 local typeoffset=UObject.Class
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 --print(string.format('%X',fnameoffset))
 --print(string.format('%X',object+fnameoffset))
 local str1=FNameStringAlgo(pointer+fnameoffset)
 local str2=FNameStringAlgo(object+fnameoffset)
 if not str2 then str2=FNameStringAlgo(object+fnameoffset-8)end
 if not str1 or str1=='None' or not str2 or str2=='None' then return nil end
 str1=str1..' '..str2
 --print(ObjectList[object])
 ObjectList[object]=str1
 return str1
end

function GetFullNameAlgo(object)
 if not object then return nil end
 --if ObjectList[object] then return ObjectList[object] end
 local pathoffset=UObject.Outer
 local fnameoffset=UObject.FNameIndex
 local str=GetNameAlgo(object)
 if not str then return nil end
 local number=readInteger(object+fnameoffset+4)
 local typ=str:sub(1,string.find(str,' ')-1)
 local isProperty=string.find(typ,'Property')
 if not isProperty then isProperty=string.find(typ,'Function') end
 local pointer=readPointer(object+pathoffset)
 while(true)do
  if not pointer or pointer==0 then break end
  local stri=GetNameAlgo(pointer)
  if not stri then break end
  typ=stri:sub(1,string.find(stri,' ')-1)
  local isPropertyc=string.find(typ,'Property')
  if not isPropertyc then isPropertyc=string.find(typ,'Function') end
  stri=string.sub(str,1,string.find(str,' '))..stri:sub(string.find(stri,' ')+1,stri:len())
  local num=readInteger(pointer+fnameoffset+4)

  if number~=num and num==0 or  not isPropertyc and isProperty then stri=stri..':'
  else stri=stri..'.' end
  number=num
  isProperty=isPropertyc

  str=stri..string.sub(str,string.find(str,' ')+1,str:len())
  pointer=readPointer(pointer+pathoffset)

  if string.find(str,'%./') then
    stri=string.sub(str,1,string.find(str,' '))
    str=stri..str:sub(string.find(str,'%./')+1,str:len())
  break end

 end
 if not str then return nil end
 --ObjectList[object]=str
 return str
end

function GetFullNameSuperAlgo(object)
  local super=UObject.super
  local str1 = GetFullNameAlgo(object)
  if not str1 then return nil end
  local pointer = readPointer(object+super)
  if pointer then
    local str2 = GetFullNameAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function GetFullNameSafesAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 local str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end


function GetFullNameSafeAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str3 then str3=GetFullNameSafesAlgo(pointer)end

 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 local str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end

function FindString(namestr,start,stop)
  for i=start,stop do
    local name=FNameStringAlgo(i,true)
    if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
      --print(name)
      if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
        if namestr==name then FNameResult=i return end
      end
    end
  end
end


function FindStringFName(namestr)
  local size
  if UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
  elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
  else size=math.floor(#FNameDict[1]/4) end
  local count=0x200
  size=math.floor((size/count)+0.5)
  ue4parsetablecheck()
  FNameResult=nil
  local result
  local num,start,stop=count,0,0
  for i=0,size do
    start=stop
    stop=stop+num
    if FNameResult then break end
    createThread(FindString(namestr,start,stop-1))
  end
  result=FNameResult
  FNameResult=nil
  return result
end

function hasProperty(object)
  local str1
  if UE4ver&gt;=25 then str1=GetFullNameSafeAlgo(object)
  else str1=GetFullNameAlgo(object) end
  if not str1 then return nil end
  local pointer =readPointer(object+UObject.Property)
  if pointer then
    local str2 = GetFullNameAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function printInheritC(class)
  for i=0,10 do
    if not class or class==0 then break end
    print(GetFullNameSuperAlgo(class))
    class=readPointer(class+UObject.super)
  end
end

function printInheritI(instance)
  instance=readPointer(instance+UObject.Class)
  printInheritC(instance)
end

function getregionsize(address)
local allregion=enumMemoryRegions()
 for i=#allregion,1,-1 do
  if allregion[i].BaseAddress&lt;=address then
   local BaseAddress=allregion[i].BaseAddress
   local RegionSize=allregion[i].RegionSize
   local curSize=BaseAddress+RegionSize-address
   return curSize,RegionSize,BaseAddress
  end
 end
end
--[[
function parsefrombig(tab,index,size)
 local datatable={}
 if not tab then return nil end
 for i=1,size do
  datatable[i]=tab[index+i]
 end
 return datatable
end
]]

function ue4parsetable()
 FNameList={}
 ObjectList={}
 FullNameList={}
 sub=targetIs64Bit() and 0 or 4
 local pool=getAddressSafe('FNamePool')
 local pool2=getAddressSafe('GUObjectArray')
 if pool and pool2 then
  if UE4ver&gt;=20 then GUObjectsize=readInteger(getAddress('GUObjectArray+24')-(sub*2))
  elseif UE4ver&gt;11 then  GUObjectsize=readInteger('GUObjectArray+1C')
  else GUObjectsize=readInteger(getAddress('GUObjectArray+8')-(sub*2))
  end
  FNameDict={}
  GUObjectDict={}
  for i=0,500 do
   local pointer
   if UE4ver&gt;=23 then pointer=readPointer(pool+i*(8-sub)+0x10)
   elseif UE4ver&gt;2 then  pointer=readPointer(readPointer(pool)+i*(8-sub))
   else pointer=readPointer(pool+i*(8-sub)) end
   if pointer and pointer~=0 then
    local size=getregionsize(pointer)
    if not size or size==0 then break end
    FNameDict[i+1]=readBytes(pointer,size-1,true)
   else break
   end
  end
  for i=0,500 do
   if UE4ver&gt;=20 then
    pointer=readPointer(readPointer(pool2+0x10)+i*(8-sub))
    if pointer and pointer~=0 then
    --print(string.format('%X',pointer))
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true)
    else break
    end
   elseif UE4ver&gt;11 then pointer=readPointer(pool2+0x10)
    if pointer and pointer~=0 then
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true) break
    else break end
   elseif UE4ver&gt;2 then pointer=readPointer(readPointer(pool2)+i*8+0x10)
    if pointer and pointer~=0 then
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true)
    else break end
   else pointer=readPointer(pool2)
    if pointer and pointer~=0 then
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true) break
    else break end
   end
  end
 end
end


function ue4parsetablecheck()
 if not FNameDict or not GUObjectDict then ue4parsetable()
 else
 local pointer,pointei,datatable,m
 if targetIs64Bit() then
   datatable={}
   for m=1,8 do datatable[m]=GUObjectDict[1][m]end
   pointer=byteTableToQword(datatable)
 else
   datatable={}
   for m=1,4 do datatable[m]=GUObjectDict[1][m]end
   pointer=byteTableToDword(datatable)
 end
 if UE4ver&gt;=20 then pointei=readPointer('[[GUObjectArray+10]]')
 elseif UE4ver&gt;11 then pointei=readPointer('[GUObjectArray+10]')
 elseif UE4ver&gt;2 then pointei=readPointer('[[GUObjectArray]+10]')
 else pointei=readPointer('[GUObjectArray]') end
 --print(string.format('%X',pointei))
 --print(string.format('%X',pointer))
 if pointei ~= pointer then ue4parsetable() end
 local GUObjectsizes
 if UE4ver&gt;=20 then GUObjectsizes=readInteger(getAddress('GUObjectArray+24')-(sub*2))
 elseif UE4ver&gt;11 then GUObjectsizes=readInteger('GUObjectArray+1C')
 else GUObjectsizes=readInteger(getAddress('GUObjectArray+8')-(sub*2)) end
 if GUObjectsizes~=GUObjectsize then ue4parsetable() end
 end
end

function FindObject(threadlist,ObjectId,address,size,i,start,stop,fullname)
  local pointer,datatable
  for j=start,stop do
    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end
    if pointer and pointer~=0 then
      local objid=readInteger(pointer+ObjectId)
      if objid and objid&lt;size then
        local name=GetFullNameAlgo(pointer)
        if name and string.find(name,' ') then
          name=string.sub(name,string.find(name,' ')+1,name:len())
          if not FullNameList[name]then FullNameList[name]=pointer end
          if FullNameList[fullname] then
            ObjectResult=FullNameList[fullname]
            for k,v in ipairs(threadlist) do v.terminate() end
            return
          end
        end
      end
    end
  end
end

function StaticFindObjectAlgo(fullname)
 ue4parsetablecheck()
 if FullNameList[fullname] then return FullNameList[fullname]end
 local threadlist={}
 local k=1
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local ObjectId=UObject.ObjectId
 ObjectResult=nil
 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess) do
    start=stop
    stop=stop+num
    if ObjectResult then break end
    threadlist[k]=createThread(FindObject(threadlist,ObjectId,GUObjectDict[i],size,i,start,stop-1,fullname))
    k=k+1
  end
 end
 local result=ObjectResult
 ObjectResult=nil
 return result
end

function registerFunc(ObjectId,address,size,i,start,stop)
  local funct=UObject.funct
  for j=start,stop do
    local pointer
    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end
    if pointer and pointer~=0 then
      local objid=readInteger(pointer+ObjectId)
      if objid and objid&lt;size then
        local name=GetFullNameAlgo(pointer)
        if name and string.find(name,' ') then
          local typ=string.sub(name,1,string.find(name,' ')-1)
          if typ=='Function' then
            local fullname=string.sub(name,string.find(name,' ')+1,name:len())
            local func=readPointer(pointer+funct)
            if func and func~=0 then extralist.addSymbol('UE',fullname,func,1)end
          end
        end
      end
    end
  end
end

function registerFuncAlgo()
 local funct=UObject.funct
 ue4parsetablecheck()
 if not extralist then
   extralist=createSymbolList()
   extralist.register()
 end
 if not enumUEObjIsRunning and UEObj then
   for i,v in ipairs(UEObj) do
     if v.Type=='Function' then
       local func=readPointer(v.Address+funct)
       if func and func~=0 then extralist.addSymbol('UE',v.FullName,func,1)end
     end
   end
 else
   local k=1
   local count=0x200
   local size=GUObjectsize
   local sizess= UE4ver&gt;2 and (targetIs64Bit() and 0x18*count or 0x10*count) or 0x4*count
   local ObjectId=UObject.ObjectId
   for i=1,#GUObjectDict do
    local num,start,stop=count,0,0
    for j=0,math.floor(#GUObjectDict[i]/sizess) do
      start=stop
      stop=stop+num
      if ObjectResult then break end
      createThread(registerFunc(ObjectId,GUObjectDict[i],size,i,start,stop-1))
      k=k+1
    end
   end
 end
end

function isStructExist(name)
for i=0,getStructureCount()-1 do
if(getStructure(i).getName()==name)then return getStructure(i) end
end
return false
end

function deletestruct(name)
local count=getStructureCount()
local structure
for i=0,count-1 do
structure=getStructure(i)
if(structure.getName()==name)then structure.removeFromGlobalStructureList() break end
end end

function ChildStructStart(structname,elementname)
local struct=isStructExist(structname)
if struct then
for i=0,struct.Count-1 do
if struct.Element[i].Name==elementname then return struct.Element[i].ChildStructStart end end
else return nil end
end

function findAddress(name,number,AddressOrAOBString,modulename,stopaddress,Nth,aobscanOnly,gethead,nop)
	local size,address=0x100
    AddressOrAOBString,address=string.lower(AddressOrAOBString):gsub('banana','')
	if(address&gt;0)then
		local f
		if(modulename==0 or modulename==nil or modulename=='')then f=AOBScan(AddressOrAOBString)
		else
            if type(modulename)==type(0) then modulename=string.format('%X',modulename)
            elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
			local ms = createMemScan()
			if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
				stopaddress=getNameFromAddress(getAddress(modulename),true,false)
                if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
				if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
                modulename=getAddress([["]]..stopaddress..[["]])
				stopaddress=modulename+getModuleSize(stopaddress)
                modulename=string.format('%X',modulename)
			end
			ms.firstScan(soExactValue,vtByteArray,rtTruncated,AddressOrAOBString,'',getAddress(modulename),getAddress(stopaddress),'',fsmNotAligned,'',true,false,false,false)
			ms.waitTillDone()
			f = createFoundList(ms)
			f.initialize()
			ms.destroy()
		end
		address={}
		for i=0,f.Count-1 do address[i+1]=f[i]end
		f.destroy()
        if Nth==nil or Nth==0 or Nth=='' then Nth=1 end
        if gethead then
           local addresss=GetAddressSafe(address[Nth])
           if not addresss then addresss=GetAddressSafe(address[Nth-1])end
           if addresss and addresss~=0 then
           for i=0,0x1000 do
               addresss=addresss-1
               if readBytes(addresss,1)==0xCC then break end
               if nop then local ext, opc, byt, add=splitDisassembledString(disassemble(addresss)) if string.find(opc,'nop') then addresss=addresss+getInstructionSize(addresss)-1 break end end
           end
           address[Nth]=addresss+1 end
        end
		if number==nil or number==0 or number=='' then
			if aobscanOnly then return address end
		else
            if(#address==0)then error(name..' aob no result found') end
            if(getAddress(address[Nth])==nil)then error(name..' aob result '..Nth..' doesnt exist') end
            unregisterSymbol(name)
            registerSymbol(name,getAddressSafe(address[Nth]),true)
            if aobscanOnly then return end
		end
		AddressOrAOBString=GetAddressSafe(address[Nth])
	end
    AddressOrAOBString=getAddressSafe(AddressOrAOBString)
	if(AddressOrAOBString==nil)then error(name..' still cant be found')end
	local addr={}
	local i=0
	local j=1
	while(i&lt;size) do
		local ext, opc, byt, add=splitDisassembledString(disassemble(getAddressSafe(AddressOrAOBString)+i))
		if(ext~="")then
			if(opc:find(",")~=nil)then
				opc=opc:sub(opc:find(",")+1,opc:len())
			else
				opc=opc:sub(opc:find(" ")+1,opc:len())
			end
			addr[j]=opc:gsub("%[",""):gsub("]","") j=j+1
		end
        if opc:find('],') then
            opc=opc:sub(opc:find("%[")+1,opc:find("]")-1)
            if tonumber(opc,16) then addr[j]=opc j=j+1 end
        end
		i=i+getInstructionSize(AddressOrAOBString+i)
	end
    --for i=1,#addr do print(addr[i]) end
	if number==nil or number==0 or number=='' then return addr end
	local offset
	if(type(number)==type(''))then
		offset=string.find(number,',')
		if(offset==nil)then number=getAddress(number)
		else offset=getAddress(string.sub(number,offset+1,number:len()))
			number=getAddress(string.sub(number,1,string.find(number,',')-1))
		end
	end
	if offset==nil then offset=0 end
	unregisterSymbol(name)
	registerSymbol(name,getAddressSafe(addr[number])-offset,true)
end

function ue4determineversion()
 local address=findAddress('FNamePool',0,'48 8D 0D *  *  *  *  E8 *  *  *  * 4C 8B C0 C6banana',process,nil,0,true)[1]
 if address then findAddress('FNamePool',1,address) UE4ver=25 ue4parsetable() ue4config()
  local address=getAddressSafe(StaticFindObjectAlgo('/Script/Engine.GameEngine'))
  if not address or address==0 then error('StaticFindObject not functioning as expected...')end
  UE4ver=nil
  local pointer=readPointer(address+UObject.member)
  if pointer then pointer=readPointer(pointer) if pointer then UE4ver=25 end end
  if not UE4ver then UE4ver=23 end
 else
  address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[1]
  if address then findAddress('FNamePool',1,address)
  else findAddress('FNamePool',1,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20banana',process,nil,2)end
  local address=readPointer('[[GUObjectArray+10]]+18')
  if address&gt;0x10000 then
   UE4ver=22
   ue4parsetable()
   ue4config()
   FNameStringAlgo(1,true)
   local address=getAddressSafe(StaticFindObjectAlgo('/Script/Engine.GameEngine'))
   if not address or address==0 then error('StaticFindObject not functioning as expected...')end
   UE4ver=nil
   local pointer=readPointer(address+UObject.member)
   if pointer then pointer=readPointer(pointer) if pointer then UE4ver=22 end end
   if not UE4ver then UE4ver=20 end
  else UE4ver=18 end
 end
end


function ue4createstruct(FullNameOrAddress,StructName,isGlobal,isfullname,Structu,AddedOffset,AddedName)
  if StructName and isStructExist(StructName) and isGlobal then return end
  local member,Offset,Property,bitmask,nextmember,super=UObject.member,UObject.Offset,UObject.Property,UObject.bitmask,UObject.nextmember,UObject.super
  local Object,Name,Class,PropName,Typ,Off,pointer,e,f=FullNameOrAddress
  local isUE425=UE4ver&gt;=25
  if type(FullNameOrAddress)==type('') then Object=StaticFindObjectAlgo(FullNameOrAddress) end
  if not Object then print(FullNameOrAddress..' not found...') return end
  Name=GetNameAlgo(Object)
  if not Name or not string.find(Name,' ') then print(FullNameOrAddress..' invalid Object?') return end
  if not StructName then
    Class=Name:sub(1,string.find(Name,' ')-1)
    Name=Name:sub(string.find(Name,' ')+1,Name:len())
  else Name=StructName end
  local Struct=Structu
  if not Struct then Struct=createStructure(Name)end
  if not AddedOffset then AddedOffset=0 end
  if not AddedName then AddedName='' end
  while(true)do
    if not Object or Object==0 then break end
    Name=GetNameAlgo(Object)
    if not Name then break end
    Name=Name:sub(string.find(Name,' ')+1,Name:len())
    if Name=='Object' then break end
    --print(GetFullNameAlgo(Object))
    pointer=readPointer(Object+UObject.member)
    while(true)do
      if not pointer or pointer==0 then break end
      PropName=isUE425 and GetFullNameSafeAlgo(pointer) or GetFullNameAlgo(pointer)
      if PropName and string.find(PropName,' ') then
        Typ=PropName:sub(1,string.find(PropName,' ')-1)
        if not string.find(Typ,'Function')then
          if not isfullname then PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())
          else PropName=PropName:sub(string.find(PropName,' ')+1,PropName:len())end
          PropName=AddedName..PropName
          Off=readInteger(pointer+Offset)+AddedOffset
          if Class=='UserDefinedStruct' and string.find(PropName,'_') then PropName=PropName:sub(1,string.find(PropName,'_')-1)end
          if Typ=='StructProperty' then
            ue4createstruct(readPointer(pointer+Property),nil,nil,isfullname,Struct,Off,PropName..'.')
            if not getElementByOffset(Struct,Off) then e=Struct.addElement() e.Offset=Off e.Name=PropName e.Vartype=vtDword end
          else
            e=Struct.addElement()
            e.Offset=Off
            e.Name=PropName
            if not ue4type[Typ] then e.Vartype=vtDword
            else e.Vartype=ue4type[Typ]end
            if Typ=='ArrayProperty' then
              f=Struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=Struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
            end
            if Typ=='BoolProperty' then e.ChildStructStart=readBytes(pointer+bitmask,1)end
          end
        end
      end
      pointer=readPointer(pointer+nextmember)
    end
    Object=readPointer(Object+super)
  end

  if Struct.Count==0 then return end
  if AddedOffset&gt;0 then return end

  if Struct.Element[Struct.Count-1].Offset&lt;=0x5000 then
    local count=Struct.Count-1
    local list,k,element1,element2,size,bytesize={},1
    for i=0,count do
        element1=Struct.Element[i]
        element2=Struct.Element[i+1]
        if element2 then
          bytesize=element1.Bytesize
          if bytesize&lt;4 then bytesize=4 end
          size=element2.Offset-element1.Offset-bytesize
          if size&gt;0 then
             if size%4&gt;0 then size=4-size%4+size end
             local start=element1.Offset
             if start%4&gt;0 then start=4-start%4+start
             else start=start+4 end
             size=size/4
             for j=0,size-1 do
               if (start+j*4)&gt;=(element1.Offset+bytesize) then
                 list[k]=start+j*4
                 k=k+1
               end
             end
           end
        end
      end
      for i,v in ipairs(list) do local e=Struct.addElement() e.Offset=v e.Vartype=vtDword end
    end

    if isGlobal then Struct.addToGlobalStructureList()end
end

function getElementByOffset(struct,offset)
  for i=0,struct.Count-1 do
    if struct.Element[i].Offset==offset then return i end
  end
  return nil
end

function ue4createstructfast(fullnameortable,StructName,isGlobal,isfullname,structu,AddedOffset,AddedName)
  if StructName and isStructExist(StructName) and isGlobal then return end
  if not UEObj then enumUEObj() end
  local tabl=fullnameortable
  if type(fullnameortable)==type('') then
    for i,v in ipairs(UEObj) do if v.FullName==fullnameortable then tabl=v break end end
  end
  --[[
  if not tabl or type(tabl)~=type({})  then
    enumUEObj()
    if type(fullnameortable)==type('') then
      for i,v in ipairs(UEObj) do if v.FullName==fullnameortable then tabl=v break end end
    end
  end
  ]]
  if not tabl or type(tabl)~=type({})  then
    print(tostring(fullnameortable)..' not found...')
    return
  end
  local name=StructName
  if not name then name=tabl.Name end
  if not AddedOffset then AddedOffset=0 end
  local struct=structu
  if not struct then struct=createStructure(name)end
  if not AddedName then AddedName='' end
  --print(tostring(tabl))
  local isUserDefinedStruct=string.find(tabl.Type,'UserDefinedStruct')
  local e,typ,propname
  while(true)do
    if not tabl then break end
    if type(tabl)==type(1) or tabl.Name=='Object' then break end
    print(tostring(tabl.Type)..' '..tostring(tabl.FullName))
    if tabl.Member then
      for i=1,#tabl.Member do
        if tabl.Member[i].Type~='Function' then
          if isfullname then e.Name=string.format('%s %s%s',tabl.Member[i].Type,AddedName,tabl.Member[i].FullName)
          else
            propname=AddedName..tabl.Member[i].Name
            if isUserDefinedStruct then propname=propname:sub(1,string.find(propname,'_')-1) end
          end
          if tabl.Member[i].Type=='StructProperty' then
            ue4createstructfast(tabl.Member[i].Property,nil,nil,isfullname,struct,tabl.Member[i].Offset+AddedOffset,propname..'.')
            if not getElementByOffset(struct,tabl.Member[i].Offset+AddedOffset) then e=struct.addElement() e.Offset=tabl.Member[i].Offset+AddedOffset e.Name=propname e.Vartype=vtDword end
          else
            e=struct.addElement()
            e.Offset=tabl.Member[i].Offset+AddedOffset
            typ=tabl.Member[i].Type
            e.Name=propname
            e.Vartype=ue4type[typ]
            if e.Vartype==nil then e.Vartype=vtDword end
          --if typ=='StructProperty' then for i=2,(v.Size/4) do local f=struct.addElement() f.Offset=e.Offset+i*4-4 f.Name=e.Name..'_'..i f.Vartype=e.Vartype end e.Name=e.Name
            if typ=='ArrayProperty' then
              local f=struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
              --[[
              if tabl.Member[i].Property.Name and tabl.Member[i].Property.Property.Name then
                local struc=createStructure(tabl.Member[i].Property.Name)
                ue4createstructfast(tabl.Member[i].Property.Property,isfullname and tabl.Member[i].Property.Property.FullName..'.' or tabl.Member[i].Property.Property.Name..'.',10,isfullname,struc)
                if struc.Count&gt;1 then e.ChildStruct=struc end
              end]]
            elseif typ=='BoolProperty' then e.ChildStructStart=tabl.Member[i].BitField end
          end
        end
      end
    end
    tabl=tabl.Parent
  end
  if struct.Count==0 then return end
  if AddedOffset&gt;0 then return end
  if struct.Element[struct.Count-1].Offset&lt;=0x5000 then
    local count=struct.Count-1
    local list,k,element1,element2,size,bytesize={},1
    for i=0,count do
      element1=struct.Element[i]
      element2=struct.Element[i+1]
      if element2 then
        bytesize=element1.Bytesize
        if bytesize&lt;4 then bytesize=4 end
        size=element2.Offset-element1.Offset-bytesize
        if size&gt;0 then
           if size%4&gt;0 then size=4-size%4+size end
           local start=element1.Offset
           if start%4&gt;0 then start=4-start%4+start
           else start=start+4 end
           size=size/4
           for j=0,size-1 do
             if (start+j*4)&gt;=(element1.Offset+bytesize) then
               list[k]=start+j*4
               k=k+1
             end
           end
        end
      end
    end
    for i,v in ipairs(list) do local e=struct.addElement() e.Offset=v e.Vartype=vtDword end
  end
  if isGlobal then struct.addToGlobalStructureList()end
end

function uecreatestruct(instance,name,depth,isfullname)
  local pointer=readPointer(instance+UObject.Class)
  local classname=GetFullNameAlgo(pointer)
  if not classname then print('instance is invalid') return end
  if classname:find(' ') then classname=classname:sub(classname:find(' ')+1) end

  print(string.format("createThread(ue4createstruct(\'%s\',\'%s\',0))",classname,name))
  ue4createstruct(pointer,name,depth,isfullname)
end

function ue_structureDissectOverrideCallback(Struct, Instance)
  --print('banana2')
  local name,fullname
  address,name,fullname=ue_findRealStartOfObject(Instance)

  if name then
   -- print('banana3')
    ue4createstructfast(fullname,nil,10,nil,Struct)
    if Struct.Count&gt;1 then return true
    else return false end
  end

  --ue_fillstruct(readPointer(Instance+UObject.Class),structure)
  --print('banana4')

  return nil
end

function ue_structureNameLookupCallback(address)
  --print('banana1')
  local name,fullname
  address,name,fullname=ue_findRealStartOfObject(address)
  if name then return name,address end
  return nil
end

function ue_findRealStartOfObject(address)
  local pointer=readPointer(address+UObject.Class)
  if pointer then
    local FullName=GetFullNameAlgo(pointer)
    if FullName then
      local Name=GetNameAlgo(pointer)
      FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
      Name=Name:sub(string.find(Name,' ')+1,Name:len())
      return address,Name,FullName
    end
  end

  if not UEObj then enumUEObj() end
  for i=1,#UEObj do
    if UEObj[i].MemberSize and UEObj[i].Class and UEObj[i].Class.MemberSize and UEObj[i].Class.MemberSize&gt;0 and not string.find(UEObj[i].Class.FullName,'/Script/CoreUObject.') then
       if address&gt;=UEObj[i].Address and address&lt;UEObj[i].Address+UEObj[i].Class.MemberSize then
         local name
         return UEObj[i].Address,UEObj[i].Class.Name,UEObj[i].Class.FullName
       end
    end
  end

  return address
end


function enumUEObjT(file,size,i,start,stop)
 local datatable,Address,FName,Name,FullName,typ,typ1,isProperty,l,pointer,stri,num,isPropertyc,EObj,k=0
 local Class,ObjectId,super,Offset,nextmember,member,propsize,bitmask,Property,Outer=UObject.Class,UObject.ObjectId,UObject.super,UObject.Offset,UObject.nextmember,UObject.member,UObject.propsize,UObject.bitmask,UObject.Property,UObject.Outer
 local UEver=UE4ver
 local pointersize= targetIs64Bit() and 8 or 4

 for j=start,stop do
    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      Address=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      Address=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      Address=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      Address=byteTableToDword(datatable)
    end

    if Address and Address~=0 then
       objid=readInteger(Address+ObjectId)
       if objid then
          if objid&lt;size then
             FullName=GetFullNameAlgo(Address)

             if FullName then
               isProperty=false
               typ1=FullName:sub(1,string.find(FullName,' ')-1)
               FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
               if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len()) isProperty=true
               elseif string.find(FullName,'%.') then Name=FullName:sub(string.find(FullName,'%.')+1,FullName:len())
               else Name=FullName end
               if UEObjIndex[FullName] and UEObj[UEObjIndex[FullName]] then UEObj[UEObjIndex[FullName]].Address=Address
               else
                 EObj={}
                 EObj.Address=Address
                 EObj.Id=objid
                 EObj.Class=temp[readPointer(Address+Class)]
                 EObj.Type=typ1
                 EObj.FullName=FullName
                 EObj.Name=Name
                 if isProperty then
                   isProperty=readPointer(Address+Outer)
                   if isProperty and isProperty~=0 then
                     EObj.Outer=isProperty
                     EObj.Size=readInteger(Address+propsize)
                     EObj.Offset=readInteger(Address+Offset)
                     if typ1=='BoolProperty' then EObj.BitField=readBytes(Address+bitmask,1)
                     elseif typ1=='StructProperty' or typ1=='ObjectProperty' or typ1=='ArrayProperty' then EObj.Property=readPointer(Address+Property)end
                   else print(FullName..' nil outer')
                   end
                 end

                 Parent=readPointer(Address+super)
                 if Parent and Parent~=0 then EObj.Parent=Parent end
                 temp[Address]=EObj
                 if UEver&gt;=25 then
                   k=1
                   EObj.MemberSize=readInteger(Address+member+pointersize)
                   Address=readPointer(Address+member)
                   EObj.Member={}

                   while(true)do
                     if UEver&gt;=25 then FullName=GetFullNameSafeAlgo(Address)
                     else FullName=GetFullNameAlgo(Address) end
                     if not FullName then break end

                     typ=FullName:sub(1,string.find(FullName,' ')-1)
                     FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
                     if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len())
                     else Name=FullName end
                     EObj.Member[k]={}
                     EObj.Member[k].Address=Address
                     EObj.Member[k].Type=typ
                     EObj.Member[k].FullName=FullName
                     EObj.Member[k].Name=Name
                     EObj.Member[k].Size=readInteger(Address+propsize)
                     EObj.Member[k].Offset=readInteger(Address+Offset)
                     if typ=='BoolProperty' then EObj.Member[k].BitField=readBytes(Address+bitmask,1)
                     elseif typ=='StructProperty' or typ=='ObjectProperty' or typ=='ArrayProperty' then EObj.Member[k].Property=readPointer(Address+Property)end
                     Address=readPointer(Address+nextmember)
                     k=k+1
                   end
                   if #EObj.Member==0 then EObj.Member=nil end
                 end
                 UEObj[#UEObj+1]=EObj
                 UEObjIndex[EObj.FullName]=#UEObj+1
               end
             end
          end
       end
    end
 end
--print(i..':'..k)
end

function enumUEObj(isSilent,isUpdateOnly)
 enumUEObjIsRunning=true
 local sub=targetIs64Bit() and 0 or 4
 ue4parsetablecheck()
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local starttime=os.time()
 if not isUpdateOnly then
   UEObj={}
   UEObjIndex={}
 end
 temp={}
 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess+0.5) do
   start=stop
   stop=stop+num
   createThread(enumUEObjT(file,size,i,start,stop-1))
  end
 end
 if not isUpdateOnly then
   if UE4ver&gt;=25 then
     for i=1,#UEObj do
       if UEObj[i].Parent then
         if temp[UEObj[i].Parent] then
           UEObj[i].Parent=temp[UEObj[i].Parent]
         end
       end
       if UEObj[i].Member then
         for j=1,#UEObj[i].Member do
           if UEObj[i].Member[j].Property then
             if temp[UEObj[i].Member[j].Property] then
               UEObj[i].Member[j].Property=temp[UEObj[i].Member[j].Property]
               local typ=UEObj[i].Member[j].Property.Type
               if typ and ( typ=='StructProperty' or typ=='ObjectProperty' or typ=='ArrayProperty' ) then
                 typ=temp[readPointer(UEObj[i].Member[j].Property.Address+UObject.Property)]
                 if typ then
                   UEObj[i].Member[j].Property.Property=typ
                 end
               end
             end
           end
         end
       end
     end
   else
     for i=1,#UEObj do
       if UEObj[i].Parent then
         if temp[UEObj[i].Parent] then
           UEObj[i].Parent=temp[UEObj[i].Parent]
         end
       end
       if UEObj[i].Outer then
         if temp[UEObj[i].Outer]then
           if temp[UEObj[i].Property] then
             UEObj[i].Property=temp[UEObj[i].Property]
             local typ=UEObj[i].Property.Type
             if typ and ( typ=='StructProperty' or typ=='ObjectProperty' or typ=='ArrayProperty' ) then
               typ=temp[readPointer(UEObj[i].Property.Address+UObject.Property)]
               if typ then
                 UEObj[i].Property.Property=typ
               end
             end
           end
           if not temp[UEObj[i].Outer].Member then temp[UEObj[i].Outer].Member={}end
           temp[UEObj[i].Outer].Member[#temp[UEObj[i].Outer].Member+1]=UEObj[i]
         else print(UEObj[i].FullName..' missing outer') end
       end
     end
   end
 end
 temp=nil
 enumUEObjIsRunning=false
 if not isSilent then print(string.format('\nA Total of %u objects had been enumerated in %u seconds',#UEObj,os.time()-starttime))end
end



function findOpcodes(address,opcode,size)
  if not size then size=0x50 end
  address=getAddressSafe(address)
  if not address then return nil end
  local addr={}
  local i=0
  local j=1
  while(i&lt;size) do
    local ext, opc, byt, add=splitDisassembledString(disassemble(address+i))
    if string.find(opc,opcode) then
      addr[j]=address+i
      j=j+1
    end
    i=i+getInstructionSize(address+i)
  end
  return addr
end

--local ext, opc, byt, add=splitDisassembledString(disassemble(findOpcodes('/Script/Astro.PrinterComponent:UpdatePreprinting_exec','call')[1]))
--return opc:sub(string.find(opc,' ')+1,opc:len())

function groupscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtGrouped,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function UEfindInstancesOfClass(fullnameOrAddress)
  local class,address=UObject.Class
  if type(fullnameOrAddress)==type('')then address=StaticFindObjectAlgo(fullnameOrAddress)
  else address=fullnameOrAddress end
  local fname=readInteger(address+UObject.FNameIndex)
  local result=groupscan(string.format('%u:%u 4:%u',targetIs64Bit() and 8 or 4,address,fname))
  for i,v in ipairs(result) do result[i]=tonumber(v,16)-class end
  return result
end

function StructAddToListSymbol(StructName,StartOffset,StopOffset,BaseAddress,OffsetOnly)
  if not StartOffset then StartOffset=0 end
  if not StopOffset then StopOffset=0xFFFFFF end
  local structCount=getStructureCount()
  local struct
  for i=0,structCount-1 do
    local stru=getStructure(i)
    if stru.Name==StructName then struct=stru break end
  end
  if struct then
    for i=0,struct.Count-1 do
      local e=struct.Element[i]
      if e.Offset&gt;=StartOffset and e.Offset&lt;=StopOffset then
        local rec=getAddressList().createMemoryRecord()
        rec.setDescription(e.Name)
        if OffsetOnly then
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.Offset[0]=e.Offset
          else rec.setAddress(string.format('+%X',e.Offset))end
        else
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.OffsetText[0]=StructName..'.'..e.Name
          else rec.setAddress(string.format('+%s.%s',StructName,e.Name))end
        end
        rec.Type=e.Vartype
      end
    end
  end
end

function getInsForJump(address,registername,destination,allocsize,SharedMemoryName)
  address = getAddressSafe(address)
  if not address then error('getInsForJump address nil') return end
  if not allocsize then allocsize=4096 end
  destination=getAddressSafe(destination)
  if not destination then
	if not SharedMemoryName then destination = allocateMemory(allocsize,address)
	else destination = allocateSharedMemory(SharedMemoryName,allocsize) end
  end
  local size = (address+5-destination&gt;0x7FFFFFFF) and 14 or 5
  if registername then
	unregisterSymbol(registername)
	registerSymbol(registername,destination,true)
  end
  local opcodes = {}
  local i = 0
  while(i&lt;size) do
    local ext, opc=splitDisassembledString(disassemble(address+i))
    opcodes[#opcodes+1] = opc
    i=i+getInstructionSize(address+i)
  end
  local copy = table.concat(opcodes,'\r\n')
  local readAsTable = true
  local byt = readBytes(address,i,readAsTable)
  for j=1,#byt do byt[j] = ('%02X'):format(byt[j]) end
  local bytes = table.concat(byt, ' ')
  return i,copy,bytes,size,destination
end

function enablescript(name,registername,addressname,script,disable)
    local address=getAddress(addressname)
    if disable then script=(script):format(address,registername,readBytes(registername,1))
    else
        local i,copy,bytes,size =getInsForJump(address,name)
        script=(script):format(registername, registername, name, copy, registername, i, bytes, address)..string.rep('nop\n',i-size)..'returnhere:'
    end
    local success,erro=autoAssembleCheck(script)
    if not success then print('\n'..erro..'\n')local scriptstr=createStringlist()scriptstr.Text=script for j=0,scriptstr.Count-1 do print(string.format('%u\t%s',j+1,scriptstr[j])) end
    if not disable then deAlloc(name)unregisterSymbol(name)end error(name..' autoAssemble failed')end
    autoAssemble(script)
    if disable then deAlloc(name)unregisterSymbol(name)unregisterSymbol(registername)end
end

function cycleFullCompact(sender,force)
local state = not(compactmenuitem.Caption == 'Compact View Mode')
if force~=nil
then state = not force
end
compactmenuitem.Caption = state and 'Compact View Mode' or 'Full View Mode'
getMainForm().Splitter1.Visible = state
getMainForm().Panel4.Visible = state
getMainForm().Panel5.Visible = state
end

function addCompactMenu()
if compactmenualreadyexists
then return end
local parent = getMainForm().Menu.Items
compactmenuitem = createMenuItem(parent)
parent.add(compactmenuitem)
compactmenuitem.Caption = 'Compact View Mode'
compactmenuitem.OnClick = cycleFullCompact
compactmenualreadyexists = 'yes'
end

addCompactMenu()
--cycleFullCompact(nil,true)

if syntaxcheck then return end

[ENABLE]
if not process or not enumModules()[1] then print('Error: No process selected...') error('process is nil') end
local starttime=os.time()
ue4versioncheck()

if targetIs64Bit() then

 local address=findAddress('GUObjectArray',0,'44 8B * * * 48 8D 05 * * * * * * * * * 48 89 71 10banana',process,nil,0,true)[1]
 if not address then address=findAddress('GUObjectArray',0,'40 53 48 83 EC 20 48 8B D9 48 85 D2 74 * 8Bbanana',process,nil,0,true)[1]end
 if not address then address=findAddress('GUObjectArray',0,'4C 8B 05 * * * * 45 3B 88banana',process,nil,0,true)[1]end
 if not address then error('GUObjectArray aob not found...')end
 findAddress('GUObjectArray',1,address)

 ue4config()

 if UE4ver&gt;=23 then
   address=findAddress('FNamePool',0,'4C 8D 05 * * * * EB 16 48 8D 0D * * * * E8banana',process,nil,0,true)[1]
   if not address then address=findAddress('FNamePool',0,'48 8D 0D *  *  *  *  E8 *  *  *  * 4C 8B C0 C6banana',process,nil,0,true)[1]end
   if address then findAddress('FNamePool',1,address)
   else error('FNamePool aob not found...')end
 else
  address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[2]
  if not address then address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[1] end
  if address then findAddress('FNamePool',1,address)
  else findAddress('FNamePool',1,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20banana',process,nil,2)end
 end
 local address=findAddress('GEngine',0,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process,nil,0,true)[1]
 if not address then address=findAddress('GEngine',0,'48 8B 1D * * * * 48 85 DB 74 * 48 8Dbanana',process,nil,0,true)[1]end
 if not address then error('GEngine aob not found...')end
 findAddress('GEngine',1,address)
 --findAddress('GEngine',1,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process)

else
 ue4config()
 if UE4ver&gt;2 then
  findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  findAddress('GUObjectArray',1,'8B 44 24 04 56 8B F1 85 C0 74 17 8B 40 08banana',process)
  findAddress('FNamePool',1,'33 F6 89 35 * * * * 8B C6 5Ebanana',process,nil,1,nil,true,true)
 else
  findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  findAddress('FNamePool',1,'8B 07 8B 0D * * * * 8B 04 81banana',process)
  findAddress('GUObjectArray',1,'8B 15 * * * * 8B 04 82 85banana',process)
 end
end
print('AOBScan done : '..os.time()-starttime)
ue4parsetable()
--findAddress('GWorld',1,'4D 8B 94 24 50 0C 00 00banana',process)

FNameStringAlgo(1,true)

print('Table parsing done : '..os.time()-starttime)
if UE4ver&gt;2 then

 createThread(ue4createstruct('/Script/Engine.GameEngine','GameEngine',1))
 createThread(ue4createstruct('/Script/Engine.GameViewportClient','GameViewportClient',0))

 createThread(ue4createstruct('/Script/Engine.GameInstance','GameInstance',0))
 createThread(ue4createstruct('/Script/Engine.LocalPlayer','LocalPlayer',1))
 createThread(ue4createstruct('/Script/Engine.PlayerController','PlayerController',2))
 createThread(ue4createstruct('/Script/Engine.CharacterMovementComponent','MovementComponent',0))
 createThread(ue4createstruct('/Script/Engine.CapsuleComponent','CapsuleComponent',3))
 createThread(ue4createstruct('/Script/Engine.Character','GPlayer',0))

 createThread(ue4createstruct('/Script/Engine.World','World',0))

end

print('All done : '..os.time()-starttime..'\n')
sleep(1000)
GetLuaEngine().close()
[DISABLE]
--cycleFullCompact(nil,false)
unregisterSymbol('GEngine')
unregisterSymbol('GUObjectArray')
unregisterSymbol('FNamePool')

</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>26101</ID>
                  <Description>"Enable ue_structureDissectCallback (Experimental)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
if not ue_structureDissectOverrideCallbackID then
  ue_structureDissectOverrideCallbackID=registerStructureDissectOverride(ue_structureDissectOverrideCallback)
end

if not ue_structureNameLookupCallbackID then
  ue_structureNameLookupCallbackID=registerStructureNameLookup(ue_structureNameLookupCallback)
end

 
 
[DISABLE]
unregisterStructureDissectOverride(ue_structureDissectOverrideCallbackID)
unregisterStructureNameLookup(ue_structureNameLookupCallbackID)
ue_structureDissectOverrideCallbackID=nil
ue_structureNameLookupCallbackID=nil
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26102</ID>
                  <Description>"Basic UE Object Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local Offset,ObjectId,nextmember,member,enumMul,Property=UObject.Offset,UObject.ObjectId,UObject.nextmember,UObject.member,UObject.enumMul,UObject.Property

function ue4dump(file,address,size,i,start,stop)
 local k=0
 local addy= targetIs64Bit() and 8 or 4
 local en= targetIs64Bit() and 0x40 or 0x2C
 local pointer,datatable,pointers,propname,offset,list,str,strid,name,objid
 for j=start,stop do

    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end

    if pointer and pointer~=0 then
       local objid=readInteger(pointer+ObjectId)
       if objid then
          if objid&lt;size then
             str=string.format('%016X',pointer)
             strid=string.format('%08u',objid)
             name=GetFullNameSuperAlgo(pointer,true)
             if name then
                 typ=name:sub(1,string.find(name,' ')-1)
                 if string.find(typ,'Property') then
                     if (typ=='StructProperty' or string.find(typ,'ObjectProperty') or string.find(typ,'ArrayProperty') ) and Property then
                       name=hasProperty(pointer)
                     end
                     strid=string.format('%8X',readInteger(pointer+Offset))
                 end

                 file:write(string.format('[%s] %s %s\n',strid,str,name))


                 if (typ=='UserDefinedEnum' or typ=='Enum') and enumMul then
                   list=pointer+en
                   for i=0,readInteger(list+8)-1 do
                     pointers=readPointer(list)+i*enumMul
                     offset=readBytes(pointers+addy,1)
                     if offset==0 then offset=i end
                     propname=FNameStringAlgo(pointers)
                     strid=string.format('%8X',offset)
                     str=string.format('%016X',pointers)
                     file:write(string.format('[%s] %s %s\n',strid,str,propname))
                   end
                 elseif typ=='MapProperty' and Property then
                   for n=0,1 do
                     pointers=readPointer(pointer+n*8+Property)
                     propname=hasProperty(pointers)
                     if propname then
                       offset=readInteger(pointers+Offset)
                       strid=string.format('%8X',offset)
                       str=string.format('%016X',pointers)
                       file:write(string.format('[%s] %s %s\n',strid,str,propname))
                     end
                   end
                 end

                 if UE4ver&gt;=25 then
                     local pointers= readPointer(pointer+member)
                     while(true)do
	                     propname=GetFullNameSafeAlgo(pointers)
	                     if not propname then break end
	                     offset=readInteger(pointers+Offset)
	                     strid=string.format('%8X',offset)
                         str=string.format('%016X',pointers)

                         typ=propname:sub(1,string.find(propname,' ')-1)
                         if typ=='StructProperty' or string.find(typ,'ObjectProperty') or string.find(typ,'ArrayProperty') then
                           propname=hasProperty(pointers)
                         end

	                     file:write(string.format('[%s] %s %s\n',strid,str,propname))

                         if typ=='MapProperty' then
                           for n=0,1 do
                             pointer=readPointer(pointers+n*8+Property)
                             propname=hasProperty(pointer)
                             if propname then
                               offset=readInteger(pointer+Offset)
                               strid=string.format('%8X',offset)
                               str=string.format('%016X',pointer)
                               file:write(string.format('[%s] %s %s\n',strid,str,propname))
                             end
                           end
                         end

	                     pointers=readPointer(pointers+nextmember)
                     end
                 end
                 k=k+1
             end
          end
       end
    end
 end
    totalobject=totalobject+k
--print(i..':'..k)
end


 local sub=targetIs64Bit() and 0 or 4
 ue4parsetablecheck()
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local starttime=os.time()
 local Path = 'C:\\test\\'
 local filename= string.format('[%s] ObjectsDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
--local re={rei1,rei2,rei3,rei4,rei5}
 totalobject=0
--allobject=createStringlist()

 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess+0.5) do
   start=stop
   stop=stop+num
   createThread(ue4dump(file,GUObjectDict[i],size,i,start,stop-1))
  end
 end


 file:close()
 print(string.format('\nA Total of %u objects had been dumped in %u seconds',totalobject,os.time()-starttime))
 print(Path..filename)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26103</ID>
                  <Description>"Basic UE Name Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function uenamedump(file,start,stop)
  for i=start,stop do
    local name=FNameStringAlgo(i,true)
    if name and name:len()&lt;200 and name:len()&gt;3 and not string.find(name,'%c')  then
      --print(name)
      local strid=string.format('%08X',i)

      file:write(string.format('[%s] %s\n',strid,name))
      totalname=totalname+1
    end
  end
end


 local size
 if UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
 elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
 else size=math.floor(#FNameDict[1]/4) end
 local count=0x200
 size=math.floor((size/count)+0.5)

 local starttime=os.time()
 local Path = 'C:\\test\\'
 local filename= string.format('[%s] NamesDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
 totalname=0
 ue4parsetablecheck()
 local num,start,stop=count,0,0
 for i=0,size do
   start=stop
   stop=stop+num
   createThread(uenamedump(file,start,stop-1))
 end
 file:close()
 print(string.format('\nA Total of %u names had been dumped in %u seconds',totalname,os.time()-starttime))
 print(Path..filename)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26104</ID>
                  <Description>"NoClip &amp; Fly                                            Numpad6 :Toggle, Space :Up, LeftCtrl :Down"</Description>
                  <Options moHideChildren="1" moDeactivateChildrenAsWell="1"/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end

[ENABLE]

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) &amp; ~ ChildStructStart('PlayerController','bActorEnableCollision')
writeBytes(address,bActorEnableCollision)
end

--[[
Enum /Script/Engine.EMovementMode
0:MOVE_None
1:MOVE_Walking
2:MOVE_NavWalking
3:MOVE_Falling
4:MOVE_Swimming
5:MOVE_Flying
6:MOVE_Custom
7:MOVE_MAX

local list=+0x40
for i=0,readInteger(list+8)-1 do
local pointer=readPointer(list)+i*0x10
local enum=readInteger(pointer+8)
local name=FNameString(pointer)
print(enum..':'..name)
end
]]


if not RelativeLocationZoffset then
  local address=getAddress('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  local value=readInteger(address+getAddress('CapsuleComponent.RelativeLocation.Z'))
  local list=groupscan(string.format('4:%u',value),address,address+0x1000)
  RelativeLocationZoffset={}
  for i=1,#list do
    RelativeLocationZoffset[i]=getAddress(list[i])-address
  end
end

updown = createTimer()
updown.Interval = 5
updown.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_SPACE) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])+20)
      end
    end
    if isKeyPressed(VK_LCONTROL) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])-20)
      end
    end
  end
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MovementMode')
  if address then
  writeBytes(address,5)
  end
end




[DISABLE]
updown.destroy()

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) | ChildStructStart('PlayerController','bActorEnableCollision')
writeBytes(address,bActorEnableCollision)
end

local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MovementMode')
if address then
writeBytes(address,1)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Toggle Activation</Action>
                      <Keys>
                        <Key>102</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                  </Hotkeys>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26105</ID>
                      <Description>"WASD"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
wasd = createTimer()
wasd.Interval = 5
wasd.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_S) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)+20)
      end
    end
    if isKeyPressed(VK_W) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)-20)
      end
    end
    if isKeyPressed(VK_A) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)+20)
      end
    end
    if isKeyPressed(VK_D) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)-20)
      end
    end
  end
end

[DISABLE]
wasd.destroy()
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>26106</ID>
                  <Description>"bCanBeDamaged false (Godmode)      Numpad4 :Deactive, Numpad5 :Active"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end

[ENABLE]
--CanBeDamaged = createTimer()
--CanBeDamaged.setInterval(1000)
--CanBeDamaged.OnTimer = function()
local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bCanBeDamaged')
if address then
local bCanBeDamaged=readBytes(address,1) &amp; ~ ChildStructStart('PlayerController','bCanBeDamaged')
writeBytes(address,bCanBeDamaged)
end
--end
 
 
[DISABLE]
--CanBeDamaged.destroy()

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bCanBeDamaged')
if address then
local bCanBeDamaged=readBytes(address,1) | ChildStructStart('PlayerController','bCanBeDamaged')
writeBytes(address,bCanBeDamaged)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>101</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>100</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26107</ID>
                  <Description>"Jump Multiplier                                       Numpad0 :Deactive, Numpad1 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
jumpmultiplier=1
if syntaxcheck then return end
if not jumpdefault then jumpdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')end
if not MaxAccelerationdefault then MaxAccelerationdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')end
if not AirControldefault then AirControldefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')end
[ENABLE]
jumpmuti=createHotkey(function()jumpmultiplier=jumpmultiplier+0.5 end,VK_NUMPAD1)
jump = createTimer()
jump.setInterval(1000)
jump.OnTimer = function()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')
local address2=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')
local address3=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')
if address then writeFloat(address,jumpdefault*jumpmultiplier)
writeFloat(address2,MaxAccelerationdefault*jumpmultiplier)
writeFloat(address3,AirControldefault*jumpmultiplier)
end
end
[DISABLE]
jump.destroy()
jumpmuti.destroy()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')
local address2=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')
local address3=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')
if address then writeFloat(address,jumpdefault)
writeFloat(address2,MaxAccelerationdefault)
writeFloat(address3,AirControldefault)
end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>97</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>96</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26108</ID>
                  <Description>"WalkSpeed Multiplier                             Numpad2 :Deactive, Numpad3 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
walkmultiplier=1
if syntaxcheck then return end
if not walkdefault then walkdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')end
[ENABLE]
walkpmuti=createHotkey(function() walkmultiplier=walkmultiplier+0.5 end,VK_NUMPAD3)
walk = createTimer()
walk.setInterval(1000)
walk.OnTimer = function()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')
if address then writeFloat(address,walkdefault*walkmultiplier)end
end
[DISABLE]
walk.destroy()
walkpmuti.destroy()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')
if address then writeFloat(address,walkdefault)end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>99</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>98</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26109</ID>
                  <Description>"UWorld"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>GameViewportClient.World</Offset>
                    <Offset>GameEngine.GameViewport</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>26110</ID>
                  <Description>"Player"</Description>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>PlayerController.Character</Offset>
                    <Offset>LocalPlayer.PlayerController</Offset>
                    <Offset>0</Offset>
                    <Offset>GameInstance.LocalPlayers</Offset>
                    <Offset>GameEngine.GameInstance</Offset>
                  </Offsets>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26111</ID>
                      <Description>"CharacterMovement"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <GroupHeader>1</GroupHeader>
                      <Address>+GPlayer.CharacterMovement</Address>
                      <Offsets>
                        <Offset>0</Offset>
                      </Offsets>
                      <CheatEntries>
                        <CheatEntry>
                          <ID>26112</ID>
                          <Description>"JumpZVelocity"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.JumpZVelocity</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26113</ID>
                          <Description>"MaxWalkSpeed"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxWalkSpeed</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26114</ID>
                          <Description>"MaxWalkSpeedCrouched"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxWalkSpeedCrouched</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26115</ID>
                          <Description>"MaxAcceleration"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxAcceleration</Address>
                        </CheatEntry>
                      </CheatEntries>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>26116</ID>
              <Description>"Tools"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>26117</ID>
                  <Description>"FNamePool scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
function stringscan(value,modulename,stopaddress,isUnicode)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtString,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,isUnicode,true)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end



createThread(function()
print('------------------')
local isUnicode=true
local strlist,result,result2,result3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  result=stringscan('IntProperty',getAddressSafe(strlist[i]),getAddressSafe(strlist[i]..'+50'),isUnicode)
  if #result&gt;0 then
    result=stringscan('None',getAddressSafe(strlist[i]..'-50'),getAddressSafe(strlist[i]),isUnicode)
    print(strlist[i])
    if #result&gt;0 then
      if string.sub(strlist[i],strlist[i]:len()-3,strlist[i]:len()-2)=='00' then
        result=pointerscan(getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00'))
        for j=1,#result do
          print(strlist[i]..'&lt;-'..result[j])
          if string.sub(result[j],result[j]:len()-1,result[j]:len())=='00' then
            result2=pointerscan(getAddressSafe(result[j]))
            for k=1,#result2 do
              print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
              result3=pointerscan(getAddressSafe(result2[k]),getAddress(process),getAddress(process)+getModuleSize(process))
              for l=1,#result3 do print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l]) end
            end
          end
        end
      end
    end
  end
end
print('done')
end)
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26118</ID>
                  <Description>"DissectCode (Memory View -&gt; Ctrl+J or (Tools -&gt; Dissect code) )"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26119</ID>
                      <Description>"Save DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
getDissectCode().saveToFile(path)
--getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>26120</ID>
                      <Description>"Load DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
--getDissectCode().saveToFile(path)
getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>26122</ID>
          <Description>"Dumper V5"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>26123</ID>
              <Description>"Unreal Engine"</Description>
              <Options moHideChildren="1"/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
function ue4config()
 local sub=targetIs64Bit() and 0 or 4
 UObject = {}
 if UE4ver&lt;=2 and targetIs64Bit() then ue4determineversion() end
-----------------------------
----------UE4 struct---------
 if UE4ver&gt;2 then

    UObject.ObjectId= 0xC-sub
    UObject.Class = 0x10-sub
    UObject.FNameIndex = 0x18-(sub*2)
    UObject.Outer = 0x20-(sub*2)

    UObject.enumMul= 0x10

  if UE4ver&gt;=25 then
    UObject.super= 0x40
    UObject.member= 0x50
    UObject.nextmember= 0x20
    UObject.Offset= 0x4C
    UObject.propsize=0x3C
    UObject.bitmask= 0x7A
    UObject.funct= 0xD8
    UObject.Property= 0x78

  elseif UE4ver&gt;=22 then
    UObject.super= 0x40
    UObject.member= 0x48
    UObject.funct= 0xC0
  else
    UObject.super= 0x30 -(sub*4)
    UObject.member= 0x38 -(sub*5)
    UObject.funct= 0xB0
  end

  if UE4ver&lt;25 then
    UObject.nextmember=0x28-(sub*3)
    UObject.Offset= 0x44-(sub*4)
    UObject.propsize= 0x34-(sub*3/2)
    UObject.bitmask= 0x72-(sub*8)

    UObject.Property= 0x70

  end

  if UE4ver&lt;11 then
    UObject.Offset= 0x4C
    UObject.enumMul= 0xC
  end

----------------------------
---------UE3 struct---------
--1.25
 elseif UE4ver&gt;=1 then
    UObject.ObjectId= 0x4
    UObject.Outer = 0x14
    UObject.FNameIndex = 0x18
    UObject.Class = 0x20
    UObject.Offset= 0x48
    UObject.super= 0x34
    UObject.member= 0x38
    UObject.nextmember=0x28
    UObject.propsize= 0x30
    UObject.bitmask= 0x60
    UObject.Property= 0x58
    UObject.enumMul= 0x8


--0.10246
 else
    UObject.ObjectId= 0x20
    UObject.Outer = 0x28
    UObject.FNameIndex = 0x2C
    UObject.Class = 0x34

    UObject.Offset= 0x60

    UObject.super= 0x48
    UObject.member= 0x4C

    UObject.nextmember=0x3C
    UObject.propsize= 0x44
    UObject.bitmask= 0x70
 end

---------------------------
end


local ue4type={
		['BoolProperty']=vtByte,
		['ByteProperty']=vtByte,
		['FloatProperty']=vtSingle,
        ['StructProperty']=vtDword,
		['IntProperty']=vtDword,
        ['NameProperty']=vtQword,
        ['Int64Property']=vtQword,
		['TextProperty']=vtPointer,
        ['StrProperty']=vtPointer,
        ['ArrayProperty']=vtPointer,
        ['MapProperty']=vtPointer,
        ['ClassProperty']=vtPointer,
		['ObjectProperty']=vtPointer}

function ue4versioncheck()
 local fileversion,info =getFileVersion(enumModules()[1].PathToFile)
 if not info then UE4ver=0 return end
--return info.minor
 UE4ver=tonumber(info.minor..'.'..info.release)
end

function FNameStringAlgo(FName,IndexOnly)
 if not FName then return nil end
 local UEver=UE4ver
 local sub=targetIs64Bit() and 0 or 4
 local number,str,datatable
 if not IndexOnly then
   number=UEver&gt;2 and readInteger(FName+4) or 0
   FName=readInteger(FName)
 else number=FName&gt;&gt;32 FName=FName&amp;0xFFFFFFFF
 end
 if not FName then return nil end
 if FNameList[FName] then
   if number&gt;0 then return FNameList[FName]..'_'..number-1 end
   return FNameList[FName]
 end
 local CFName=FName
 if UEver&gt;=23 then
  local i=(FName&gt;&gt;0x10)+1
  FName=(FName&amp;0xFFFF)*2
  if i&gt;#FNameDict or FName&gt;#FNameDict[i] then return nil end
  datatable={}
  for m=1,2 do
    datatable[m]=FNameDict[i][FName+m]
  end

  local le = byteTableToWord(datatable)
  if not le then return nil end
  le=le&gt;&gt;6
  if le&gt;200 then return nil end
  local widechar=true and FNameDict[i][FName+1]&amp;1==1 or false
  if widechar then
    datatable={}
    for m=1,le*2 do
      datatable[m]=FNameDict[i][FName+2+m]
    end
    str=byteTableToWideString(datatable)
  else
    datatable={}
    for m=1,le do
      datatable[m]=FNameDict[i][FName+2+m]
    end
    str=byteTableToString(datatable)
  end
 else
  local i
  if UEver&gt;2 then
   i=(FName&gt;&gt;0xE)+1
   FName=(FName&amp;0x3FFF)*(8-sub)
  else i=1 FName=FName*(8-sub) end
  if i&gt;#FNameDict or FName&gt;#FNameDict[i] then return nil end
  local pointer
  if targetIs64Bit() then
    datatable={}
    for m=1,8 do
      datatable[m]=FNameDict[i][FName+m]
    end
    pointer=byteTableToQword(datatable)
  else
    datatable={}
    for m=1,4 do
      datatable[m]=FNameDict[i][FName+m]
    end
    pointer=byteTableToDword(datatable)
  end
  if not pointer or pointer==0 then return nil end

  --local offset=UE4ver&gt;=22 and 0xC-sub or 0x10-(sub*2)
  if FName==1 and not stringoffset or not stringoffsetid then
     str=readString(pointer+8,13)
     if str=='ByteProperty' then stringoffset=8
     else str=readString(pointer+0xC,13)
         if str=='ByteProperty' then stringoffset=0xC
         else str=readString(pointer+0x10,13)
             if str=='ByteProperty' then stringoffset=0x10 end
         end
     end

     for j=0, stringoffset-4,4 do
       if readInteger(pointer+j)==2 then stringoffsetid=j end
     end
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
  --print(string.format('%X',offset))

  else
  local widechar=true and readInteger(pointer+stringoffsetid)&amp;1==1 and UEver&gt;2 or false
  str= readString(pointer+stringoffset,200,widechar)
  if not str then str= readString(pointer+stringoffset,100,widechar) end
  if not str then str= readString(pointer+stringoffset,50,widechar) end
  if not str then str= readString(pointer+stringoffset,30,widechar) end
  if not str then
   local le=0
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
   while(true)do
    if le&gt;50 then break end
    if readBytes(pointer+stringoffset+le)==0 then break end
    le=le+1
   end
   str= readString(pointer+stringoffset,le)
  end
   --print(string.format('%X',pointer+0xC))
 end end
 if not str then return nil end
 if number&gt;0 then return str..'_'..number-1 end
 --print(str)
 FNameList[CFName]=str
 return str
end

function GetNameAlgo(object)
 if not object then return nil end
 if ObjectList[object] then --print(ObjectList[object])
   return ObjectList[object]
 end
 local fnameoffset=UObject.FNameIndex
 local typeoffset=UObject.Class
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 --print(string.format('%X',fnameoffset))
 --print(string.format('%X',object+fnameoffset))
 local str1=FNameStringAlgo(pointer+fnameoffset)
 local str2=FNameStringAlgo(object+fnameoffset)
 if not str2 then str2=FNameStringAlgo(object+fnameoffset-8)end
 if not str1 or str1=='None' or not str2 or str2=='None' then return nil end
 str1=str1..' '..str2
 --print(ObjectList[object])
 ObjectList[object]=str1
 return str1
end

function GetFullNameAlgo(object)
 if not object then return nil end
 --if ObjectList[object] then return ObjectList[object] end
 local pathoffset=UObject.Outer
 local fnameoffset=UObject.FNameIndex
 local str=GetNameAlgo(object)
 if not str then return nil end
 local number=readInteger(object+fnameoffset+4)
 local typ=str:sub(1,string.find(str,' ')-1)
 local isProperty=string.find(typ,'Property')
 if not isProperty then isProperty=string.find(typ,'Function') end
 local pointer=readPointer(object+pathoffset)
 while(true)do
  if not pointer or pointer==0 then break end
  local stri=GetNameAlgo(pointer)
  if not stri then break end
  typ=stri:sub(1,string.find(stri,' ')-1)
  local isPropertyc=string.find(typ,'Property')
  if not isPropertyc then isPropertyc=string.find(typ,'Function') end
  stri=string.sub(str,1,string.find(str,' '))..stri:sub(string.find(stri,' ')+1,stri:len())
  local num=readInteger(pointer+fnameoffset+4)

  if number~=num and num==0 or  not isPropertyc and isProperty then stri=stri..':'
  else stri=stri..'.' end
  number=num
  isProperty=isPropertyc

  str=stri..string.sub(str,string.find(str,' ')+1,str:len())
  pointer=readPointer(pointer+pathoffset)

  if string.find(str,'%./') then
    stri=string.sub(str,1,string.find(str,' '))
    str=stri..str:sub(string.find(str,'%./')+1,str:len())
  break end

 end
 if not str then return nil end
 --ObjectList[object]=str
 return str
end

function GetFullNameSuperAlgo(object)
  local super=UObject.super
  local str1 = GetFullNameAlgo(object)
  if not str1 then return nil end
  local pointer = readPointer(object+super)
  if pointer then
    local str2 = GetFullNameAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function GetFullNameSafesAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 local str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end


function GetFullNameSafeAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str3 then str3=GetFullNameSafesAlgo(pointer)end

 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 local str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end

function FindString(namestr,start,stop)
  for i=start,stop do
    local name=FNameStringAlgo(i,true)
    if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
      --print(name)
      if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
        if namestr==name then FNameResult=i return end
      end
    end
  end
end


function FindStringFName(namestr)
  local size
  if UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
  elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
  else size=math.floor(#FNameDict[1]/4) end
  local count=0x200
  size=math.floor((size/count)+0.5)
  ue4parsetablecheck()
  FNameResult=nil
  local result
  local num,start,stop=count,0,0
  for i=0,size do
    start=stop
    stop=stop+num
    if FNameResult then break end
    createThread(FindString(namestr,start,stop-1))
  end
  result=FNameResult
  FNameResult=nil
  return result
end

function hasProperty(object)
  local str1
  if UE4ver&gt;=25 then str1=GetFullNameSafeAlgo(object)
  else str1=GetFullNameAlgo(object) end
  if not str1 then return nil end
  local pointer =readPointer(object+UObject.Property)
  if pointer then
    local str2 = GetFullNameAlgo(pointer)
    if not str2 then str2=GetFullNameSafeAlgo(pointer)end
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function printInheritC(class)
  for i=0,10 do
    if not class or class==0 then break end
    print(GetFullNameSuperAlgo(class))
    class=readPointer(class+UObject.super)
  end
end

function printInheritI(instance)
  instance=readPointer(instance+UObject.Class)
  printInheritC(instance)
end

function getregionsize(address)
local allregion=enumMemoryRegions()
 for i=#allregion,1,-1 do
  if allregion[i].BaseAddress&lt;=address then
   local BaseAddress=allregion[i].BaseAddress
   local RegionSize=allregion[i].RegionSize
   local curSize=BaseAddress+RegionSize-address
   return curSize,RegionSize,BaseAddress
  end
 end
end
--[[
function parsefrombig(tab,index,size)
 local datatable={}
 if not tab then return nil end
 for i=1,size do
  datatable[i]=tab[index+i]
 end
 return datatable
end
]]

function ue4parsetable()
 FNameList={}
 ObjectList={}
 FullNameList={}
 sub=targetIs64Bit() and 0 or 4
 local pool=getAddressSafe('FNamePool')
 local pool2=getAddressSafe('GUObjectArray')
 if pool and pool2 then
  if UE4ver&gt;=20 then GUObjectsize=readInteger(getAddress('GUObjectArray+24')-(sub*2))
  elseif UE4ver&gt;11 then  GUObjectsize=readInteger('GUObjectArray+1C')
  else GUObjectsize=readInteger(getAddress('GUObjectArray+8')-(sub*2))
  end
  FNameDict={}
  GUObjectDict={}
  for i=0,500 do
   local pointer
   if UE4ver&gt;=23 then pointer=readPointer(pool+i*(8-sub)+0x10)
   elseif UE4ver&gt;2 then  pointer=readPointer(readPointer(pool)+i*(8-sub))
   else pointer=readPointer(pool+i*(8-sub)) end
   if pointer and pointer~=0 then
    local size=getregionsize(pointer)
    if not size or size==0 then break end
    FNameDict[i+1]=readBytes(pointer,size-1,true)
   else break
   end
  end
  for i=0,500 do
   if UE4ver&gt;=20 then
    pointer=readPointer(readPointer(pool2+0x10)+i*(8-sub))
    if pointer and pointer~=0 then
    --print(string.format('%X',pointer))
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true)
    else break
    end
   elseif UE4ver&gt;11 then pointer=readPointer(pool2+0x10)
    if pointer and pointer~=0 then
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true) break
    else break end
   elseif UE4ver&gt;2 then pointer=readPointer(readPointer(pool2)+i*8+0x10)
    if pointer and pointer~=0 then
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true)
    else break end
   else pointer=readPointer(pool2)
    if pointer and pointer~=0 then
     GUObjectDict[i+1]=readBytes(pointer,getregionsize(pointer)-1,true) break
    else break end
   end
  end
 end
end


function ue4parsetablecheck()
 if not FNameDict or not GUObjectDict then ue4parsetable()
 else
 local pointer,pointei,datatable,m
 if targetIs64Bit() then
   datatable={}
   for m=1,8 do datatable[m]=GUObjectDict[1][m]end
   pointer=byteTableToQword(datatable)
 else
   datatable={}
   for m=1,4 do datatable[m]=GUObjectDict[1][m]end
   pointer=byteTableToDword(datatable)
 end
 if UE4ver&gt;=20 then pointei=readPointer('[[GUObjectArray+10]]')
 elseif UE4ver&gt;11 then pointei=readPointer('[GUObjectArray+10]')
 elseif UE4ver&gt;2 then pointei=readPointer('[[GUObjectArray]+10]')
 else pointei=readPointer('[GUObjectArray]') end
 --print(string.format('%X',pointei))
 --print(string.format('%X',pointer))
 if pointei ~= pointer then ue4parsetable() end
 local GUObjectsizes
 if UE4ver&gt;=20 then GUObjectsizes=readInteger(getAddress('GUObjectArray+24')-(sub*2))
 elseif UE4ver&gt;11 then GUObjectsizes=readInteger('GUObjectArray+1C')
 else GUObjectsizes=readInteger(getAddress('GUObjectArray+8')-(sub*2)) end
 if GUObjectsizes~=GUObjectsize then ue4parsetable() end
 end
end

function FindObject(threadlist,ObjectId,address,size,i,start,stop,fullname)
  local pointer,datatable
  for j=start,stop do

    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x8+m] then break end
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x4+m] then break end
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x18+m] then break end
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x10+m] then break end
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end

    if pointer and pointer~=0 then
      local objid=readInteger(pointer+ObjectId)
      if objid and objid&lt;size then
        local name=GetFullNameAlgo(pointer)
        if name and string.find(name,' ') then
          name=string.sub(name,string.find(name,' ')+1,name:len())
          name=name:lower()
          if not FullNameList[name]then FullNameList[name]=pointer end
          if FullNameList[fullname] then
            ObjectResult=FullNameList[fullname]
            for k,v in ipairs(threadlist) do v.terminate() end
            return
          end
        end
      end
    end
  end
end

function StaticFindObjectAlgo(fullname)
 ue4parsetablecheck()
 fullname=fullname:lower()
 if FullNameList[fullname] then return FullNameList[fullname]end
 local threadlist={}
 local k=1
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local ObjectId=UObject.ObjectId
 ObjectResult=nil
 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess) do
    start=stop
    stop=stop+num
    if ObjectResult then break end
    threadlist[k]=createThread(FindObject(threadlist,ObjectId,GUObjectDict[i],size,i,start,stop-1,fullname))
    k=k+1
  end
 end
 local result=ObjectResult
 ObjectResult=nil
 return result
end

function registerFunc(ObjectId,address,size,i,start,stop)
  local funct=UObject.funct
  for j=start,stop do
    local pointer

    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x8+m] then break end
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x4+m] then break end
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x18+m] then break end
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x10+m] then break end
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end

    if pointer and pointer~=0 then
      local objid=readInteger(pointer+ObjectId)
      if objid and objid&lt;size then
        local name=GetFullNameAlgo(pointer)
        if name and string.find(name,' ') then
          local typ=string.sub(name,1,string.find(name,' ')-1)
          if typ=='Function' then
            local fullname=string.sub(name,string.find(name,' ')+1,name:len())
            local func=readPointer(pointer+funct)
            if func and func~=0 then extralist.addSymbol('UE',fullname,func,1)end
          end
        end
      end
    end
  end
end

function registerFuncAlgo()
 local funct=UObject.funct
 ue4parsetablecheck()
 if not extralist then
   extralist=createSymbolList()
   extralist.register()
 end
 if not enumUEObjIsRunning and UEObj then
   for i,v in ipairs(UEObj) do
     if v.Type=='Function' then
       local func=readPointer(v.Address+funct)
       if func and func~=0 then extralist.addSymbol('UE',v.FullName,func,1)end
     end
   end
 else
   local k=1
   local count=0x200
   local size=GUObjectsize
   local sizess= UE4ver&gt;2 and (targetIs64Bit() and 0x18*count or 0x10*count) or 0x4*count
   local ObjectId=UObject.ObjectId
   for i=1,#GUObjectDict do
    local num,start,stop=count,0,0
    for j=0,math.floor(#GUObjectDict[i]/sizess) do
      start=stop
      stop=stop+num
      if ObjectResult then break end
      createThread(registerFunc(ObjectId,GUObjectDict[i],size,i,start,stop-1))
      k=k+1
    end
   end
 end
end

function isStructExist(name)
  for i=1,#StructList do
    if StructList[i].Name==name then return StructList[i] end
  end
  return nil
end

function SaveAndRemoveStruct()
  StructList={}
  local count=getStructureCount()
  for i=count-1,0,-1 do
    local struct=getStructure(i)
    StructList[i+1]=struct
    struct:removeFromGlobalStructureList()
  end
end

function DeleteStruct(Struct)
  local count=#StructList
  for i=1,count do
    if Struct==StructList[i] then
      Struct:Destroy()
      StructList[i]=nil
    end
    if not StructList[i] and StructList[i+1] then
      StructList[i]=StructList[i+1]
      StructList[i+1]=nil
    end
  end
end

function LoadStruct()
  for i=1,#StructList do
    StructList[i]:addToGlobalStructureList()
  end
end

function ChildStructStart(structname,elementname)
local struct=isStructExist(structname)
if struct then
for i=0,struct.Count-1 do
if struct.Element[i].Name==elementname then return struct.Element[i].ChildStructStart end end
else return nil end
end

function findAddress(name,number,AddressOrAOBString,modulename,stopaddress,Nth,aobscanOnly,gethead,nop)
	local size,address=0x100
    AddressOrAOBString,address=string.lower(AddressOrAOBString):gsub('banana','')
	if(address&gt;0)then
		local f
		if(modulename==0 or modulename==nil or modulename=='')then f=AOBScan(AddressOrAOBString)
		else
            if type(modulename)==type(0) then modulename=string.format('%X',modulename)
            elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
			local ms = createMemScan()
			if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
				stopaddress=getNameFromAddress(getAddress(modulename),true,false)
                if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
				if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
                modulename=getAddress([["]]..stopaddress..[["]])
				stopaddress=modulename+getModuleSize(stopaddress)
                modulename=string.format('%X',modulename)
			end
			ms.firstScan(soExactValue,vtByteArray,rtTruncated,AddressOrAOBString,'',getAddress(modulename),getAddress(stopaddress),'',fsmNotAligned,'',true,false,false,false)
			ms.waitTillDone()
			f = createFoundList(ms)
			f.initialize()
			ms.destroy()
		end
		address={}
		for i=0,f.Count-1 do address[i+1]=f[i]end
		f.destroy()
        if Nth==nil or Nth==0 or Nth=='' then Nth=1 end
        if gethead then
           local addresss=GetAddressSafe(address[Nth])
           if not addresss then addresss=GetAddressSafe(address[Nth-1])end
           if addresss and addresss~=0 then
           for i=0,0x1000 do
               addresss=addresss-1
               if readBytes(addresss,1)==0xCC then break end
               if nop then local ext, opc, byt, add=splitDisassembledString(disassemble(addresss)) if string.find(opc,'nop') then addresss=addresss+getInstructionSize(addresss)-1 break end end
           end
           address[Nth]=addresss+1 end
        end
		if number==nil or number==0 or number=='' then
			if aobscanOnly then return address end
		else
            if(#address==0)then error(name..' aob no result found') end
            if(getAddress(address[Nth])==nil)then error(name..' aob result '..Nth..' doesnt exist') end
            unregisterSymbol(name)
            registerSymbol(name,getAddressSafe(address[Nth]),true)
            if aobscanOnly then return end
		end
		AddressOrAOBString=GetAddressSafe(address[Nth])
	end
    AddressOrAOBString=getAddressSafe(AddressOrAOBString)
	if(AddressOrAOBString==nil)then error(name..' still cant be found')end
	local addr={}
	local i=0
	local j=1
	while(i&lt;size) do
		local ext, opc, byt, add=splitDisassembledString(disassemble(getAddressSafe(AddressOrAOBString)+i))
		if(ext~="")then
			if(opc:find(",")~=nil)then
				opc=opc:sub(opc:find(",")+1,opc:len())
			else
				opc=opc:sub(opc:find(" ")+1,opc:len())
			end
			addr[j]=opc:gsub("%[",""):gsub("]","") j=j+1
		end
        if opc:find('],') then
            opc=opc:sub(opc:find("%[")+1,opc:find("]")-1)
            if tonumber(opc,16) then addr[j]=opc j=j+1 end
        end
		i=i+getInstructionSize(AddressOrAOBString+i)
	end
    --for i=1,#addr do print(addr[i]) end
	if number==nil or number==0 or number=='' then return addr end
	local offset
	if(type(number)==type(''))then
		offset=string.find(number,',')
		if(offset==nil)then number=getAddress(number)
		else offset=getAddress(string.sub(number,offset+1,number:len()))
			number=getAddress(string.sub(number,1,string.find(number,',')-1))
		end
	end
	if offset==nil then offset=0 end
	unregisterSymbol(name)
	registerSymbol(name,getAddressSafe(addr[number])-offset,true)
end

function ue4determineversion()
 local address=findAddress('FNamePool',0,'48 8D 0D *  *  *  *  E8 *  *  *  * 4C 8B C0 C6banana',process,nil,0,true)[1]
 if address then findAddress('FNamePool',1,address) UE4ver=25 ue4parsetable() ue4config()
  local address=getAddressSafe(StaticFindObjectAlgo('/Script/Engine.GameEngine'))
  if not address or address==0 then error('StaticFindObject not functioning as expected...')end
  UE4ver=nil
  local pointer=readPointer(address+UObject.member)
  if pointer then pointer=readPointer(pointer) if pointer then UE4ver=25 end end
  if not UE4ver then UE4ver=23 end
 else
  address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[1]
  if address then findAddress('FNamePool',1,address)
  else findAddress('FNamePool',1,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20banana',process,nil,2)end
  local address=readPointer('[[GUObjectArray+10]]+18')
  if address&gt;0x10000 then
   UE4ver=22
   ue4parsetable()
   ue4config()
   FNameStringAlgo(1,true)
   local address=getAddressSafe(StaticFindObjectAlgo('/Script/Engine.GameEngine'))
   if not address or address==0 then error('StaticFindObject not functioning as expected...')end
   UE4ver=nil
   local pointer=readPointer(address+UObject.member)
   if pointer then pointer=readPointer(pointer) if pointer then UE4ver=22 end end
   if not UE4ver then UE4ver=20 end
  else UE4ver=18 end
 end
end

function fillstruct4bytes(Struct)
  if not getElementByOffset(Struct,0) then local e=Struct.addElement() e.Offset=0 e.Vartype=vtDword end
  Struct.beginUpdate()
  local count=Struct.Count-1
  local list,k,element1,element2,size,bytesize={},1
  for i=0,count do
    element1=Struct.Element[i]
    element2=Struct.Element[i+1]
    if element2 then
      bytesize=element1.Bytesize
      if bytesize&lt;4 then bytesize=4 end
      size=element2.Offset-element1.Offset-bytesize
      if size&gt;0 then
        if size%4&gt;0 then size=4-size%4+size end
        local start=element1.Offset
        if start%4&gt;0 then start=4-start%4+start
        else start=start+4 end
        size=size/4
        for j=0,size-1 do
          if (start+j*4)&gt;=(element1.Offset+bytesize) then
            list[k]=start+j*4
            k=k+1
          end
        end
      end
    end
  end
  for i,v in ipairs(list) do local e=Struct.addElement() e.Offset=v e.Vartype=vtDword end
  Struct.endUpdate()
end

function ue4createstruct(FullNameOrAddress,StructName,isGlobal,isfullname,Structu,AddedOffset,AddedName)
  if not FullNameOrAddress then return end
  if StructName and isGlobal then local Struct=isStructExist(StructName) if Struct then DeleteStruct(Struct)end end
  local member,Offset,Property,bitmask,nextmember,super,propsize=UObject.member,UObject.Offset,UObject.Property,UObject.bitmask,UObject.nextmember,UObject.super,UObject.propsize
  local Object,Name,Class,PropName,Typ,Off,pointer,e,f=FullNameOrAddress
  local isUE425=UE4ver&gt;=25
  if type(FullNameOrAddress)==type('') then Object=StaticFindObjectAlgo(FullNameOrAddress) end
  if not Object then print(FullNameOrAddress..' not found...') return end
  Name=GetNameAlgo(Object)
  if not Name or not string.find(Name,' ') then print(FullNameOrAddress..' invalid Object?') return end
  if not StructName then
    Class=Name:sub(1,string.find(Name,' ')-1)
    Name=Name:sub(string.find(Name,' ')+1,Name:len())
  else Name=StructName end

  local Struct=Structu
  if not Struct then Struct=createStructure(Name)end

  if not AddedName then AddedName='' end
  local RunningStructName=name
  if not AddedOffset then
    if not RunningStruct then RunningStruct={} end
    RunningStruct[#RunningStruct+1]=RunningStructName

    AddedOffset=0 Struct.beginUpdate()
  else
    local FullName=GetFullNameAlgo(Object)
    FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())

    if not LocalStruct then LocalStruct={}end
    if LocalStruct[FullName] then copyStruct(LocalStruct[FullName],Struct,AddedOffset,AddedName)
    else
      local copy=createStructure(FullName)
      ue4createstruct(Object,nil,nil,isfullname,copy)
      LocalStruct[FullName]=copy
      copyStruct(LocalStruct[FullName],Struct,AddedOffset,AddedName)
    end
    return
  end

  --print(string.format('%X',Object))
  while(true)do
    if not Object or Object==0 then break end
    Name=GetNameAlgo(Object)
    if not Name then break end
    Name=Name:sub(string.find(Name,' ')+1,Name:len())
    if Name=='Object' then break end
    print(GetFullNameAlgo(Object))
    pointer=readPointer(Object+UObject.member)
    while(true)do
      if not pointer or pointer==0 then break end
      PropName=isUE425 and GetFullNameSafeAlgo(pointer) or GetFullNameAlgo(pointer)
      if PropName and string.find(PropName,' ') then
        Typ=PropName:sub(1,string.find(PropName,' ')-1)
        if not string.find(Typ,'Function')then
          if not isfullname then PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())
          else PropName=PropName:sub(string.find(PropName,' ')+1,PropName:len())end
          PropName=AddedName..PropName
          Off=readInteger(pointer+Offset)+AddedOffset
          if Class=='UserDefinedStruct' and string.find(PropName,'_') then PropName=PropName:sub(1,string.find(PropName,'_')-1)end
          if Typ=='StructProperty' then
            ue4createstruct(readPointer(pointer+Property),nil,nil,isfullname,Struct,Off,PropName..'.')
            if not getElementByOffset(Struct,Off) then e=Struct.addElement() e.Offset=Off e.Name=PropName e.Vartype=vtDword end
          else
            e=Struct.addElement()
            e.Offset=Off
            e.Name=PropName
            if not ue4type[Typ] then e.Vartype=vtDword
            else e.Vartype=ue4type[Typ]end
            if Typ=='ArrayProperty' or Typ=='MapProperty' then
              f=Struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=Struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
              local isMap= Typ=='MapProperty'

              Prop=readPointer(pointer+Property)
              PropName=GetFullNameAlgo(Prop)
              if not PropName then PropName=GetFullNameSafeAlgo(Prop)end
              if PropName then
                Typ=PropName:sub(1,string.find(PropName,' ')-1)
                PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())
                if string.find(PropName,':') then PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())end
                if Typ=='StructProperty' then
                  Prop=readPointer(Prop+Property)
                  PropName=GetNameAlgo(Prop)
                  if PropName then
                    PropName=PropName:sub(string.find(PropName,' ')+1,PropName:len())..'[]'
                    --print(Typ..' '..PropName)
                  end
                else PropName=PropName..'[]' end
                if not ArrayStruct then ArrayStruct={} end
                if ArrayStruct[PropName] then e.setChildStruct(ArrayStruct[PropName])
                else
                  local stru=createStructure(PropName)
                  ArrayStruct[PropName]=stru
                  e.setChildStruct(stru)

                  stru.beginUpdate()
                  for j=0,1 do
                    Prop=readPointer(pointer+Property+j*(8-sub))
                    PropName=GetFullNameAlgo(Prop)
                    if not PropName then PropName=GetFullNameSafeAlgo(Prop)end
                    if PropName then
                      Typ=PropName:sub(1,string.find(PropName,' ')-1)
                      --if Typ=='StructProperty' then print(PropName)end
                      PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())
                      if string.find(PropName,':') then PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())end
                      local psize=isMap and 0x10 or readInteger(Prop+propsize)
                      local Offs=isMap and readInteger(Prop+Offset) or 0
                      local Propt
                      if Typ=='StructProperty' then
                        Propt=readPointer(Prop+Property)
                      end
                      for p=0,10 do
                        Off=p*psize+Offs
                        local ItemName=string.format('[%u] ',p)
                        if Typ=='StructProperty' then
                          ue4createstruct(Propt,nil,nil,isfullname,stru,Off,ItemName)
                          --if not getElementByOffset(stru,Off) then e=stru.addElement() e.Offset=Off e.Name=PropName e.Vartype=vtDword end
                        else
                          local g=stru.addElement()
                          g.Offset=Off
                          g.Name=ItemName..PropName
                          if not ue4type[Typ] then g.Vartype=vtDword
                          else g.Vartype=ue4type[Typ]end
                        end
                      end
                    end
                  end
                  stru.endUpdate()
                  fillstruct4bytes(stru)
                end
              end
            elseif Typ=='BoolProperty' then e.ChildStructStart=readBytes(pointer+bitmask,1)end
          end
        end
      end
      pointer=readPointer(pointer+nextmember)
    end
    Object=readPointer(Object+super)
  end
  if AddedOffset&gt;0 then return end
  Struct.endUpdate()
  fillstruct4bytes(Struct)
  if isGlobal then StructList[#StructList+1]=Struct end

  local count=#RunningStruct
  for i=1,count do
    if RunningStruct[i]==RunningStructName then RunningStruct[i]=nil end
    if not RunningStruct[i] and RunningStruct[i+1] then RunningStruct[i]=RunningStruct[i+1] RunningStruct[i+1]=nil end
  end
end

function getElementByOffset(struct,offset)
  for i=0,struct.Count-1 do
    if struct.Element[i].Offset==offset then return i end
  end
  return nil
end

function copyStruct(original,copy,AddedOffset,AddedName)
  if not copy then copy=createStructure(original.Name..'_copy')end
  if not AddedOffset then AddedOffset=0 end
  if not AddedName then AddedName='' end
  copy.beginUpdate()
  for i=0,original.Count-1 do
    local e=copy.addElement()
    e.Offset=original.Element[i].Offset+AddedOffset
    if original.Element[i].Name=='' then e.Name=original.Element[i].Name
    else e.Name=AddedName..original.Element[i].Name end
    e.Vartype=original.Element[i].Vartype
    e.ChildStruct=original.Element[i].ChildStruct
    e.ChildStructStart=original.Element[i].ChildStructStart
    e.Bytesize=original.Element[i].Bytesize
  end
  copy.endUpdate()
  return copy
end

function ue4createstructfast(fullnameortable,StructName,isGlobal,isfullname,structu,AddedOffset,AddedName,depth,callernum)
  if not callernum then callernum=0 end
  if not depth then depth=10 end
  local depths=0
  callernum=callernum+1
  if callernum&gt;10 then return end
  if StructName and isGlobal then local struct=isStructExist(StructName) if struct then DeleteStruct(struct) end end
  if not UEObj then enumUEObj() end
  local tabl=fullnameortable
  if type(fullnameortable)==type('') then
    for i,v in ipairs(UEObj) do if v.FullName==fullnameortable then tabl=v break end end
  end
  --[[
  if not tabl or type(tabl)~=type({})  then
    enumUEObj()
    if type(fullnameortable)==type('') then
      for i,v in ipairs(UEObj) do if v.FullName==fullnameortable then tabl=v break end end
    end
  end
  ]]
  if not tabl or type(tabl)~=type({})  then
    print(tostring(fullnameortable)..' not found...')
    return
  end
  local name=StructName
  if not name then name=tabl.Name end
  local struct=structu
  if not struct then struct=createStructure(name)end
  if not AddedName then AddedName='' end
  local RunningStructName=name
  if not AddedOffset then
    if not RunningStruct then RunningStruct={} end
    RunningStruct[#RunningStruct+1]=RunningStructName

    AddedOffset=0 struct.beginUpdate()
  elseif tabl and tabl.FullName then
    if not LocalStruct then LocalStruct={}end
    if LocalStruct[tabl.FullName] then copyStruct(LocalStruct[tabl.FullName],struct,AddedOffset,AddedName)
    else
      local copy=createStructure(tabl.FullName)
      ue4createstructfast(tabl,nil,nil,isfullname,copy)
      LocalStruct[tabl.FullName]=copy
      copyStruct(LocalStruct[tabl.FullName],struct,AddedOffset,AddedName)
    end
    return
  end

  --print(tostring(tabl))
  local isUserDefinedStruct=string.find(tabl.Type,'UserDefinedStruct')
  local e,typ,propname
  while(true)do
    if not tabl then break end
    if type(tabl)==type(1) or tabl.Name=='Object' then break end
    print(tostring(tabl.Type)..' '..tostring(tabl.FullName))
    if tabl.Member then
      for i=1,#tabl.Member do
        if tabl.Member[i].Type~='Function' then
          if isfullname then e.Name=string.format('%s %s%s',tabl.Member[i].Type,AddedName,tabl.Member[i].FullName)
          else
            propname=AddedName..tabl.Member[i].Name
            if isUserDefinedStruct then propname=propname:sub(1,string.find(propname,'_')-1) end
          end
          if tabl.Member[i].Type=='StructProperty' then
            ue4createstructfast(tabl.Member[i].Property,nil,nil,isfullname,struct,tabl.Member[i].Offset+AddedOffset,propname..'.',depth,callernum)
            if not getElementByOffset(struct,tabl.Member[i].Offset+AddedOffset) then e=struct.addElement() e.Offset=tabl.Member[i].Offset+AddedOffset e.Name=propname e.Vartype=vtDword end
          else
            e=struct.addElement()
            e.Offset=tabl.Member[i].Offset+AddedOffset
            typ=tabl.Member[i].Type
            e.Name=propname
            e.Vartype=ue4type[typ]
            if e.Vartype==nil then e.Vartype=vtDword end
            if typ=='ArrayProperty' or typ=='MapProperty' then
              local isMap= Typ=='MapProperty'
              local Typ=tabl.Member[i].Property[1].Type
              if Typ=='StructProperty' then propname=tabl.Member[i].Property[1].Property.Name..'[]'
              else propname=tabl.Member[i].Property[1].Name..'[]' end
              if not ArrayStruct then ArrayStruct={} end
              if ArrayStruct[propname] then e.setChildStruct(ArrayStruct[propname])
              else
                local stru=createStructure(propname)
                stru.beginUpdate()
                for p=1,#tabl.Member[i].Property do
                  local PropName=tabl.Member[i].Property[p].Name
                  local Typ=tabl.Member[i].Property[p].Type
                  local psize=isMap and 0x10 or tabl.Member[i].Property[p].Size
                  local Offs=isMap and tabl.Member[i].Property[p].Offset or 0
                  for l=0,10 do
                    Off=l*psize+Offs
                    local ItemName=string.format('[%u] ',l)
                    if Typ=='StructProperty' then
                      ue4createstructfast(tabl.Member[i].Property[p].Property,nil,nil,isfullname,stru,Off,ItemName,depth,callernum)
                      --if not getElementByOffset(stru,Off) then g=stru.addElement() g.Offset=Off g.Name=ItemName..PropName g.Vartype=vtDword end
                    else
                      g=stru.addElement()
                      g.Offset=Off
                      g.Name=ItemName..PropName
                      if not ue4type[Typ] then g.Vartype=vtDword
                      else g.Vartype=ue4type[Typ]end
                    end
                  end
                end
                stru.endUpdate()
                if stru.Count&gt;1 then
                  fillstruct4bytes(stru)
                  e.setChildStruct(stru)
                  ArrayStruct[propname]=stru
                else stru:Destroy()end
              end

              local f=struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
            elseif typ=='BoolProperty' then e.ChildStructStart=tabl.Member[i].BitField end
          end
        end
      end
    end
    depths=depths+1
    if depths&gt;depth then break end
    tabl=tabl.Parent
  end
  if AddedName~='' then return end
  struct.endUpdate()

  fillstruct4bytes(struct)
  if isGlobal then StructList[#StructList+1]=struct end

  local count=#RunningStruct
  for i=1,count do
    if RunningStruct[i]==RunningStructName then RunningStruct[i]=nil end
    if not RunningStruct[i] and RunningStruct[i+1] then RunningStruct[i]=RunningStruct[i+1] RunningStruct[i+1]=nil end
  end
end

function uecreatestruct(instance,name,depth,isfullname)
  local pointer=readPointer(instance+UObject.Class)
  local classname=GetFullNameAlgo(pointer)
  if not classname then print('instance is invalid') return end
  if classname:find(' ') then classname=classname:sub(classname:find(' ')+1) end

  print(string.format("createThread(ue4createstruct(\'%s\',\'%s\',0))",classname,name))
  ue4createstruct(pointer,name,depth,isfullname)
end

function ue_structureDissectOverrideCallback(Struct, Instance)
  --print('banana2')
  local name,fullname,class
  address,name,fullname,class=ue_findRealStartOfObject(Instance)

  if class then
   -- print('banana3')
    --if UEObj and (not enumUEObjIsRunning or enumUEObjIsUpdateOnly) then ue4createstructfast(fullname,nil,nil,nil,Struct) end
    SaveAndRemoveStruct()
    ue4createstruct(class,nil,nil,nil,Struct)
    LoadStruct()
    if Struct.Count&gt;1 then return true
    else return false end
  end

  --ue_fillstruct(readPointer(Instance+UObject.Class),structure)
  --print('banana4')

  return nil
end

function ue_structureNameLookupCallback(address)
  --print('banana1')
  local name,fullname
  address,name,fullname=ue_findRealStartOfObject(address)
  if name then return name,address end
  return nil
end

function ue_SymbolLookupCallback(symbol)
  --print('banana1')
  local str='Function '
  if string.find(symbol,str) then
    symbol=symbol:sub(string.find(symbol,str)+str:len(),symbol:len())
    local pointer=StaticFindObjectAlgo(symbol)
    if pointer then return readPointer(pointer+UObject.funct)end
  end
  return nil
end

function ue_findRealStartOfObject(address)
  local pointer=readPointer(address+UObject.Class)
  if pointer then
    local FullName=GetFullNameAlgo(pointer)
    if FullName then
      local Name=GetNameAlgo(pointer)
      FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
      Name=Name:sub(string.find(Name,' ')+1,Name:len())
      return address,Name,FullName,pointer
    end
  end

  if UEObj and (not enumUEObjIsRunning or enumUEObjIsUpdateOnly) then
    for i=1,#UEObj do
      if UEObj[i].MemberSize and UEObj[i].Class and UEObj[i].Class.MemberSize and UEObj[i].Class.MemberSize&gt;0 and not string.find(UEObj[i].Class.FullName,'/Script/CoreUObject.') then
         if address&gt;=UEObj[i].Address and address&lt;UEObj[i].Address+UEObj[i].Class.MemberSize then
           local name
           return UEObj[i].Address,UEObj[i].Class.Name,UEObj[i].Class.FullName,UEObj[i].Class.Address
         end
      end
    end
  end

  return address
end


function enumUEObjT(file,size,i,start,stop)
 local datatable,Address,FName,Name,FullName,typ,typ1,isProperty,l,pointer,stri,num,isPropertyc,EObj,k=0
 local Class,ObjectId,super,Offset,nextmember,member,propsize,bitmask,Property,Outer=UObject.Class,UObject.ObjectId,UObject.super,UObject.Offset,UObject.nextmember,UObject.member,UObject.propsize,UObject.bitmask,UObject.Property,UObject.Outer
 local UEver=UE4ver
 local pointersize= targetIs64Bit() and 8 or 4

 for j=start,stop do

    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x8+m] then break end
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      Address=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x4+m] then break end
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      Address=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x18+m] then break end
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      Address=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x10+m] then break end
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      Address=byteTableToDword(datatable)
    end

    if Address and Address~=0 then
       objid=readInteger(Address+ObjectId)
       if objid then
          if objid&lt;size then
             FullName=GetFullNameAlgo(Address)

             if FullName then
               isProperty=false
               typ1=FullName:sub(1,string.find(FullName,' ')-1)
               FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
               if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len()) isProperty=true
               elseif string.find(FullName,'%.') then Name=FullName:sub(string.find(FullName,'%.')+1,FullName:len())
               else Name=FullName end
               if UEObjIndex[FullName] and UEObj[UEObjIndex[FullName]] then UEObj[UEObjIndex[FullName]].Address=Address
               else
                 EObj={}
                 EObj.Address=Address
                 EObj.Id=objid
                 EObj.Class=temp[readPointer(Address+Class)]
                 EObj.Type=typ1
                 EObj.FullName=FullName
                 EObj.Name=Name
                 if isProperty then
                   isProperty=readPointer(Address+Outer)
                   if isProperty and isProperty~=0 then
                     EObj.Outer=isProperty
                     EObj.Size=readInteger(Address+propsize)
                     EObj.Offset=readInteger(Address+Offset)
                     if typ1=='BoolProperty' then EObj.BitField=readBytes(Address+bitmask,1)
                     elseif typ1=='StructProperty' or typ1=='ObjectProperty' then EObj.Property=readPointer(Address+Property)
                     elseif typ1=='MapProperty' or typ1=='ArrayProperty' then
                       EObj.Property={}
                       local count= typ1=='MapProperty' and 1 or 0
                       for p=0,count do
                         local prop=readPointer(Address+Property+p*8)
                         FullName=GetFullNameAlgo(prop)
                         if not FullName then FullName=GetFullNameSafeAlgo(prop)end
                         if FullName then
                           typ=FullName:sub(1,string.find(FullName,' ')-1)
                           FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
                           if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len())
                           else Name=FullName end
                           if string.find(Name,'%:') then Name=Name:sub(string.find(Name,'%:')+1,Name:len())end
                           local Prop={}
                           Prop.Address=prop
                           Prop.Type=typ
                           Prop.FullName=FullName
                           Prop.Name=Name
                           Prop.Size=readInteger(prop+propsize)
                           Prop.Offset=readInteger(prop+Offset)
                           if typ=='BoolProperty' then Prop.BitField=readBytes(prop+bitmask,1)
                           elseif typ=='StructProperty' or typ=='ObjectProperty' then Prop.Property=readPointer(prop+Property)end
                           EObj.Property[p+1]=Prop
                         end
                       end
                     end
                   else print(FullName..' nil outer')
                   end
                 end

                 Parent=readPointer(Address+super)
                 if Parent and Parent~=0 then EObj.Parent=Parent end
                 temp[Address]=EObj
                 if UEver&gt;=25 then
                   k=1
                   EObj.MemberSize=readInteger(Address+member+pointersize)
                   Address=readPointer(Address+member)
                   EObj.Member={}

                   while(true)do
                     if UEver&gt;=25 then FullName=GetFullNameSafeAlgo(Address)
                     else FullName=GetFullNameAlgo(Address) end
                     if not FullName then break end

                     typ=FullName:sub(1,string.find(FullName,' ')-1)
                     FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
                     if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len())
                     else Name=FullName end
                     EObj.Member[k]={}
                     EObj.Member[k].Address=Address
                     EObj.Member[k].Type=typ
                     EObj.Member[k].FullName=FullName
                     EObj.Member[k].Name=Name
                     EObj.Member[k].Size=readInteger(Address+propsize)
                     EObj.Member[k].Offset=readInteger(Address+Offset)
                     if typ=='BoolProperty' then EObj.Member[k].BitField=readBytes(Address+bitmask,1)
                     elseif typ=='StructProperty' or typ=='ObjectProperty' then EObj.Member[k].Property=readPointer(Address+Property)
                     elseif typ=='MapProperty' or typ=='ArrayProperty' then
                       EObj.Member[k].Property={}
                       for p=0,1 do
                         local prop=readPointer(Address+Property+p*8)
                         FullName=GetFullNameAlgo(prop)
                         if not FullName then FullName=GetFullNameSafeAlgo(prop)end
                         if FullName then
                           typ=FullName:sub(1,string.find(FullName,' ')-1)
                           FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
                           if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len())
                           else Name=FullName end
                           if string.find(Name,'%:') then Name=Name:sub(string.find(Name,'%:')+1,Name:len())end
                           local Prop={}
                           Prop.Address=prop
                           Prop.Type=typ
                           Prop.FullName=FullName
                           Prop.Name=Name
                           Prop.Size=readInteger(prop+propsize)
                           Prop.Offset=readInteger(prop+Offset)
                           if typ=='BoolProperty' then Prop.BitField=readBytes(prop+bitmask,1)
                           elseif typ=='StructProperty' or typ=='ObjectProperty' then local propt=readPointer(prop+Property) if propt then Prop.Property=propt end end
                           EObj.Member[k].Property[p+1]=Prop
                         end
                       end
                       if #EObj.Member[k].Property==0 then EObj.Member[k].Property=nil end
                     end
                     Address=readPointer(Address+nextmember)
                     k=k+1
                   end
                   if #EObj.Member==0 then EObj.Member=nil end
                 end
                 UEObj[#UEObj+1]=EObj
                 UEObjIndex[EObj.FullName]=#UEObj+1
               end
             end
          end
       end
    end
 end
--print(i..':'..k)
end

function enumUEObj(isSilent,isUpdateOnly)
 if isUpdateOnly then enumUEObjIsUpdateOnly=true end
 enumUEObjIsRunning=true
 local sub=targetIs64Bit() and 0 or 4
 ue4parsetablecheck()
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local starttime=os.time()
 if not isUpdateOnly then
   UEObj={}
   UEObjIndex={}
 end
 temp={}
 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess+0.5) do
   start=stop
   stop=stop+num
   createThread(enumUEObjT(file,size,i,start,stop-1))
  end
 end
 if not isUpdateOnly then
   if UE4ver&gt;=25 then
     for i=1,#UEObj do
       if UEObj[i].Parent then
         if temp[UEObj[i].Parent] then
           UEObj[i].Parent=temp[UEObj[i].Parent]
         end
       end
       if UEObj[i].Member then
         for j=1,#UEObj[i].Member do
           if UEObj[i].Member[j].Property then
             if temp[UEObj[i].Member[j].Property] then
               UEObj[i].Member[j].Property=temp[UEObj[i].Member[j].Property]
             elseif type(UEObj[i].Member[j].Property)==type({}) then
               for p=1,#UEObj[i].Member[j].Property do
                 if temp[UEObj[i].Member[j].Property[p].Property] then
                   UEObj[i].Member[j].Property[p].Property=temp[UEObj[i].Member[j].Property[p].Property]
                 elseif UEObj[i].Member[j].Property[p].Property then print(string.format('%X no object?',UEObj[i].Member[j].Property[p].Property))
                 elseif UEObj[i].Member[j].Property[p].Type=='StructProperty' or UEObj[i].Member[j].Property[p].Type=='ObjectProperty' then print(string.format('%s %s no property?',UEObj[i].Member[j].Property[p].Type,UEObj[i].Member[j].Property[p].FullName))
                 end
               end
             end
           end
         end
       end
     end
   else
     for i=1,#UEObj do
       if UEObj[i].Parent then
         if temp[UEObj[i].Parent] then
           UEObj[i].Parent=temp[UEObj[i].Parent]
         end
       end
       if UEObj[i].Outer then
         if temp[UEObj[i].Outer]then
           if temp[UEObj[i].Property] then
             UEObj[i].Property=temp[UEObj[i].Property]
           elseif type(UEObj[i].Property)==type({}) then
             for p=1,#UEObj[i].Property do
               if temp[UEObj[i].Property[p].Property] then
                 UEObj[i].Property[p].Property=temp[UEObj[i].Property[p].Property]
               else print(string.format('%X no object?',UEObj[i].Property[p].Property))
               end
             end
           end
           if not temp[UEObj[i].Outer].Member then temp[UEObj[i].Outer].Member={}end
           temp[UEObj[i].Outer].Member[#temp[UEObj[i].Outer].Member+1]=UEObj[i]
         else print(UEObj[i].FullName..' missing outer') end
       end
     end
   end
 end
 temp=nil
 enumUEObjIsUpdateOnly=false
 enumUEObjIsRunning=false
 if not isSilent then print(string.format('\nA Total of %u objects had been enumerated in %u seconds',#UEObj,os.time()-starttime))end
end



function findOpcodes(address,opcode,size)
  if not size then size=0x50 end
  address=getAddressSafe(address)
  if not address then return nil end
  local addr={}
  local i=0
  local j=1
  while(i&lt;size) do
    local ext, opc, byt, add=splitDisassembledString(disassemble(address+i))
    if string.find(opc,opcode) then
      addr[j]=address+i
      j=j+1
    end
    i=i+getInstructionSize(address+i)
  end
  return addr
end

--local ext, opc, byt, add=splitDisassembledString(disassemble(findOpcodes('/Script/Astro.PrinterComponent:UpdatePreprinting_exec','call')[1]))
--return opc:sub(string.find(opc,' ')+1,opc:len())

function groupscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtGrouped,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function UEfindInstancesOfClass(fullnameOrAddress)
  local class,address=UObject.Class
  if type(fullnameOrAddress)==type('')then address=StaticFindObjectAlgo(fullnameOrAddress)
  else address=fullnameOrAddress end
  local fname=readInteger(address+UObject.FNameIndex)
  local result=groupscan(string.format('%u:%u 4:%u',targetIs64Bit() and 8 or 4,address,fname))
  for i,v in ipairs(result) do result[i]=tonumber(v,16)-class end
  return result
end

function StructAddToListSymbol(StructName,StartOffset,StopOffset,BaseAddress,OffsetOnly)
  if not StartOffset then StartOffset=0 end
  if not StopOffset then StopOffset=0xFFFFFF end
  local structCount=getStructureCount()
  local struct
  for i=0,structCount-1 do
    local stru=getStructure(i)
    if stru.Name==StructName then struct=stru break end
  end
  if struct then
    for i=0,struct.Count-1 do
      local e=struct.Element[i]
      if e.Offset&gt;=StartOffset and e.Offset&lt;=StopOffset then
        local rec=getAddressList().createMemoryRecord()
        rec.setDescription(e.Name)
        if OffsetOnly then
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.Offset[0]=e.Offset
          else rec.setAddress(string.format('+%X',e.Offset))end
        else
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.OffsetText[0]=StructName..'.'..e.Name
          else rec.setAddress(string.format('+%s.%s',StructName,e.Name))end
        end
        rec.Type=e.Vartype
      end
    end
  end
end

function getInsForJump(address,registername,destination,allocsize,SharedMemoryName)
  address = getAddressSafe(address)
  if not address then error('getInsForJump address nil') return end
  if not allocsize then allocsize=4096 end
  destination=getAddressSafe(destination)
  if not destination then
	if not SharedMemoryName then destination = allocateMemory(allocsize,address)
	else destination = allocateSharedMemory(SharedMemoryName,allocsize) end
  end
  local size = (address+5-destination&gt;0x7FFFFFFF) and 14 or 5
  if registername then
	unregisterSymbol(registername)
	registerSymbol(registername,destination,true)
  end
  local opcodes = {}
  local i = 0
  while(i&lt;size) do
    local ext, opc=splitDisassembledString(disassemble(address+i))
    opcodes[#opcodes+1] = opc
    i=i+getInstructionSize(address+i)
  end
  local copy = table.concat(opcodes,'\r\n')
  local readAsTable = true
  local byt = readBytes(address,i,readAsTable)
  for j=1,#byt do byt[j] = ('%02X'):format(byt[j]) end
  local bytes = table.concat(byt, ' ')
  return i,copy,bytes,size,destination
end

function enablescript(name,registername,addressname,script,disable)
    local address=getAddress(addressname)
    if disable then script=(script):format(address,registername,readBytes(registername,1))
    else
        local i,copy,bytes,size =getInsForJump(address,name)
        script=(script):format(registername, registername, name, copy, registername, i, bytes, address)..string.rep('nop\n',i-size)..'returnhere:'
    end
    local success,erro=autoAssembleCheck(script)
    if not success then print('\n'..erro..'\n')local scriptstr=createStringlist()scriptstr.Text=script for j=0,scriptstr.Count-1 do print(string.format('%u\t%s',j+1,scriptstr[j])) end
    if not disable then deAlloc(name)unregisterSymbol(name)end error(name..' autoAssemble failed')end
    autoAssemble(script)
    if disable then deAlloc(name)unregisterSymbol(name)unregisterSymbol(registername)end
end

function cycleFullCompact(sender,force)
local state = not(compactmenuitem.Caption == 'Compact View Mode')
if force~=nil
then state = not force
end
compactmenuitem.Caption = state and 'Compact View Mode' or 'Full View Mode'
getMainForm().Splitter1.Visible = state
getMainForm().Panel4.Visible = state
getMainForm().Panel5.Visible = state
end

function addCompactMenu()
if compactmenualreadyexists
then return end
local parent = getMainForm().Menu.Items
compactmenuitem = createMenuItem(parent)
parent.add(compactmenuitem)
compactmenuitem.Caption = 'Compact View Mode'
compactmenuitem.OnClick = cycleFullCompact
compactmenualreadyexists = 'yes'
end

addCompactMenu()
--cycleFullCompact(nil,true)

if syntaxcheck then return end

[ENABLE]
if not process or not enumModules()[1] then print('Error: No process selected...') error('process is nil') end
local starttime=os.time()
ue4versioncheck()

if targetIs64Bit() then

 local address=findAddress('GUObjectArray',0,'44 8B * * * 48 8D 05 * * * * * * * * * 48 89 71 10banana',process,nil,0,true)[1]
 if not address then address=findAddress('GUObjectArray',0,'40 53 48 83 EC 20 48 8B D9 48 85 D2 74 * 8Bbanana',process,nil,0,true)[1]end
 if not address then address=findAddress('GUObjectArray',0,'4C 8B 05 * * * * 45 3B 88banana',process,nil,0,true)[1]end
 if not address then error('GUObjectArray aob not found...')end
 findAddress('GUObjectArray',1,address)

 ue4config()

 if UE4ver&gt;=23 then
   address=findAddress('FNamePool',0,'4C 8D 05 * * * * EB 16 48 8D 0D * * * * E8banana',process,nil,0,true)[1]
   if not address then address=findAddress('FNamePool',0,'48 8D 0D *  *  *  *  E8 *  *  *  * 4C 8B C0 C6banana',process,nil,0,true)[1]end
   if address then findAddress('FNamePool',1,address)
   else error('FNamePool aob not found...')end
 else
  address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[2]
  if not address then address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[1] end
  if address then findAddress('FNamePool',1,address)
  else findAddress('FNamePool',1,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20banana',process,nil,2)end
 end
 local address=findAddress('GEngine',0,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process,nil,0,true)[1]
 if not address then address=findAddress('GEngine',0,'48 8B 1D * * * * 48 85 DB 74 * 48 8Dbanana',process,nil,0,true)[1]end
 if not address then error('GEngine aob not found...')end
 findAddress('GEngine',1,address)
 --findAddress('GEngine',1,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process)

else
 ue4config()
 if UE4ver&gt;2 then
  findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  findAddress('GUObjectArray',1,'8B 44 24 04 56 8B F1 85 C0 74 17 8B 40 08banana',process)
  findAddress('FNamePool',1,'33 F6 89 35 * * * * 8B C6 5Ebanana',process,nil,1,nil,true,true)
 else
  findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  findAddress('FNamePool',1,'8B 07 8B 0D * * * * 8B 04 81banana',process)
  findAddress('GUObjectArray',1,'8B 15 * * * * 8B 04 82 85banana',process)
 end
end
print('AOBScan done : '..os.time()-starttime)
ue4parsetable()
--findAddress('GWorld',1,'4D 8B 94 24 50 0C 00 00banana',process)

FNameStringAlgo(1,true)

print('Table parsing done : '..os.time()-starttime)

if UE4ver&gt;2 then

-- createThread(function()
   SaveAndRemoveStruct()

   createThread(ue4createstruct('/Script/Engine.GameEngine','GameEngine',1))
   createThread(ue4createstruct('/Script/Engine.GameViewportClient','GameViewportClient',0))
   createThread(ue4createstruct('/Script/Engine.GameInstance','GameInstance',0))
   createThread(ue4createstruct('/Script/Engine.LocalPlayer','LocalPlayer',1))
   createThread(ue4createstruct('/Script/Engine.PlayerController','PlayerController',2))
   createThread(ue4createstruct('/Script/Engine.CharacterMovementComponent','MovementComponent',0))
   createThread(ue4createstruct('/Script/Engine.CapsuleComponent','CapsuleComponent',3))
   createThread(ue4createstruct('/Script/Engine.Character','GPlayer',0))
   createThread(ue4createstruct('/Script/Engine.World','World',0))

 local RunningStructCounter=0
 while(true)do
   if #RunningStruct==0 then break
   else sleep(1)end
   RunningStructCounter=RunningStructCounter+1
   if RunningStructCounter&gt;180000 then break end
 end


   LoadStruct()
-- end)

end

print('All done : '..os.time()-starttime..'\n')
if not ue_SymbolLookupCallbackID then
  ue_SymbolLookupCallbackID=registerSymbolLookupCallback(ue_SymbolLookupCallback,slNotSymbol)
end
--registerFuncAlgo()
GetLuaEngine().close()
[DISABLE]
--cycleFullCompact(nil,false)
unregisterSymbolLookupCallback(ue_SymbolLookupCallbackID)
ue_SymbolLookupCallbackID=nil
unregisterSymbol('GEngine')
unregisterSymbol('GUObjectArray')
unregisterSymbol('FNamePool')
</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>26124</ID>
                  <Description>"Enable ue_structureDissectCallback (Experimental)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
if not ue_structureDissectOverrideCallbackID then
  ue_structureDissectOverrideCallbackID=registerStructureDissectOverride(ue_structureDissectOverrideCallback)
end

if not ue_structureNameLookupCallbackID then
  ue_structureNameLookupCallbackID=registerStructureNameLookup(ue_structureNameLookupCallback)
end

UEObjt=createThread(function()
  while(true)do
    if not UEObj and not enumUEObjIsRunning then enumUEObj(1)
    elseif not enumUEObjIsRunning then enumUEObj(1,1)end
    sleep(30000)
  end
end)
 
[DISABLE]
unregisterStructureDissectOverride(ue_structureDissectOverrideCallbackID)
unregisterStructureNameLookup(ue_structureNameLookupCallbackID)
ue_structureDissectOverrideCallbackID=nil
ue_structureNameLookupCallbackID=nil

UEObjt:terminate()
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26125</ID>
                  <Description>"Basic UE Object Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local Offset,ObjectId,nextmember,member,enumMul,Property=UObject.Offset,UObject.ObjectId,UObject.nextmember,UObject.member,UObject.enumMul,UObject.Property

function ue4dump(file,address,size,i,start,stop)
 local k=0
 local addy= targetIs64Bit() and 8 or 4
 local en= targetIs64Bit() and 0x40 or 0x2C
 local pointer,datatable,pointers,propname,offset,list,str,strid,name,objid
 for j=start,stop do

    if UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x8+m] then break end
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x4+m] then break end
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x18+m] then break end
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x10+m] then break end
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end

    if pointer and pointer~=0 then
       local objid=readInteger(pointer+ObjectId)
       if objid then
          if objid&lt;size then
             str=string.format('%016X',pointer)
             strid=string.format('%08u',objid)
             name=GetFullNameSuperAlgo(pointer,true)
             if name then
                 typ=name:sub(1,string.find(name,' ')-1)
                 if string.find(typ,'Property') then
                     if (typ=='StructProperty' or string.find(typ,'ObjectProperty') or string.find(typ,'ArrayProperty') ) and Property then
                       name=hasProperty(pointer)
                     end
                     strid=string.format('%8X',readInteger(pointer+Offset))
                 end

                 file:write(string.format('[%s] %s %s\n',strid,str,name))


                 if (typ=='UserDefinedEnum' or typ=='Enum') and enumMul then
                   list=pointer+en
                   for i=0,readInteger(list+8)-1 do
                     pointers=readPointer(list)+i*enumMul
                     offset=readBytes(pointers+addy,1)
                     if offset==0 then offset=i end
                     propname=FNameStringAlgo(pointers)
                     strid=string.format('%8X',offset)
                     str=string.format('%016X',pointers)
                     file:write(string.format('[%s] %s %s\n',strid,str,propname))
                   end
                 elseif ( typ=='MapProperty' or string.find(typ,'ArrayProperty') ) and Property then
                   for n=0,1 do
                     pointers=readPointer(pointer+n*8+Property)
                     propname=hasProperty(pointers)
                     if propname then
                       offset=readInteger(pointers+Offset)
                       strid=string.format('%8X',offset)
                       str=string.format('%016X',pointers)
                       file:write(string.format('[%s] %s %s\n',strid,str,propname))
                     end
                   end
                 end

                 if UE4ver&gt;=25 then
                     local pointers= readPointer(pointer+member)
                     while(true)do
	                     propname=GetFullNameSafeAlgo(pointers)
	                     if not propname then break end
	                     offset=readInteger(pointers+Offset)
	                     strid=string.format('%8X',offset)
                         str=string.format('%016X',pointers)

                         typ=propname:sub(1,string.find(propname,' ')-1)
                         if typ=='StructProperty' or string.find(typ,'ObjectProperty') or string.find(typ,'ArrayProperty') then
                           propname=hasProperty(pointers)
                         end

	                     file:write(string.format('[%s] %s %s\n',strid,str,propname))


                         if typ=='MapProperty' or string.find(typ,'ArrayProperty') then
                           for n=0,2 do
                             pointer=readPointer(pointers+n*8+Property)
                             propname=hasProperty(pointer)
                             if propname then
                               offset=readInteger(pointer+Offset)
                               strid=string.format('%8X',offset)
                               str=string.format('%016X',pointer)
                               file:write(string.format('[%s] %s %s\n',strid,str,propname))
                             end
                           end
                         end

	                     pointers=readPointer(pointers+nextmember)
                     end
                 end
                 k=k+1
             end
          end
       end
    end
 end
    totalobject=totalobject+k
--print(i..':'..k)
end


 local sub=targetIs64Bit() and 0 or 4
 ue4parsetablecheck()
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local starttime=os.time()
 local Path = 'C:\\test\\'
 local filename= string.format('[%s] ObjectsDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
--local re={rei1,rei2,rei3,rei4,rei5}
 totalobject=0
--allobject=createStringlist()

 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess+0.5) do
   start=stop
   stop=stop+num
   createThread(ue4dump(file,GUObjectDict[i],size,i,start,stop-1))
  end
 end


 file:close()
 print(string.format('\nA Total of %u objects had been dumped in %u seconds',totalobject,os.time()-starttime))
 print(Path..filename)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26126</ID>
                  <Description>"Basic UE Name Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function uenamedump(file,start,stop)
  for i=start,stop do
    local name=FNameStringAlgo(i,true)
    if name and name:len()&lt;200 and name:len()&gt;3 and not string.find(name,'%c')  then
      --print(name)
      local strid=string.format('%08X',i)

      file:write(string.format('[%s] %s\n',strid,name))
      totalname=totalname+1
    end
  end
end


 local size
 if UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
 elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
 else size=math.floor(#FNameDict[1]/4) end
 local count=0x200
 size=math.floor((size/count)+0.5)

 local starttime=os.time()
 local Path = 'C:\\test\\'
 local filename= string.format('[%s] NamesDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
 totalname=0
 ue4parsetablecheck()
 local num,start,stop=count,0,0
 for i=0,size do
   start=stop
   stop=stop+num
   createThread(uenamedump(file,start,stop-1))
 end
 file:close()
 print(string.format('\nA Total of %u names had been dumped in %u seconds',totalname,os.time()-starttime))
 print(Path..filename)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26127</ID>
                  <Description>"NoClip &amp; Fly                                            Numpad6 :Toggle, Space :Up, LeftCtrl :Down"</Description>
                  <Options moHideChildren="1" moDeactivateChildrenAsWell="1"/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end

[ENABLE]

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) &amp; ~ ChildStructStart('PlayerController','bActorEnableCollision')
writeBytes(address,bActorEnableCollision)
end

--[[
Enum /Script/Engine.EMovementMode
0:MOVE_None
1:MOVE_Walking
2:MOVE_NavWalking
3:MOVE_Falling
4:MOVE_Swimming
5:MOVE_Flying
6:MOVE_Custom
7:MOVE_MAX

local list=+0x40
for i=0,readInteger(list+8)-1 do
local pointer=readPointer(list)+i*0x10
local enum=readInteger(pointer+8)
local name=FNameString(pointer)
print(enum..':'..name)
end
]]


if not RelativeLocationZoffset then
  local address=getAddress('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  local value=readInteger(address+getAddress('CapsuleComponent.RelativeLocation.Z'))
  local list=groupscan(string.format('4:%u',value),address,address+0x1000)
  RelativeLocationZoffset={}
  for i=1,#list do
    RelativeLocationZoffset[i]=getAddress(list[i])-address
  end
end

updown = createTimer()
updown.Interval = 5
updown.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_SPACE) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])+20)
      end
    end
    if isKeyPressed(VK_LCONTROL) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])-20)
      end
    end
  end
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MovementMode')
  if address then
  writeBytes(address,5)
  end
end




[DISABLE]
updown.destroy()

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) | ChildStructStart('PlayerController','bActorEnableCollision')
writeBytes(address,bActorEnableCollision)
end

local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MovementMode')
if address then
writeBytes(address,1)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Toggle Activation</Action>
                      <Keys>
                        <Key>102</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                  </Hotkeys>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26128</ID>
                      <Description>"WASD"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
wasd = createTimer()
wasd.Interval = 5
wasd.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_S) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)+20)
      end
    end
    if isKeyPressed(VK_W) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)-20)
      end
    end
    if isKeyPressed(VK_A) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)+20)
      end
    end
    if isKeyPressed(VK_D) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)-20)
      end
    end
  end
end

[DISABLE]
wasd.destroy()
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>26129</ID>
                  <Description>"bCanBeDamaged false (Godmode)      Numpad4 :Deactive, Numpad5 :Active"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end

[ENABLE]
--CanBeDamaged = createTimer()
--CanBeDamaged.setInterval(1000)
--CanBeDamaged.OnTimer = function()
local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bCanBeDamaged')
if address then
local bCanBeDamaged=readBytes(address,1) &amp; ~ ChildStructStart('PlayerController','bCanBeDamaged')
writeBytes(address,bCanBeDamaged)
end
--end
 
 
[DISABLE]
--CanBeDamaged.destroy()

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bCanBeDamaged')
if address then
local bCanBeDamaged=readBytes(address,1) | ChildStructStart('PlayerController','bCanBeDamaged')
writeBytes(address,bCanBeDamaged)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>101</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>100</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26130</ID>
                  <Description>"Jump Multiplier                                       Numpad0 :Deactive, Numpad1 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
jumpmultiplier=1
if syntaxcheck then return end
if not jumpdefault then jumpdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')end
if not MaxAccelerationdefault then MaxAccelerationdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')end
if not AirControldefault then AirControldefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')end
[ENABLE]
jumpmuti=createHotkey(function()jumpmultiplier=jumpmultiplier+0.5 end,VK_NUMPAD1)
jump = createTimer()
jump.setInterval(1000)
jump.OnTimer = function()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')
local address2=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')
local address3=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')
if address then writeFloat(address,jumpdefault*jumpmultiplier)
writeFloat(address2,MaxAccelerationdefault*jumpmultiplier)
writeFloat(address3,AirControldefault*jumpmultiplier)
end
end
[DISABLE]
jump.destroy()
jumpmuti.destroy()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')
local address2=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')
local address3=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')
if address then writeFloat(address,jumpdefault)
writeFloat(address2,MaxAccelerationdefault)
writeFloat(address3,AirControldefault)
end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>97</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>96</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26131</ID>
                  <Description>"WalkSpeed Multiplier                             Numpad2 :Deactive, Numpad3 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
walkmultiplier=1
if syntaxcheck then return end
if not walkdefault then walkdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')end
[ENABLE]
walkpmuti=createHotkey(function() walkmultiplier=walkmultiplier+0.5 end,VK_NUMPAD3)
walk = createTimer()
walk.setInterval(1000)
walk.OnTimer = function()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')
if address then writeFloat(address,walkdefault*walkmultiplier)end
end
[DISABLE]
walk.destroy()
walkpmuti.destroy()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')
if address then writeFloat(address,walkdefault)end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>99</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>98</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26132</ID>
                  <Description>"UWorld"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>GameViewportClient.World</Offset>
                    <Offset>GameEngine.GameViewport</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>26133</ID>
                  <Description>"Player"</Description>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>PlayerController.Character</Offset>
                    <Offset>LocalPlayer.PlayerController</Offset>
                    <Offset>0</Offset>
                    <Offset>GameInstance.LocalPlayers</Offset>
                    <Offset>GameEngine.GameInstance</Offset>
                  </Offsets>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26134</ID>
                      <Description>"CharacterMovement"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <GroupHeader>1</GroupHeader>
                      <Address>+GPlayer.CharacterMovement</Address>
                      <Offsets>
                        <Offset>0</Offset>
                      </Offsets>
                      <CheatEntries>
                        <CheatEntry>
                          <ID>26135</ID>
                          <Description>"JumpZVelocity"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.JumpZVelocity</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26136</ID>
                          <Description>"MaxWalkSpeed"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxWalkSpeed</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26137</ID>
                          <Description>"MaxWalkSpeedCrouched"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxWalkSpeedCrouched</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26138</ID>
                          <Description>"MaxAcceleration"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxAcceleration</Address>
                        </CheatEntry>
                      </CheatEntries>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>26139</ID>
              <Description>"Tools"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>26140</ID>
                  <Description>"FNamePool scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
function stringscan(value,modulename,stopaddress,isUnicode)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtString,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,isUnicode,true)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end



createThread(function()
print('------------------')
local isUnicode=true
local strlist,result,result2,result3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  result=stringscan('IntProperty',getAddressSafe(strlist[i]),getAddressSafe(strlist[i]..'+50'),isUnicode)
  if #result&gt;0 then
    result=stringscan('None',getAddressSafe(strlist[i]..'-50'),getAddressSafe(strlist[i]),isUnicode)
    print(strlist[i])
    if #result&gt;0 then
      if string.sub(strlist[i],strlist[i]:len()-3,strlist[i]:len()-2)=='00' then
        result=pointerscan(getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00'))
        for j=1,#result do
          print(strlist[i]..'&lt;-'..result[j])
          if string.sub(result[j],result[j]:len()-1,result[j]:len())=='00' then
            result2=pointerscan(getAddressSafe(result[j]))
            for k=1,#result2 do
              print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
              result3=pointerscan(getAddressSafe(result2[k]),getAddress(process),getAddress(process)+getModuleSize(process))
              for l=1,#result3 do print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l]) end
            end
          end
        end
      end
    end
  end
end
print('done')
end)
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26141</ID>
                  <Description>"DissectCode (Memory View -&gt; Ctrl+J or (Tools -&gt; Dissect code) )"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26142</ID>
                      <Description>"Save DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
getDissectCode().saveToFile(path)
--getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>26143</ID>
                      <Description>"Load DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
--getDissectCode().saveToFile(path)
getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>26144</ID>
          <Description>"Dumper V6"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>26145</ID>
              <Description>"Unreal Engine"</Description>
              <Options moHideChildren="1"/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
function ue4config()
 local sub=targetIs64Bit() and 0 or 4
 UObject = {}

 --if UE4ver&lt;=2 and targetIs64Bit() then ue4determineversion() end
-----------------------------
----------UE4 struct---------
 if UE4ver&gt;2 then

    UObject.ObjectId= 0xC-sub
    UObject.Class = 0x10-sub
    UObject.FNameIndex = 0x18-(sub*2)
    UObject.Outer = 0x20-(sub*2)

  if UE4ver&gt;=25 then
    UObject.super= 0x40
    UObject.member= 0x50
    UObject.nextmember= 0x20
    UObject.Offset= 0x4C
    UObject.propsize=0x3C
    UObject.bitmask= 0x7A
    UObject.funct= 0xD8
    UObject.Property= 0x78

  elseif UE4ver&gt;=22 then
    UObject.super= 0x40
    UObject.member= 0x48
    UObject.funct= 0xC0
  else
    UObject.super= 0x30 -(sub*4)
    UObject.member= 0x38 -(sub*5)
    UObject.funct= 0xB0
  end

  if UE4ver&lt;25 then
    UObject.nextmember=0x28-(sub*3)
    UObject.Offset= 0x44-(sub*4)
    UObject.propsize= 0x34-(sub*3/2)
    UObject.bitmask= 0x72-(sub*8)

    UObject.Property= 0x70-(sub*8)

  end

  if UE4ver&lt;11 then
    UObject.Offset= 0x4C
  end

----------------------------
---------UE3 struct---------
--1.25
--[[
 elseif UE4ver&gt;=1 then

    UObject.ObjectId= 0x4
    UObject.Outer = 0x14
    UObject.FNameIndex = 0x18
    UObject.Class = 0x20
    UObject.Offset= 0x48
    UObject.super= 0x34
    UObject.member= 0x38
    UObject.nextmember=0x28
    UObject.propsize= 0x30
    UObject.bitmask= 0x60
    UObject.Property= 0x58

]]
--0.10246
 else
 --[[
    UObject.ObjectId= 0x20
    UObject.Outer = 0x28
    UObject.FNameIndex = 0x2C
    UObject.Class = 0x34

    UObject.Offset= 0x60

    UObject.super= 0x48
    UObject.member= 0x4C

    UObject.nextmember=0x3C
    UObject.propsize= 0x44
    UObject.bitmask= 0x70]]

 end

---------------------------
end


ue4type={
		['BoolProperty']=vtByte,
		['ByteProperty']=vtByte,
		['FloatProperty']=vtSingle,
        ['StructProperty']=vtDword,
		['IntProperty']=vtDword,
        ['NameProperty']=vtQword,
        ['Int64Property']=vtQword,
		['TextProperty']=vtPointer,
        ['StrProperty']=vtPointer,
        ['ArrayProperty']=vtPointer,
        ['MapProperty']=vtPointer,
        ['ClassProperty']=vtPointer,
		['ObjectProperty']=vtPointer}

function ue4versioncheck()
 --if true then return 0 end
 local fileversion,info =getFileVersion(enumModules()[1].PathToFile)
 if not info then return 0 end
 return tonumber(info.minor..'.'..info.release)
end

function FNameStringAlgo(FName,IndexOnly)
 if not FName then return nil end
 local UEver=UE4ver
 local sub=targetIs64Bit() and 0 or 4
 local number,str,datatable
 if not IndexOnly then
   number=UEver&gt;2 and readInteger(FName+4) or 0
   FName=readInteger(FName)
 else number=FName&gt;&gt;32 FName=FName&amp;0xFFFFFFFF
 end


 if not FName then return nil end

 if isMassEffect then
   local i=(FName&gt;&gt;0x1D)&amp;7
   FName=FName&amp;0x1FFFFFFF
   --[[
   datatable={}
   for m=1,100 do
     datatable[m]=FNameDict[1+i][FName+m+stringoffset]
   end
   str= byteTableToString(datatable)]]
   str=readString(readPointer(getAddress('FNamePool')+i*8)+FName+stringoffset)
   return str
 end

 if FNameList[FName] then
   if number&gt;0 then return FNameList[FName]..'_'..number-1 end
   return FNameList[FName]
 end

 local CFName=FName

 if readPointer(FNameString) then
   if not FNameStringStub then FNameStringStub=createExecuteCodeExStub(0,FNameString,0,0)end
   if not FNameStringRE then FNameStringRE=createRemoteExecutor()end

   if not mem then mem=allocateMemory(0x100)end
   writeQword(mem+0x50+UObject.FNameIndex,FName)
   FNameStringRE.executeStub(FNameStringStub,{mem+0x50,mem})
   str=readPointer(mem)
   if str then str=readString(str,readInteger(mem+0x8)*2,true) end
   --deAlloc(mem)

 elseif UEver&gt;=23 then
  local i=(FName&gt;&gt;0x10)+1
  FName=(FName&amp;0xFFFF)*2
  if i&gt;#FNameDict or FName&gt;#FNameDict[i] then return nil end
  datatable={}
  for m=1,2 do
    datatable[m]=FNameDict[i][FName+m]
  end

  local le = byteTableToWord(datatable)
  if not le then return nil end
  le=le&gt;&gt;6
  if le&gt;200 then return nil end
  local widechar=true and FNameDict[i][FName+1]&amp;1==1 or false
  --print(FName)
  if CFName==3 and not stringoffset then
    for k=2,0x20,2 do
      datatable={}
      for m=1,le do
        datatable[m]=FNameDict[i][FName+k+m]
      end
      if byteTableToString(datatable)=='ByteProperty' then stringoffset=k break end
      --print(k)
    end
  end

  if not stringoffset then return end

  if widechar then
    datatable={}
    for m=1,le*2 do
      datatable[m]=FNameDict[i][FName+stringoffset+m]
    end
    str=byteTableToWideString(datatable)
  else
    datatable={}
    for m=1,le do
      datatable[m]=FNameDict[i][FName+stringoffset+m]
    end
    str=byteTableToString(datatable)
  end
 else
  local i

  if FNamePool2 then FName= FName &lt;0x25A and readInteger(FName*4+FNamePool) or FName

  --[[
  elseif UEver&gt;2 then
   i=(FName&gt;&gt;0xE)+1
   FName=(FName&amp;0x3FFF)*(8-sub)
  else i=1 FName=FName*(8-sub) end]]
  else
    i=UEver&gt;7 and (FName&gt;&gt;0xE)+1 or 1
    FName= (UEver&gt;7 and (FName&amp;0x3FFF) or FName) *  (8-sub)
  end

  if FNameDict and (i&gt;#FNameDict or ( FNameDict[i] and FName&gt;#FNameDict[i]) ) then return nil end

  local pointer
  if FNamePool2 then

    pointer=readPointer(FNamePool2)+FName

  elseif targetIs64Bit() then
    datatable={}
    for m=1,8 do
      datatable[m]=FNameDict[i][FName+m]
    end
    pointer=byteTableToQword(datatable)
  else
    datatable={}
    for m=1,4 do
      datatable[m]=FNameDict[i][FName+m]
    end
    pointer=byteTableToDword(datatable)
  end

  if not readPointer(pointer) then return nil end
  local pointers,pointers2=pointer
  if stringoffset2 then pointer=readPointer(pointer+stringoffset2)end
  pointers2=pointer

  --local offset=UE4ver&gt;=22 and 0xC-sub or 0x10-(sub*2)
  if CFName==1 and (not stringoffset or not stringoffsetid) then

     for k=0,0x30,4 do
        str=readString(pointer+k,13)
        if str=='ByteProperty' then stringoffset=k break end
      end

      if not stringoffset then
        for k=0,0x30,4 do
          str=readString(pointer+k,13*2,true)
          if str=='ByteProperty' then stringoffset=k forcewidechar=true break end
        end
      end

      pointer=pointers

     for j=0, stringoffset-4,4 do
       if readInteger(pointer+j)==2 then stringoffsetid=j end
     end
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
  --print(string.format('%X',offset))

  else
  if not stringoffset then return end
  --print(string.format('%X',pointer))

  pointer=pointers

  local widechar=stringoffsetid and (readInteger(pointer+stringoffsetid)&amp;1==1 or false) or false

  pointer=pointers2

  if stringoffset2 and not readPointer(pointer) then pointer=pointers+stringoffset2 end

  widechar= forcewidechar and true or widechar

  str= readString(pointer+stringoffset,200,widechar)

  if not str then str= readString(pointer+stringoffset,100,widechar) end
  if not str then str= readString(pointer+stringoffset,50,widechar) end
  if not str then str= readString(pointer+stringoffset,30,widechar) end
  if not str then
   local le=0
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
   while(true)do
    if le&gt;50 then break end
    if readBytes(pointer+stringoffset+le)==0 then break end
    le=le+1
   end
   str= readString(pointer+stringoffset,le)
  end
  --print(stringoffset)


 end end
 if not str then return nil end
 if number&gt;0 then return str..'_'..number-1 end
 --print(str)
 FNameList[CFName]=str
 --print(str)
 return str
end

function GetNameAlgo(object)
 if not object then return nil end
 if ObjectList[object] then --print(ObjectList[object])
   return ObjectList[object]
 end
 local fnameoffset=UObject.FNameIndex
 local typeoffset=UObject.Class
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 --print(string.format('%X',fnameoffset))
 --print(string.format('%X',object+fnameoffset))
 local str1=FNameStringAlgo(readInteger(pointer+fnameoffset),true)
 --if readInteger(pointer+fnameoffset+4)~=0 then return nil end

 local str2=FNameStringAlgo(object+fnameoffset)
 if not str2 then str2=FNameStringAlgo(object+fnameoffset-8)end
 if not str1 or str1=='None' or not str2 or str2=='None' then return nil end
 str1=str1..' '..str2
 --print(ObjectList[object])
 ObjectList[object]=str1
 return str1
end

function GetFullNameAlgo(object)
 if not object then return nil end
 --if ObjectList[object] then return ObjectList[object] end
 local pathoffset=UObject.Outer
 local fnameoffset=UObject.FNameIndex
 local str=GetNameAlgo(object)
 if not str then return nil end
 local number=readInteger(object+fnameoffset+4)
 local typ=str:sub(1,string.find(str,' ')-1)
 local isProperty=string.find(typ,'Property')
 if not isProperty then isProperty=string.find(typ,'Function') end
 local pointer=readPointer(object+pathoffset)
 while(true)do
  if not pointer or pointer==0 then break end
  local stri=GetNameAlgo(pointer)
  if not stri then break end
  typ=stri:sub(1,string.find(stri,' ')-1)
  local isPropertyc=string.find(typ,'Property')
  if not isPropertyc then isPropertyc=string.find(typ,'Function') end
  stri=string.sub(str,1,string.find(str,' '))..stri:sub(string.find(stri,' ')+1,stri:len())
  local num=readInteger(pointer+fnameoffset+4)

  if number~=num and num==0 or  not isPropertyc and isProperty then stri=stri..':'
  else stri=stri..'.' end
  number=num
  isProperty=isPropertyc

  str=stri..string.sub(str,string.find(str,' ')+1,str:len())
  pointer=readPointer(pointer+pathoffset)

  if string.find(str,'%./') then
    stri=string.sub(str,1,string.find(str,' '))
    str=stri..str:sub(string.find(str,'%./')+1,str:len())
  break end

 end
 if not str then return nil end
 --ObjectList[object]=str
 return str
end

function GetFullNameSuperAlgo(object)
  local super=UObject.super
  local str1 = GetFullNameSafeAlgo(object)
  if not str1 then return nil end
  local pointer = readPointer(object+super)
  if pointer then
    local str2 = GetFullNameSafeAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function GetFullNameSafesAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 local str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end


function GetFullNameSafeAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local str= GetFullNameAlgo(object)
 if str then return str end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str3 then str3=GetFullNameSafesAlgo(pointer)end

 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end

function FindString(namestr,start,stop,isNoIndex)
  local acclen=0
  for i=start,stop do
    local name=FNameStringAlgo(i+acclen,true)
    if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
      --print(name)
      if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
        if namestr==name then FNameResult=i+acclen return end
        if isNoIndex then acclen=acclen+name:len()end
      end
    end
  end
end


function FindStringFName(namestr,isNoIndex)
  local size
  if FNamePool2 then size=readInteger(FNamePool2+8)

  elseif UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
  elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
  else size=math.floor(#FNameDict[1]/4) end
  local count=0x200
  size=math.floor((size/count)+0.5)
  ue4parsetablecheck()
  FNameResult=nil
  local result
  local num,start,stop=count,0,0
  for i=0,size do
    start=i*num
    stop=(i+1)*num
    if FNameResult then break end
    createThread(FindString(namestr,start,stop-1,isNoIndex))
  end
  result=FNameResult
  FNameResult=nil
  return result
end

function hasProperty(object)
  local str1,str2
  str1=GetFullNameSafeAlgo(object)
  if not str1 then return nil end
  local pointer =readPointer(object+UObject.Property)
  if pointer then
    str2=GetFullNameSafeAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function printInheritC(class)
  for i=0,10 do
    if not class or class==0 then break end
    print(GetFullNameSuperAlgo(class))
    class=readPointer(class+UObject.super)
  end
end

function printInheritI(instance)
  instance=readPointer(instance+UObject.Class)
  printInheritC(instance)
end

function getregionsize(address)
local allregion=enumMemoryRegions()
 for i=#allregion,1,-1 do
  if allregion[i].BaseAddress&lt;=address then
   local BaseAddress=allregion[i].BaseAddress
   local RegionSize=allregion[i].RegionSize
   local curSize=BaseAddress+RegionSize-address
   return curSize,RegionSize,BaseAddress,i
  end
 end
end
--[[
function parsefrombig(tab,index,size)
 local datatable={}
 if not tab then return nil end
 for i=1,size do
  datatable[i]=tab[index+i]
 end
 return datatable
end
]]
sub=targetIs64Bit() and 0 or 4

function ue4parsetableFNamePool()
  BasicEnumObject_running=nil
  ObjectTable={}
  ObjectList={}
  FullNameList={}
  FNameList={}
  if readPointer(FNameString) or string.find(process,'StateOfDecay2')then return end
  local pool=getAddressSafe('FNamePool')
  if pool then
    local pointer,pointers
    if not readPointer(readPointer(pool)) then pointer=pool+0x10
    else
      pointer=pool
      if readPointer(readPointer(readPointer(pointer)))then
        if readPointer(readPointer(readPointer(readPointer(pointer))))then
          pointer=readPointer(pointer)
        end
      end
    end
    if not readPointer(pointer)then pointer=readPointer(pool2+0x10)end
    FNameDict={}
    local j=0
    for i=0,500 do
      pointers=readPointer(pointer+i*(8-sub))
      if readPointer(pointers) then
        FNameDict[i+1]=readBytes(pointers,getregionsize(pointers)-1,true)
      else j=j+1 end
      if j&gt;5 then break end
    --[[
     local pointer
     if UE4ver&gt;=23 then pointer=readPointer(pool+i*(8-sub)+0x10)
     elseif UE4ver&gt;2 then  pointer=readPointer(readPointer(pool)+i*(8-sub))
     else pointer=readPointer(pool+i*(8-sub)) end
     if pointer and pointer~=0 then
       local size=getregionsize(pointer)
       if not size or size==0 then break end
       FNameDict[i+1]=readBytes(pointer,size-1,true)
     else break
     end]]

    end
  end
end

function ue4parsetable()
 local size=targetIs64Bit() and 8 or 4
 ue4parsetableFNamePool()
 local pool2=getAddressSafe('GUObjectArray')
 if pool2 then
  GUObjectDict={}
  if NOGUObjectsize then GUObjectsize=0xFFFFFFFF GUObjectDict[1]=readBytes(pool2,getregionsize(pool2)-1,true) return end


  local pointer,pointers=readPointer(pool2)
  GUObjectsize=readInteger(pool2+size)
  if not readPointer(pointer)then GUObjectsize=readInteger(pool2+0x10+size*2) pointer=readPointer(pool2+0x10)end
  if not readPointer(readPointer(pointer)) then pointer=pointer+0x10 end


  --if GetFullNameSafeAlgo(readPointer(pointer)) then pointer=pool2 end
  if not readPointer(readPointer(readPointer(readPointer(readPointer(pointer))))) then pointer=pool2 end

  --[[
  local pointerss=readPointer(pointer)
  for i=size,0x50,4 do
    if readPointer(pointerss+i) and readPointer(readPointer(readPointer(pointerss+i))) then UObjectMul=i break end
  end
]]
  local j=0
  for i=0,500 do
    pointers=readPointer(pointer+i*(8-sub))
    if readPointer(pointers) then
      GUObjectDict[#GUObjectDict+1]=readBytes(pointers,getregionsize(pointers)-1,true)
    else j=j+1 end
    if j&gt;5 then break end
  end
--[[
  if not UObject then UObject={}end

  if not UObject.FNameIndex then
    local datatable
    for i=size,0x50,4 do
      datatable={}
      for m=1,size do datatable[m]=GUObjectDict[1][m+i]end
      pointer = targetIs64Bit() and byteTableToQword(datatable) or byteTableToDword(datatable)
      if readPointer(pointer) and readPointer(readPointer(readPointer(pointer))) then UObjectMul=i break end
    end
    for i=0,3 do
      datatable={}
      for m=1,size do datatable[m]=GUObjectDict[1][m+i*UObjectMul]end
      pointer = targetIs64Bit() and byteTableToQword(datatable) or byteTableToDword(datatable)
      if readPointer(pointer) and checkvalue(pointer+size,0x100,'Object',1) then
        UObject.FNameIndex=checkvalue(pointer+size,0x50,'Object',1)-pointer
        UObject.ObjectId=checkvalue(pointer+size,0x100,i,4)-pointer
        for j=size,0x100,4 do
          if checkvalue(readPointer(pointer+j),0x100,'Class',1) then UObject.Class=j break end
        end
        for j=size,0x100,4 do
          if checkvalue(readPointer(pointer+j),0x100,'Core',1) then UObject.Outer=j break end
        end
        break
      end
    end
  end
]]
 end
end


function ue4parsetablecheck()
 if not FNameDict or not GUObjectDict then ue4parsetable()
 else
 local pointer,pointei,datatable,m
 if targetIs64Bit() then
   datatable={}
   for m=1,8 do datatable[m]=GUObjectDict[1][m]end
   pointer=byteTableToQword(datatable)
 else
   datatable={}
   for m=1,4 do datatable[m]=GUObjectDict[1][m]end
   pointer=byteTableToDword(datatable)
 end
 if UE4ver&gt;=20 then pointei=readPointer('[[GUObjectArray+10]]')
 elseif UE4ver&gt;11 then pointei=readPointer('[GUObjectArray+10]')
 elseif UE4ver&gt;2 then pointei=readPointer('[[GUObjectArray]+10]')
 else pointei=readPointer('[GUObjectArray]') end
 --print(string.format('%X',pointei))
 --print(string.format('%X',pointer))
 if pointei ~= pointer then ue4parsetable() end
 local GUObjectsizes
 if UE4ver&gt;=20 then GUObjectsizes=readInteger(getAddress('GUObjectArray+24')-(sub*2))
 elseif UE4ver&gt;11 then GUObjectsizes=readInteger('GUObjectArray+1C')
 else GUObjectsizes=readInteger(getAddress('GUObjectArray+8')-(sub*2)) end
 if GUObjectsizes~=GUObjectsize then ue4parsetable() end
 end
end

function UE4AutoConfig()

if not UObject then UObject = {} end
local size,pointer,pointers=(targetIs64Bit() and 8 or 4)
local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
local GameEngine=StaticFindObjectAlgo('/Script/Engine.GameEngine')
local Engine=StaticFindObjectAlgo('/Script/Engine.Engine')
print(string.format('GameEngine = %X',GameEngine))
print(string.format('Engine = %X\n',Engine))
UObject.super=checkvalue(GameEngine,0x100,Engine,size)-GameEngine
local Name,Typ
for i=GameEngine,GameEngine+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Property ') then pointer=readPointer(i) UObject.member=i-GameEngine break end
end
Typ=Name:sub(1,string.find(Name,' ')-1)

UObject.propsize=checkvalue(pointer,0x100,varsize[ue4type[Typ]],4)-pointer
local classsize=readInteger(UObject.member+size+GameEngine)
UObject.Offset=checkvalue(pointer,0x100,tostring(classsize-0x100)..'~'..tostring(classsize),4)-pointer

for i=pointer,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Property ') then UObject.nextmember=i-pointer break end
end

pointer=readPointer(Engine+UObject.member)
for i=pointer+UObject.nextmember,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Class ') then UObject.Property=i-pointer break end
end

UObject.bitmask=UObject.Property+2

pointer=StaticFindObjectAlgo('/Script/CoreUObject.Object:ExecuteUbergraph')
print(string.format('ExecuteUbergraph = %X\n',pointer))

for i=pointer+UObject.Property,pointer+0x100,size do
  if inModule(readPointer(i)) then UObject.funct=i-pointer break end
end

pointer=StaticFindObjectAlgo('/Script/CoreUObject.EInterpCurveMode')
print(string.format('EInterpCurveMode = %X\n',pointer))
for j=size,0x50,size do
  pointers=readPointer(pointer+UObject.Outer+j)
      --pointers=readPointer(pointers)
  if pointers and checkvalue(pointers,0x50,'CIM_Linear',1) then
    UObject.enumoffset=UObject.Outer+j
    pointer=readPointer(pointer+UObject.enumoffset)
    print(string.format('EInterpCurveMode enums = %X\n',pointer))
    UObject.enumname=checkvalue(pointer,0x50,'CIM_Linear',1)-pointer
    UObject.enumindex=checkvalue(pointer,0x50,1,2) and checkvalue(pointer,0x50,1,2)-checkvalue(pointer,0x50,'CIM_CurveAuto',1) or 4
    for k=UObject.enumname+8,0x50,4 do
      if readInteger(pointer+k)&gt;4 and FNameStringAlgo(readInteger(pointer+k),true) then UObject.enummul=k break end
    end

    break
  end
end

print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
UObject.funct = 0x%X
UObject.enumoffset = 0x%X
UObject.enummul = 0x%X
UObject.enumname = 0x%X
UObject.enumindex = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask,UObject.funct,UObject.enumoffset,
UObject.enummul,UObject.enumname,
UObject.enumindex))

end

function UE3AutoConfig()

if not UObject then UObject = {} end
local size,pointer,pointers=(targetIs64Bit() and 8 or 4)
local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
local GameEngine=StaticFindObjectAlgo('Engine.GameEngine')
local Engine=StaticFindObjectAlgo('Engine.Engine')
print(string.format('GameEngine = %X',GameEngine))
print(string.format('Engine = %X\n',Engine))
UObject.super=checkvalue(GameEngine,0x100,Engine,size)-GameEngine
local Name,Typ
for i=GameEngine+UObject.Outer,GameEngine+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and (string.find(Name,'Function ') or string.find(Name,'Property ')) then pointer=readPointer(i) UObject.member=i-GameEngine break end
end

for i=UObject.Outer+size,0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(pointer+i))
  if Name and  (string.find(Name,'Property ') or string.find(Name,'Function ') or string.find(Name,'Struct ')) and not string.find(Name,'Core') then
    Name=GetFullNameSafeAlgo(readPointer(readPointer(pointer+i)+i))
      if Name and  (string.find(Name,'Property ') or string.find(Name,'Function ') or string.find(Name,'Struct ')) and not string.find(Name,'Core') then
        UObject.nextmember=i break
      end
  end
end

for i=0,100 do
  pointer=readPointer(UObject.nextmember+pointer)
  Name=GetFullNameSafeAlgo(pointer)
  --print(Name)
  if Name and string.find(Name,'ObjectProperty ') then break end
end

Typ=Name:sub(1,string.find(Name,' ')-1)
--print(string.format('%X = %s',pointer,GetFullNameSafeAlgo(pointer)))

UObject.propsize=checkvalue(pointer,0x100,varsize[ue4type[Typ]],2)-pointer
local classsize=readInteger(UObject.member+size+GameEngine)

UObject.Offset=checkvalue(pointer,0x100,tostring(classsize-0x200)..'~'..tostring(classsize),4)-pointer


--pointer=readPointer(Engine+UObject.member)
for i=pointer+UObject.nextmember,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Class ') then UObject.Property=i-pointer break end
end

UObject.bitmask=UObject.Property+2

pointer=StaticFindObjectAlgo('Core.Object:FindObject')
print(string.format('FindObject = %X\n',pointer))
for i=pointer+UObject.ObjectId,pointer+0x100,4 do
  if inModule(readPointer(i)) then UObject.funct=i-pointer break end
end

pointer=StaticFindObjectAlgo('Core.Object.EInterpCurveMode')
print(string.format('EInterpCurveMode = %X\n',pointer))
for i=size,0x50,size do
  pointers=readPointer(pointer+UObject.Outer+i)
  pointers=readPointer(pointers)
  if pointers then
    for j=size,0x50,size do
      pointers=readPointer(pointer+UObject.Outer+i+j)
      --pointers=readPointer(pointers)
      if pointers and checkvalue(pointers,0x50,'CIM_Linear',1) then
        UObject.enumoffset=UObject.Outer+i+j
        pointer=readPointer(pointer+UObject.enumoffset)
        UObject.enumname=0--checkvalue(pointer,0x50,FindStringFName('CIM_Linear'),4)-pointer
        UObject.enumindex=4--checkvalue(pointer,0x50,1,4)-checkvalue(pointer,0x50,FindStringFName('CIM_CurveAuto'),4)
        UObject.enummul=8--checkvalue(pointer,0x50,2,4)-checkvalue(pointer,0x50,1,4)
        break
      end
    end
    break
  end
end


print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
UObject.funct = 0x%X
UObject.enumoffset = 0x%X
UObject.enummul = 0x%X
UObject.enumname = 0x%X
UObject.enumindex = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask,UObject.funct,UObject.enumoffset,
UObject.enummul,UObject.enumname,
UObject.enumindex))

end


function FindObject(threadlist,ObjectId,size,i,start,stop,fullname)
  local pointer,datatable
  for j=start,stop do

    if UObjectMul then
      if targetIs64Bit() then
        datatable={}
        for m=1,8 do
          if not GUObjectDict[i][j*UObjectMul+m] then break end
          datatable[m]=GUObjectDict[i][j*UObjectMul+m]
        end
        pointer=byteTableToQword(datatable)
      else
        datatable={}
        for m=1,4 do
          if not GUObjectDict[i][j*0x4+m] then break end
          datatable[m]=GUObjectDict[i][j*0x4+m]
        end
        pointer=byteTableToDword(datatable)
      end
    elseif UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x8+m] then break end
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x4+m] then break end
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x18+m] then break end
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x10+m] then break end
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end

    if pointer and pointer~=0 then
      local objid=readInteger(pointer+ObjectId)
      if objid and objid&lt;size then
        local name=GetFullNameSafeAlgo(pointer)
        if name and string.find(name,' ') then
          name=string.sub(name,string.find(name,' ')+1,name:len())
          name=name:lower()
          if not FullNameList[name]then FullNameList[name]=pointer end
          if FullNameList[fullname] then
            ObjectResult=FullNameList[fullname]
            for k,v in ipairs(threadlist) do v.terminate() end
            return
          end
        end
      end
    end
  end
end

function StaticFindObjectAlgo(fullname)
 ue4parsetablecheck()
 fullname=fullname:lower()
 if FullNameList[fullname] then return FullNameList[fullname]end
 local threadlist={}
 local k=1
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;10 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local ObjectId=UObject.ObjectId
 ObjectResult=nil
 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess) do
    start=stop
    stop=stop+num
    if ObjectResult then break end
    threadlist[k]=createThread(FindObject(threadlist,ObjectId,size,i,start,stop-1,fullname))
    k=k+1
  end
 end
 local result=ObjectResult
 ObjectResult=nil
 return result
end

function BasicObject(ObjectId,size,i,start,stop)
  local pointer,datatablen,name,ObjectData,objid
  Threadlist[#Threadlist+1]=i
  for j=start,stop do
    if UObjectMul then
      if targetIs64Bit() then
        datatable={}
        for m=1,8 do
          if not GUObjectDict[i][j*UObjectMul+m] then break end
          datatable[m]=GUObjectDict[i][j*UObjectMul+m]
        end
        pointer=byteTableToQword(datatable)
      else
        datatable={}
        for m=1,4 do
          if not GUObjectDict[i][j*0x4+m] then break end
          datatable[m]=GUObjectDict[i][j*0x4+m]
        end
        pointer=byteTableToDword(datatable)
      end
    elseif UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x8+m] then break end
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x4+m] then break end
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x18+m] then break end
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x10+m] then break end
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end
    if pointer and pointer~=0 then
      objid=readInteger(pointer+ObjectId)
      if objid and objid&lt;size and not Temporary[pointer] then
        name=GetFullNameSafeAlgo(pointer)
        if name and string.find(name,' ') then
          ObjectData={}
          ObjectData.ObjId=objid
          ObjectData.Address=pointer
          ObjectData.Type=string.sub(name,1,string.find(name,' ')-1)
          ObjectData.FullName=string.sub(name,string.find(name,' ')+1,name:len())
          ObjectData.Super=UObject.super and readPointer(pointer+UObject.super) or nil
          if not readPointer(ObjectData.Super) then ObjectData.Super=nil end
          ObjectTable[#ObjectTable+1]=ObjectData
          Temporary[pointer]=ObjectData
        end
      end
    end
  end
  Threadlist[#Threadlist]=nil
end


function BasicEnumObject()
  if BasicEnumObject_running then return end
  BasicEnumObject_running=true
  ObjectTable={}
  ue4parsetablecheck()
  local count=0x200
  local size=GUObjectsize
  local sizess= targetIs64Bit() and (UE4ver&gt;10 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
  local ObjectId=UObject.ObjectId
  local num,start,stop
  Temporary={}
  Threadlist={}
  local LastStop
  for i=1,#GUObjectDict do
    num,start,stop=count,0,0
    for j=0,math.floor(#GUObjectDict[i]/sizess) do
      start=stop
      stop=stop+num
      --print(start..'~'..stop)
      createThread(BasicObject(ObjectId,size,i,start,stop-1))
      if i==#GUObjectDict and j==math.floor(#GUObjectDict[i]/sizess) then LastStop=stop end
    end
  end
  for i=0,10000 do
    if #Threadlist==0 then break end
    sleep(1)
  end
  for i=1,#ObjectTable do
    if Temporary[ObjectTable[i].Super] then
      if not Temporary[ObjectTable[i].Super].Uper then Temporary[ObjectTable[i].Super].Uper={}end
      Temporary[ObjectTable[i].Super].Uper[#Temporary[ObjectTable[i].Super].Uper+1]=ObjectTable[i]
      ObjectTable[i].Super=Temporary[ObjectTable[i].Super]
    end
  end
  BasicEnumObject_running=nil
  Temporary=nil
  Threadlist=nil


  --print('done')
end



function registerFunc(ObjectId,size,i,start,stop)
  local funct=UObject.funct
  for j=start,stop do
    local pointer

    if UObjectMul then
      if targetIs64Bit() then
        datatable={}
        for m=1,8 do
          if not GUObjectDict[i][j*UObjectMul+m] then break end
          datatable[m]=GUObjectDict[i][j*UObjectMul+m]
        end
        pointer=byteTableToQword(datatable)
      else
        datatable={}
        for m=1,4 do
          if not GUObjectDict[i][j*0x4+m] then break end
          datatable[m]=GUObjectDict[i][j*0x4+m]
        end
        pointer=byteTableToDword(datatable)
      end
    elseif UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x8+m] then break end
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x4+m] then break end
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x18+m] then break end
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x10+m] then break end
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end

    if pointer and pointer~=0 then
      local objid=readInteger(pointer+ObjectId)
      if objid and objid&lt;size then
        local name=GetFullNameSafeAlgo(pointer)
        if name and string.find(name,' ') then
          local typ=string.sub(name,1,string.find(name,' ')-1)
          if typ=='Function' then
            local fullname=string.sub(name,string.find(name,' ')+1,name:len())
            local func=readPointer(pointer+funct)
            if func and func~=0 then extralist.addSymbol('UE',fullname,func,1)end
          end
        end
      end
    end
  end
end

function registerFuncAlgo()
 local funct=UObject.funct
 ue4parsetablecheck()
 if not extralist then
   extralist=createSymbolList()
   extralist.register()
 end
 if not enumUEObjIsRunning and UEObj then
   for i,v in ipairs(UEObj) do
     if v.Type=='Function' then
       local func=readPointer(v.Address+funct)
       if func and func~=0 then extralist.addSymbol('UE',v.FullName,func,1)end
     end
   end
 else
   local k=1
   local count=0x200
   local size=GUObjectsize
   local sizess= UE4ver&gt;2 and (targetIs64Bit() and 0x18*count or 0x10*count) or 0x4*count
   local ObjectId=UObject.ObjectId
   for i=1,#GUObjectDict do
    local num,start,stop=count,0,0
    for j=0,math.floor(#GUObjectDict[i]/sizess) do
      start=stop
      stop=stop+num
      if ObjectResult then break end
      createThread(registerFunc(ObjectId,size,i,start,stop-1))
      k=k+1
    end
   end
 end
end

function isStructExist(name)
  for i=1,#StructList do
    if StructList[i].Name==name then return StructList[i] end
  end
  return nil
end

function SaveAndRemoveStruct()
  StructList={}
  local count=getStructureCount()
  for i=count-1,0,-1 do
    local struct=getStructure(i)
    StructList[i+1]=struct
    struct:removeFromGlobalStructureList()
  end
end

function DeleteStruct(Struct)
  local count=#StructList
  for i=1,count do
    if Struct==StructList[i] then
      Struct:Destroy()
      StructList[i]=nil
    end
    if not StructList[i] and StructList[i+1] then
      StructList[i]=StructList[i+1]
      StructList[i+1]=nil
    end
  end
end

function LoadStruct()
  for i=1,#StructList do
    StructList[i]:addToGlobalStructureList()
  end
end

function ChildStructStart(structname,elementname)
local struct=isStructExist(structname)
if struct then
for i=0,struct.Count-1 do
if struct.Element[i].Name==elementname then return struct.Element[i].ChildStructStart end end
else return nil end
end

function findAddress(name,number,AddressOrAOBString,modulename,stopaddress,Nth,aobscanOnly,gethead,nop)
	local size,address=0x100
    AddressOrAOBString,address=string.lower(AddressOrAOBString):gsub('banana','')
	if(address&gt;0)then
		local f
		if(modulename==0 or modulename==nil or modulename=='')then f=AOBScan(AddressOrAOBString)
		else
            if type(modulename)==type(0) then modulename=string.format('%X',modulename)
            elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
			local ms = createMemScan()
			if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
				stopaddress=getNameFromAddress(getAddress(modulename),true,false)
                if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
				if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
                modulename=getAddress([["]]..stopaddress..[["]])
				stopaddress=modulename+getModuleSize(stopaddress)
                modulename=string.format('%X',modulename)
			end
			ms.firstScan(soExactValue,vtByteArray,rtTruncated,AddressOrAOBString,'',getAddress(modulename),getAddress(stopaddress),'',fsmNotAligned,'',true,false,false,false)
			ms.waitTillDone()
			f = createFoundList(ms)
			f.initialize()
			ms.destroy()
		end
		address={}
		for i=0,f.Count-1 do address[i+1]=f[i]end
		f.destroy()
        if Nth==nil or Nth==0 or Nth=='' then Nth=1 end
        if gethead then
           local addresss=GetAddressSafe(address[Nth])
           if not addresss then addresss=GetAddressSafe(address[Nth-1])end
           if addresss and addresss~=0 then
           for i=0,0x1000 do
               addresss=addresss-1
               if readBytes(addresss,1)==0xCC then break end
               if nop then local ext, opc, byt, add=splitDisassembledString(disassemble(addresss)) if string.find(opc,'nop') then addresss=addresss+getInstructionSize(addresss)-1 break end end
           end
           address[Nth]=addresss+1 end
        end
		if number==nil or number==0 or number=='' then
			if aobscanOnly then return address end
		else
            if(#address==0)then error(name..' aob no result found') end
            if(getAddress(address[Nth])==nil)then error(name..' aob result '..Nth..' doesnt exist') end
            unregisterSymbol(name)
            registerSymbol(name,getAddressSafe(address[Nth]),true)
            if aobscanOnly then return end
		end
		AddressOrAOBString=GetAddressSafe(address[Nth])
	end
    AddressOrAOBString=getAddressSafe(AddressOrAOBString)
	if(AddressOrAOBString==nil)then error(name..' still cant be found')end
	local addr={}
	local i=0
	local j=1
	while(i&lt;size) do
		local ext, opc, byt, add=splitDisassembledString(disassemble(getAddressSafe(AddressOrAOBString)+i))
		if(ext~="")then
			if(opc:find(",")~=nil)then
				opc=opc:sub(opc:find(",")+1,opc:len())
			else
				opc=opc:sub(opc:find(" ")+1,opc:len())
			end
			addr[j]=opc:gsub("%[",""):gsub("]","") j=j+1
		end
        if opc:find('],') then
            opc=opc:sub(opc:find("%[")+1,opc:find("]")-1)
            if tonumber(opc,16) then addr[j]=opc j=j+1 end
        end
		i=i+getInstructionSize(AddressOrAOBString+i)
	end
    --for i=1,#addr do print(addr[i]) end
	if number==nil or number==0 or number=='' then return addr end
	local offset
	if(type(number)==type(''))then
		offset=string.find(number,',')
		if(offset==nil)then number=getAddress(number)
		else offset=getAddress(string.sub(number,offset+1,number:len()))
			number=getAddress(string.sub(number,1,string.find(number,',')-1))
		end
	end
	if offset==nil then offset=0 end
	unregisterSymbol(name)
	registerSymbol(name,getAddressSafe(addr[number])-offset,true)
end

function ue4determineversion()
 local address=findAddress('FNamePool',0,'48 8D 0D *  *  *  *  E8 *  *  *  * 4C 8B C0 C6banana',process,nil,0,true)[1]
 if address then findAddress('FNamePool',1,address) UE4ver=25 ue4parsetable() ue4config()
  local address=getAddressSafe(StaticFindObjectAlgo('/Script/Engine.GameEngine'))
  if not address or address==0 then error('StaticFindObject not functioning as expected...')end
  UE4ver=nil
  local pointer=readPointer(address+UObject.member)
  if pointer then pointer=readPointer(pointer) if pointer then UE4ver=25 end end
  if not UE4ver then UE4ver=23 end
 else
  address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[1]
  if address then findAddress('FNamePool',1,address)
  else findAddress('FNamePool',1,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20banana',process,nil,2)end
  local address=readPointer('[[GUObjectArray+10]]+18')
  if address&gt;0x10000 then
   UE4ver=22
   ue4parsetable()
   ue4config()
   FNameStringAlgo(1,true)
   local address=getAddressSafe(StaticFindObjectAlgo('/Script/Engine.GameEngine'))
   if not address or address==0 then error('StaticFindObject not functioning as expected...')end
   UE4ver=nil
   local pointer=readPointer(address+UObject.member)
   if pointer then pointer=readPointer(pointer) if pointer then UE4ver=22 end end
   if not UE4ver then UE4ver=20 end
  else UE4ver=18 end
 end
end

function checkvalue(address,size,value,typ)
  local cvalue,tempvalue,value2=readBytes(address,size,true)

  if type(value)==type('') and string.find(value,'~') then
    value2=tonumber(value:sub(string.find(value,'~')+1,value:len()))
    value=tonumber(value:sub(1,string.find(value,'~')-1))
  end

  if not cvalue then return false end
  if typ==1 then
    for i=1,#cvalue,4 do
      datatable={}
      for m=1,4 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToDword(datatable)
      --print(FNameStringAlgo(tempvalue,true))
      local str=FNameStringAlgo(tempvalue,true)

      if str and string.find(str,value) then return address+i-1 end
    end

  elseif typ==2 then
    for i=1,#cvalue,2 do
      datatable={}
      for m=1,2 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToWord(datatable)
      if tempvalue==value or (value2 and tempvalue&gt;=value and tempvalue&lt;=value2 ) then return address+i-1 end
    end
  elseif typ==4 then
    for i=1,#cvalue,4 do
      datatable={}
      for m=1,4 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToDword(datatable)
      if tempvalue==value or (value2 and tempvalue&gt;=value and tempvalue&lt;=value2 ) then return address+i-1 end
    end
  elseif typ==8 then
    for i=1,#cvalue,4 do
      datatable={}
      for m=1,8 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToQword(datatable)
      if tempvalue==value or (value2 and tempvalue&gt;=value and tempvalue&lt;=value2 ) then return address+i-1 end
    end
  end
  return nil
end

function fillstruct4bytes(Struct)
  if not getElementByOffset(Struct,0) then local e=Struct.addElement() e.Offset=0 e.Vartype=vtDword end
  Struct.beginUpdate()
  local count=Struct.Count-1
  local list,k,element1,element2,size,bytesize={},1
  for i=0,count do
    element1=Struct.Element[i]
    element2=Struct.Element[i+1]
    if element2 then
      bytesize=element1.Bytesize
      if bytesize&lt;4 then bytesize=4 end
      size=element2.Offset-element1.Offset-bytesize
      if size&gt;0 then
        if size%4&gt;0 then size=4-size%4+size end
        local start=element1.Offset
        if start%4&gt;0 then start=4-start%4+start
        else start=start+4 end
        size=size/4
        for j=0,size-1 do
          if (start+j*4)&gt;=(element1.Offset+bytesize) then
            list[k]=start+j*4
            k=k+1
          end
        end
      end
    end
  end
  for i,v in ipairs(list) do local e=Struct.addElement() e.Offset=v e.Vartype=vtDword end
  Struct.endUpdate()
end

function ue4createstruct(FullNameOrAddress,StructName,isGlobal,isfullname,Structu,AddedOffset,AddedName,Instance)
  if not FullNameOrAddress then return
  elseif type(FullNameOrAddress)==type({})then
    RunningStructCounter=0
    SaveAndRemoveStruct()
    for i=1,#FullNameOrAddress do
      createThread(ue4createstruct(FullNameOrAddress[i],StructName[i],isGlobal,isfullname,Structu,AddedOffset,AddedName,Instance))
    end

    while(true)do
      if not RunningStruct or #RunningStruct==0 then break
      else sleep(1)end
      RunningStructCounter=RunningStructCounter+1
      if RunningStructCounter&gt;180000 then break end
    end
    RunningStructCounter=nil
    LoadStruct()
    return
  end
  if StructName and isGlobal then local Struct=isStructExist(StructName) if Struct then return end end--DeleteStruct(Struct)end end

  local member,Offset,Property,bitmask,nextmember,super,propsize=UObject.member,UObject.Offset,UObject.Property,UObject.bitmask,UObject.nextmember,UObject.super,UObject.propsize
  local Object,Name,Class,PropName,Typ,Off,pointer,e,f=FullNameOrAddress
  local isUE425=UE4ver&gt;=25
  if type(FullNameOrAddress)==type('') then Object=StaticFindObjectAlgo(FullNameOrAddress) end
  if not Object then print(FullNameOrAddress..' not found...') return end
  Name=GetNameAlgo(Object)
  if not Name or not string.find(Name,' ') then print(FullNameOrAddress..' invalid Object?') return end
  if not StructName then
    Class=Name:sub(1,string.find(Name,' ')-1)
    Name=Name:sub(string.find(Name,' ')+1,Name:len())
  else Name=StructName end

  local Struct=Structu
  if not Struct then Struct=createStructure(Name)end

  if not AddedName then AddedName='' end
  local RunningStructName=name
  if not AddedOffset then
    if not RunningStruct then RunningStruct={} end
    RunningStruct[#RunningStruct+1]=RunningStructName

    AddedOffset=0 Struct.beginUpdate()
  else
    local FullName=GetFullNameSafeAlgo(Object)
    FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())

    if not LocalStruct then LocalStruct={}end
    if LocalStruct[FullName] then copyStruct(LocalStruct[FullName],Struct,AddedOffset,AddedName)
    else
      local copy=createStructure(FullName)
      ue4createstruct(Object,nil,nil,isfullname,copy)
      LocalStruct[FullName]=copy
      copyStruct(LocalStruct[FullName],Struct,AddedOffset,AddedName)
    end
    return
  end
  --if not RunningStructCounter and AddedName=='' then SaveAndRemoveStruct() end

  --print(string.format('%X',Object))
  while(true)do
    if not Object or Object==0 then break end
    Name=GetNameAlgo(Object)
    if not Name then break end
    Name=Name:sub(string.find(Name,' ')+1,Name:len())
    if Name=='Object' then break end
    print(GetFullNameSafeAlgo(Object))
    pointer=readPointer(Object+UObject.member)
    while(true)do
      if not pointer or pointer==0 then break end
      PropName=GetFullNameSafeAlgo(pointer)
      if PropName and string.find(PropName,':') then
        Typ=PropName:sub(1,string.find(PropName,' ')-1)
        if not string.find(Typ,'Function')then
          if not isfullname then PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())
          else PropName=PropName:sub(string.find(PropName,' ')+1,PropName:len())end
          PropName=AddedName..PropName
          Off=readInteger(pointer+Offset)+AddedOffset
          if Class=='UserDefinedStruct' and string.find(PropName,'_') then PropName=PropName:sub(1,string.find(PropName,'_')-1)end
          if Typ=='StructProperty' then
            ue4createstruct(readPointer(pointer+Property),nil,nil,isfullname,Struct,Off,PropName..'.')
            if not getElementByOffset(Struct,Off) then e=Struct.addElement() e.Offset=Off e.Name=PropName e.Vartype=vtDword end
          else
            e=Struct.addElement()
            e.Offset=Off
            e.Name=PropName
            if Instance and PropName=='RowStruct' then
              local spointer=readPointer(Instance+Off)
              local sname,sstruct=GetFullNameSafeAlgo(spointer)
              if sname then
                print(sname)
                if string.find(sname,'.') then sname=sname:sub(string.find(sname,'.')+1,sname:len())end

                if not ArrayStruct then ArrayStruct={} end
                if ArrayStruct[sname] then sstruct=ArrayStruct[PropName]
                else
                  sstruct=createStructure(sname)
                  ArrayStruct[sname]=sstruct
                  ue4createstruct(spointer,nil,nil,isfullname,sstruct)
                end

                f=Struct.addElement() f.Offset=e.Offset+8-sub f.Name='Table' f.Vartype=vtPointer
                local ssstruct=createStructure('DataTable')
                f.setChildStruct(ssstruct)

                for r=0,10 do
                  f=ssstruct.addElement() f.Offset=r*0x18 f.Name=string.format('[%u] FName',r)  f.Vartype=vtQword
                  f=ssstruct.addElement() f.Offset=r*0x18+8 f.Name=string.format('[%u] Data',r) f.Vartype=vtPointer
                  f.setChildStruct(sstruct)
                end
                fillstruct4bytes(ssstruct)

                f=Struct.addElement() f.Offset=e.Offset+0x10-sub*2 f.Name='Size' f.Vartype=vtDword
              end
            end
            if not ue4type[Typ] then e.Vartype=vtDword
            else e.Vartype=ue4type[Typ]end
            if Typ=='ArrayProperty' or Typ=='MapProperty' then
              f=Struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=Struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
              local isMap= Typ=='MapProperty'

              Prop=readPointer(pointer+Property)
              PropName=GetFullNameSafeAlgo(Prop)
              if not PropName then PropName=GetFullNameSafeAlgo(Prop)end
              if PropName then
                Typ=PropName:sub(1,string.find(PropName,' ')-1)
                PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())
                if string.find(PropName,':') then PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())end
                if Typ=='StructProperty' then
                  Prop=readPointer(Prop+Property)
                  PropName=GetNameAlgo(Prop)
                  if PropName then
                    PropName=PropName:sub(string.find(PropName,' ')+1,PropName:len())..'[]'
                    --print(Typ..' '..PropName)
                  end
                else PropName=PropName..'[]' end
                if not ArrayStruct then ArrayStruct={} end
                if ArrayStruct[PropName] then e.setChildStruct(ArrayStruct[PropName])
                else
                  local stru=createStructure(PropName)
                  ArrayStruct[PropName]=stru
                  e.setChildStruct(stru)

                  stru.beginUpdate()
                  local ppsize=0
                  if isMap then
                    for j=0,1 do
                      Prop=readPointer(pointer+Property+j*(8-sub))
                      PropName=GetFullNameSafeAlgo(Prop)
                      if PropName then
                        ppsize=(readInteger(Prop+propsize)&lt;4 and 4 or readInteger(Prop+propsize))+ppsize
                      end
                    end
                    ppsize=ppsize+0x8
                    --print(ppsize)
                  end

                  for j=0,1 do
                    Prop=readPointer(pointer+Property+j*(8-sub))
                    PropName=GetFullNameSafeAlgo(Prop)
                    if PropName then
                      Typ=PropName:sub(1,string.find(PropName,' ')-1)
                      --if Typ=='StructProperty' then print(PropName)end
                      PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())
                      if string.find(PropName,':') then PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())end

                      local psize=isMap and ppsize or readInteger(Prop+propsize)
                      local Offs=isMap and readInteger(Prop+Offset) or 0
                      local Propt
                      if Typ=='StructProperty' then
                        Propt=readPointer(Prop+Property)
                      end
                      for p=0,10 do
                        Off=p*psize+Offs
                        local ItemName=string.format('[%u] ',p)
                        if Typ=='StructProperty' then
                          ue4createstruct(Propt,nil,nil,isfullname,stru,Off,ItemName)
                          --if not getElementByOffset(stru,Off) then e=stru.addElement() e.Offset=Off e.Name=PropName e.Vartype=vtDword end
                        else
                          local g=stru.addElement()
                          g.Offset=Off
                          g.Name=ItemName..PropName
                          if not ue4type[Typ] then g.Vartype=vtDword
                          else g.Vartype=ue4type[Typ]end
                        end
                      end
                    end
                  end
                  stru.endUpdate()
                  fillstruct4bytes(stru)
                end
              end
            elseif Typ=='BoolProperty' then e.ChildStructStart=readBytes(pointer+bitmask,1)end
          end
        end
      end
      pointer=readPointer(pointer+nextmember)
    end
    Object=readPointer(Object+super)
  end

  if AddedName~='' then return end


  Struct.endUpdate()
  fillstruct4bytes(Struct)
  if isGlobal then StructList[#StructList+1]=Struct end

  local count=#RunningStruct
  for i=1,count do
    if RunningStruct[i]==RunningStructName then RunningStruct[i]=nil end
    if not RunningStruct[i] and RunningStruct[i+1] then RunningStruct[i]=RunningStruct[i+1] RunningStruct[i+1]=nil end
  end
  if not RunningStructCounter then LoadStruct() end

end

function getElementByOffset(struct,offset)
  for i=0,struct.Count-1 do
    if struct.Element[i].Offset==offset then return i end
  end
  return nil
end

function copyStruct(original,copy,AddedOffset,AddedName)
  if not copy then copy=createStructure(original.Name..'_copy')end
  if not AddedOffset then AddedOffset=0 end
  if not AddedName then AddedName='' end
  copy.beginUpdate()
  for i=0,original.Count-1 do
    local e=copy.addElement()
    e.Offset=original.Element[i].Offset+AddedOffset
    if original.Element[i].Name=='' then e.Name=original.Element[i].Name
    else e.Name=AddedName..original.Element[i].Name end
    e.Vartype=original.Element[i].Vartype
    e.ChildStruct=original.Element[i].ChildStruct
    e.ChildStructStart=original.Element[i].ChildStructStart
    e.Bytesize=original.Element[i].Bytesize
  end
  copy.endUpdate()
  return copy
end

function ue4createstructfast(fullnameortable,StructName,isGlobal,isfullname,structu,AddedOffset,AddedName,depth,callernum)
  if not callernum then callernum=0 end
  if not depth then depth=10 end
  local depths=0
  callernum=callernum+1
  if callernum&gt;10 then return end
  if StructName and isGlobal then local struct=isStructExist(StructName) if struct then DeleteStruct(struct) end end
  if not UEObj then enumUEObj() end
  local tabl=fullnameortable
  if type(fullnameortable)==type('') then
    for i,v in ipairs(UEObj) do if v.FullName==fullnameortable then tabl=v break end end
  end
  --[[
  if not tabl or type(tabl)~=type({})  then
    enumUEObj()
    if type(fullnameortable)==type('') then
      for i,v in ipairs(UEObj) do if v.FullName==fullnameortable then tabl=v break end end
    end
  end
  ]]
  if not tabl or type(tabl)~=type({})  then
    print(tostring(fullnameortable)..' not found...')
    return
  end
  local name=StructName
  if not name then name=tabl.Name end
  local struct=structu
  if not struct then struct=createStructure(name)end
  if not AddedName then AddedName='' end
  local RunningStructName=name
  if not AddedOffset then
    if not RunningStruct then RunningStruct={} end
    RunningStruct[#RunningStruct+1]=RunningStructName

    AddedOffset=0 struct.beginUpdate()
  elseif tabl and tabl.FullName then
    if not LocalStruct then LocalStruct={}end
    if LocalStruct[tabl.FullName] then copyStruct(LocalStruct[tabl.FullName],struct,AddedOffset,AddedName)
    else
      local copy=createStructure(tabl.FullName)
      ue4createstructfast(tabl,nil,nil,isfullname,copy)
      LocalStruct[tabl.FullName]=copy
      copyStruct(LocalStruct[tabl.FullName],struct,AddedOffset,AddedName)
    end
    return
  end

  --print(tostring(tabl))
  local isUserDefinedStruct=string.find(tabl.Type,'UserDefinedStruct')
  local e,typ,propname
  while(true)do
    if not tabl then break end
    if type(tabl)==type(1) or tabl.Name=='Object' then break end
    print(tostring(tabl.Type)..' '..tostring(tabl.FullName))
    if tabl.Member then
      for i=1,#tabl.Member do
        if tabl.Member[i].Type~='Function' then
          if isfullname then e.Name=string.format('%s %s%s',tabl.Member[i].Type,AddedName,tabl.Member[i].FullName)
          else
            propname=AddedName..tabl.Member[i].Name
            if isUserDefinedStruct then propname=propname:sub(1,string.find(propname,'_')-1) end
          end
          if tabl.Member[i].Type=='StructProperty' then
            ue4createstructfast(tabl.Member[i].Property,nil,nil,isfullname,struct,tabl.Member[i].Offset+AddedOffset,propname..'.',depth,callernum)
            if not getElementByOffset(struct,tabl.Member[i].Offset+AddedOffset) then e=struct.addElement() e.Offset=tabl.Member[i].Offset+AddedOffset e.Name=propname e.Vartype=vtDword end
          else
            e=struct.addElement()
            e.Offset=tabl.Member[i].Offset+AddedOffset
            typ=tabl.Member[i].Type
            e.Name=propname
            e.Vartype=ue4type[typ]
            if e.Vartype==nil then e.Vartype=vtDword end
            if typ=='ArrayProperty' or typ=='MapProperty' then
              local isMap= Typ=='MapProperty'
              local Typ=tabl.Member[i].Property[1].Type
              if Typ=='StructProperty' then propname=tabl.Member[i].Property[1].Property.Name..'[]'
              else propname=tabl.Member[i].Property[1].Name..'[]' end
              if not ArrayStruct then ArrayStruct={} end
              if ArrayStruct[propname] then e.setChildStruct(ArrayStruct[propname])
              else
                local stru=createStructure(propname)
                stru.beginUpdate()
                local ppsize=0
                if isMap then
                  for p=1,#tabl.Member[i].Property do
                    ppsize=(tabl.Member[i].Property[p].Size&lt;4 and 4 or tabl.Member[i].Property[p].Size)+ppsize
                  end
                  ppsize=ppsize+0x8
                end
                for p=1,#tabl.Member[i].Property do
                  local PropName=tabl.Member[i].Property[p].Name
                  local Typ=tabl.Member[i].Property[p].Type
                  local psize=isMap and ppsize or tabl.Member[i].Property[p].Size
                  local Offs=isMap and tabl.Member[i].Property[p].Offset or 0
                  for l=0,10 do
                    Off=l*psize+Offs
                    local ItemName=string.format('[%u] ',l)
                    if Typ=='StructProperty' then
                      ue4createstructfast(tabl.Member[i].Property[p].Property,nil,nil,isfullname,stru,Off,ItemName,depth,callernum)
                      --if not getElementByOffset(stru,Off) then g=stru.addElement() g.Offset=Off g.Name=ItemName..PropName g.Vartype=vtDword end
                    else
                      g=stru.addElement()
                      g.Offset=Off
                      g.Name=ItemName..PropName
                      if not ue4type[Typ] then g.Vartype=vtDword
                      else g.Vartype=ue4type[Typ]end
                    end
                  end
                end
                stru.endUpdate()
                if stru.Count&gt;1 then
                  fillstruct4bytes(stru)
                  e.setChildStruct(stru)
                  ArrayStruct[propname]=stru
                else stru:Destroy()end
              end

              local f=struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
            elseif typ=='BoolProperty' then e.ChildStructStart=tabl.Member[i].BitField end
          end
        end
      end
    end
    depths=depths+1
    if depths&gt;depth then break end
    tabl=tabl.Parent
  end
  if AddedName~='' then return end
  struct.endUpdate()

  fillstruct4bytes(struct)
  if isGlobal then StructList[#StructList+1]=struct end

  local count=#RunningStruct
  for i=1,count do
    if RunningStruct[i]==RunningStructName then RunningStruct[i]=nil end
    if not RunningStruct[i] and RunningStruct[i+1] then RunningStruct[i]=RunningStruct[i+1] RunningStruct[i+1]=nil end
  end
end

function uecreatestruct(instance,name,depth,isfullname)
  local pointer=readPointer(instance+UObject.Class)
  local classname=GetFullNameSafeAlgo(pointer)
  if not classname then print('instance is invalid') return end
  if classname:find(' ') then classname=classname:sub(classname:find(' ')+1) end

  print(string.format("createThread(ue4createstruct(\'%s\',\'%s\',0))",classname,name))
  ue4createstruct(pointer,name,depth,isfullname)
end

function ue_structureDissectOverrideCallback(Struct, Instance)
  --print('banana2')
  local name,fullname,class
  address,name,fullname,class=ue_findRealStartOfObject(Instance)

  if class then
   -- print('banana3')
    --if UEObj and (not enumUEObjIsRunning or enumUEObjIsUpdateOnly) then ue4createstructfast(fullname,nil,nil,nil,Struct) end
    SaveAndRemoveStruct()
    ue4createstruct(class,nil,nil,nil,Struct,nil,nil,Instance)
    --LoadStruct()
    if Struct.Count&gt;1 then return true
    else return false end
  end

  --ue_fillstruct(readPointer(Instance+UObject.Class),structure)
  --print('banana4')

  return nil
end

function ue_structureNameLookupCallback(address)
  --print('banana1')
  local name,fullname
  address,name,fullname=ue_findRealStartOfObject(address)
  if name then return name,address end
  return nil
end

function ue_SymbolLookupCallback(symbol)
  --print('banana1')
  local str='Function '
  if string.find(symbol,str) then
    symbol=symbol:sub(string.find(symbol,str)+str:len(),symbol:len())
    local pointer=StaticFindObjectAlgo(symbol)
    if pointer then return readPointer(pointer+UObject.funct)end
  end
  return nil
end

function ue_findRealStartOfObject(address)
  local pointer=readPointer(address+UObject.Class)
  if pointer then
    local FullName=GetFullNameSafeAlgo(pointer)
    if FullName then
      local Name=GetNameAlgo(pointer)
      FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
      Name=Name:sub(string.find(Name,' ')+1,Name:len())
      return address,Name,FullName,pointer
    end
  end

  if UEObj and (not enumUEObjIsRunning or enumUEObjIsUpdateOnly) then
    for i=1,#UEObj do
      if UEObj[i].MemberSize and UEObj[i].Class and UEObj[i].Class.MemberSize and UEObj[i].Class.MemberSize&gt;0 and not string.find(UEObj[i].Class.FullName,'/Script/CoreUObject.') then
         if address&gt;=UEObj[i].Address and address&lt;UEObj[i].Address+UEObj[i].Class.MemberSize then
           local name
           return UEObj[i].Address,UEObj[i].Class.Name,UEObj[i].Class.FullName,UEObj[i].Class.Address
         end
      end
    end
  end

  return address
end


function enumUEObjT(file,size,i,start,stop)
 local datatable,Address,FName,Name,FullName,typ,typ1,isProperty,l,pointer,stri,num,isPropertyc,EObj,k=0
 local Class,ObjectId,super,Offset,nextmember,member,propsize,bitmask,Property,Outer=UObject.Class,UObject.ObjectId,UObject.super,UObject.Offset,UObject.nextmember,UObject.member,UObject.propsize,UObject.bitmask,UObject.Property,UObject.Outer
 local UEver=UE4ver
 local pointersize= targetIs64Bit() and 8 or 4

 for j=start,stop do

    if UObjectMul then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*UObjectMul+m] then break end
        datatable[m]=GUObjectDict[i][j*UObjectMul+m]
      end
      Address=byteTableToQword(datatable)
    elseif UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x8+m] then break end
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      Address=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x4+m] then break end
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      Address=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x18+m] then break end
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      Address=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x10+m] then break end
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      Address=byteTableToDword(datatable)
    end

    if Address and Address~=0 then
       objid=readInteger(Address+ObjectId)
       if objid then
          if objid&lt;size then
             FullName=GetFullNameSafeAlgo(Address)

             if FullName then
               isProperty=false
               typ1=FullName:sub(1,string.find(FullName,' ')-1)
               FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
               if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len()) isProperty=true
               elseif string.find(FullName,'%.') then Name=FullName:sub(string.find(FullName,'%.')+1,FullName:len())
               else Name=FullName end
               if UEObjIndex[FullName] and UEObj[UEObjIndex[FullName]] then UEObj[UEObjIndex[FullName]].Address=Address
               else
                 EObj={}
                 EObj.Address=Address
                 EObj.Id=objid
                 EObj.Class=temp[readPointer(Address+Class)]
                 EObj.Type=typ1
                 EObj.FullName=FullName
                 EObj.Name=Name
                 if isProperty then
                   isProperty=readPointer(Address+Outer)
                   if isProperty and isProperty~=0 then
                     EObj.Outer=isProperty
                     EObj.Size=readInteger(Address+propsize)
                     EObj.Offset=readInteger(Address+Offset)
                     if typ1=='BoolProperty' then EObj.BitField=readBytes(Address+bitmask,1)
                     elseif typ1=='StructProperty' or typ1=='ObjectProperty' then EObj.Property=readPointer(Address+Property)
                     elseif typ1=='MapProperty' or typ1=='ArrayProperty' then
                       EObj.Property={}
                       local count= typ1=='MapProperty' and 1 or 0
                       for p=0,count do
                         local prop=readPointer(Address+Property+p*8)
                         FullName=GetFullNameSafeAlgo(prop)

                         if FullName then
                           typ=FullName:sub(1,string.find(FullName,' ')-1)
                           FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
                           if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len())
                           else Name=FullName end
                           if string.find(Name,'%:') then Name=Name:sub(string.find(Name,'%:')+1,Name:len())end
                           local Prop={}
                           Prop.Address=prop
                           Prop.Type=typ
                           Prop.FullName=FullName
                           Prop.Name=Name
                           Prop.Size=readInteger(prop+propsize)
                           Prop.Offset=readInteger(prop+Offset)
                           if typ=='BoolProperty' then Prop.BitField=readBytes(prop+bitmask,1)
                           elseif typ=='StructProperty' or typ=='ObjectProperty' then Prop.Property=readPointer(prop+Property)end
                           EObj.Property[p+1]=Prop
                         end
                       end
                     end
                   else print(FullName..' nil outer')
                   end
                 end

                 Parent=readPointer(Address+super)
                 if Parent and Parent~=0 then EObj.Parent=Parent end
                 temp[Address]=EObj
                 if UEver&gt;=25 then
                   k=1
                   EObj.MemberSize=readInteger(Address+member+pointersize)
                   Address=readPointer(Address+member)
                   EObj.Member={}

                   while(true)do
                     if UEver&gt;=25 then FullName=GetFullNameSafeAlgo(Address)
                     else FullName=GetFullNameSafeAlgo(Address) end
                     if not FullName then break end

                     typ=FullName:sub(1,string.find(FullName,' ')-1)
                     FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
                     if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len())
                     else Name=FullName end
                     EObj.Member[k]={}
                     EObj.Member[k].Address=Address
                     EObj.Member[k].Type=typ
                     EObj.Member[k].FullName=FullName
                     EObj.Member[k].Name=Name
                     EObj.Member[k].Size=readInteger(Address+propsize)
                     EObj.Member[k].Offset=readInteger(Address+Offset)
                     if typ=='BoolProperty' then EObj.Member[k].BitField=readBytes(Address+bitmask,1)
                     elseif typ=='StructProperty' or typ=='ObjectProperty' then EObj.Member[k].Property=readPointer(Address+Property)
                     elseif typ=='MapProperty' or typ=='ArrayProperty' then
                       EObj.Member[k].Property={}
                       for p=0,1 do
                         local prop=readPointer(Address+Property+p*8)
                         FullName=GetFullNameSafeAlgo(prop)

                         if FullName then
                           typ=FullName:sub(1,string.find(FullName,' ')-1)
                           FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
                           if string.find(FullName,'%:') then Name=FullName:sub(string.find(FullName,'%:')+1,FullName:len())
                           else Name=FullName end
                           if string.find(Name,'%:') then Name=Name:sub(string.find(Name,'%:')+1,Name:len())end
                           local Prop={}
                           Prop.Address=prop
                           Prop.Type=typ
                           Prop.FullName=FullName
                           Prop.Name=Name
                           Prop.Size=readInteger(prop+propsize)
                           Prop.Offset=readInteger(prop+Offset)
                           if typ=='BoolProperty' then Prop.BitField=readBytes(prop+bitmask,1)
                           elseif typ=='StructProperty' or typ=='ObjectProperty' then local propt=readPointer(prop+Property) if propt then Prop.Property=propt end end
                           EObj.Member[k].Property[p+1]=Prop
                         end
                       end
                       if #EObj.Member[k].Property==0 then EObj.Member[k].Property=nil end
                     end
                     Address=readPointer(Address+nextmember)
                     k=k+1
                   end
                   if #EObj.Member==0 then EObj.Member=nil end
                 end
                 UEObj[#UEObj+1]=EObj
                 UEObjIndex[EObj.FullName]=#UEObj+1
               end
             end
          end
       end
    end
 end
--print(i..':'..k)
end

function enumUEObj(isSilent,isUpdateOnly)
 if isUpdateOnly then enumUEObjIsUpdateOnly=true end
 enumUEObjIsRunning=true
 local sub=targetIs64Bit() and 0 or 4
 ue4parsetablecheck()
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;11 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local starttime=os.time()
 if not isUpdateOnly then
   UEObj={}
   UEObjIndex={}
 end
 temp={}
 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess+0.5) do
   start=stop
   stop=stop+num
   createThread(enumUEObjT(file,size,i,start,stop-1))
  end
 end
 if not isUpdateOnly then
   if UE4ver&gt;=25 then
     for i=1,#UEObj do
       if UEObj[i].Parent then
         if temp[UEObj[i].Parent] then
           UEObj[i].Parent=temp[UEObj[i].Parent]
         end
       end
       if UEObj[i].Member then
         for j=1,#UEObj[i].Member do
           if UEObj[i].Member[j].Property then
             if temp[UEObj[i].Member[j].Property] then
               UEObj[i].Member[j].Property=temp[UEObj[i].Member[j].Property]
             elseif type(UEObj[i].Member[j].Property)==type({}) then
               for p=1,#UEObj[i].Member[j].Property do
                 if temp[UEObj[i].Member[j].Property[p].Property] then
                   UEObj[i].Member[j].Property[p].Property=temp[UEObj[i].Member[j].Property[p].Property]
                 elseif UEObj[i].Member[j].Property[p].Property then print(string.format('%X no object?',UEObj[i].Member[j].Property[p].Property))
                 elseif UEObj[i].Member[j].Property[p].Type=='StructProperty' or UEObj[i].Member[j].Property[p].Type=='ObjectProperty' then print(string.format('%s %s no property?',UEObj[i].Member[j].Property[p].Type,UEObj[i].Member[j].Property[p].FullName))
                 end
               end
             end
           end
         end
       end
     end
   else
     for i=1,#UEObj do
       if UEObj[i].Parent then
         if temp[UEObj[i].Parent] then
           UEObj[i].Parent=temp[UEObj[i].Parent]
         end
       end
       if UEObj[i].Outer then
         if temp[UEObj[i].Outer]then
           if temp[UEObj[i].Property] then
             UEObj[i].Property=temp[UEObj[i].Property]
           elseif type(UEObj[i].Property)==type({}) then
             for p=1,#UEObj[i].Property do
               if temp[UEObj[i].Property[p].Property] then
                 UEObj[i].Property[p].Property=temp[UEObj[i].Property[p].Property]
               else print(string.format('%X no object?',UEObj[i].Property[p].Property))
               end
             end
           end
           if not temp[UEObj[i].Outer].Member then temp[UEObj[i].Outer].Member={}end
           temp[UEObj[i].Outer].Member[#temp[UEObj[i].Outer].Member+1]=UEObj[i]
         else print(UEObj[i].FullName..' missing outer') end
       end
     end
   end
 end
 temp=nil
 enumUEObjIsUpdateOnly=false
 enumUEObjIsRunning=false
 if not isSilent then print(string.format('\nA Total of %u objects had been enumerated in %u seconds',#UEObj,os.time()-starttime))end
end



function findOpcodes(address,opcode,size)
  if not size then size=0x50 end
  address=getAddressSafe(address)
  if not address then return nil end
  local addr={}
  local i=0
  local j=1
  while(i&lt;size) do
    local ext, opc, byt, add=splitDisassembledString(disassemble(address+i))
    if string.find(opc,opcode) then
      addr[j]=address+i
      j=j+1
    end
    i=i+getInstructionSize(address+i)
  end
  return addr
end

function findLastCall(address,size)
  if not size then size=0x1000 end
  local result=findOpcode(address,'ret',size)
  if not result then print(address..' cant find ret?') return nil end
  result=result-getAddress(address)
  result=findOpcodes(address,'call ',result)
  local ext, opc, byt, add=splitDisassembledString(disassemble(result[#result]))
  opc=opc:gsub('call ','')
  return opc
end

function followjmp(address,size)
  if not size then size=0x1000 end
  local result=findOpcode(address,'jmp ',size)
  if not result then print(address..' cant find jmp?') return nil end
  local ext, opc, byt, add=splitDisassembledString(disassemble(result))
  opc=opc:gsub('jmp ','')
  return opc
end

function followcall(address,size)
  if not size then size=0x1000 end
  local result=findOpcode(address,'call ',size)
  if not result then print(address..' cant find call?') return nil end
  local ext, opc, byt, add=splitDisassembledString(disassemble(result))
  opc=opc:gsub('call ','')
  return opc
end

--local ext, opc, byt, add=splitDisassembledString(disassemble(findOpcodes('/Script/Astro.PrinterComponent:UpdatePreprinting_exec','call')[1]))
--return opc:sub(string.find(opc,' ')+1,opc:len())

function groupscan(value,modulename,stopaddress)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtGrouped,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress,value2)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  if type(modulename)==type(0) then modulename=string.format('%X',modulename)
  elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
  if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
    stopaddress=getNameFromAddress(getAddress(modulename),true,false)
    if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
	if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
    modulename=getAddress([["]]..stopaddress..[["]])
	stopaddress=modulename+getModuleSize(stopaddress)
    modulename=string.format('%X',modulename)
  end
  if type(stopaddress)==type(0) then stopaddress=string.format('%X',stopaddress)end
  print(modulename..'~'..stopaddress)
  if value2 then ms.firstScan(soValueBetween,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  else ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)end
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function UEfindInstancesOfClass(fullnameOrAddress)
  local class,Name,address,Typ=UObject.Class
  local results,j={},1
  if type(fullnameOrAddress)==type('')then address=StaticFindObjectAlgo(fullnameOrAddress)
  else address=fullnameOrAddress end
  local result,result2=pointerscan(address)
  for i=1,#result do

    Name=GetFullNameSafeAlgo(getAddress(result[i])-class)
    if not Name then Name=GetFullNameSafeAlgo(getAddress(result[i])-UObject.super)end

    if Name and Name~='None' then
      Typ=Name:sub(1,string.find(Name,' ')-1)
      if string.find(Typ,'Class') then
        result2=pointerscan(getAddress(result[i])-UObject.super)
        for k=1,#result2 do
          Name=GetFullNameSafeAlgo(getAddress(result2[k])-class)
          if not Name then Name=GetFullNameSafeAlgo(getAddress(result2[k])-UObject.super)end
          if Name and Name~='None' then
            results[j]={}
            results[j].Name=Name
            results[j].Address=math.floor(getAddress(result2[k])-class)
            j=j+1
          end
        end
      else
        results[j]={}
        results[j].Name=Name
        results[j].Address=math.floor(getAddress(result[i])-class)
        j=j+1
      end
    end
  end
  --for i,v in ipairs(result) do result[i]=tonumber(v,16)-class end
  return results
end

function StructAddToListSymbol(StructName,StartOffset,StopOffset,BaseAddress,OffsetOnly)
  if not StartOffset then StartOffset=0 end
  if not StopOffset then StopOffset=0xFFFFFF end
  local structCount=getStructureCount()
  local struct
  for i=0,structCount-1 do
    local stru=getStructure(i)
    if stru.Name==StructName then struct=stru break end
  end
  if struct then
    for i=0,struct.Count-1 do
      local e=struct.Element[i]
      if e.Offset&gt;=StartOffset and e.Offset&lt;=StopOffset then
        local rec=getAddressList().createMemoryRecord()
        rec.setDescription(e.Name)
        if OffsetOnly then
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.Offset[0]=e.Offset
          else rec.setAddress(string.format('+%X',e.Offset))end
        else
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.OffsetText[0]=StructName..'.'..e.Name
          else rec.setAddress(string.format('+%s.%s',StructName,e.Name))end
        end
        rec.Type=e.Vartype
      end
    end
  end
end

function getInsForJump(address,registername,destination,allocsize,SharedMemoryName)
  address = getAddressSafe(address)
  if not address then error('getInsForJump address nil') return end
  if not allocsize then allocsize=4096 end
  destination=getAddressSafe(destination)
  if not destination then
	if not SharedMemoryName then destination = allocateMemory(allocsize,address)
	else destination = allocateSharedMemory(SharedMemoryName,allocsize) end
  end
  local size = (address+5-destination&gt;0x7FFFFFFF) and 14 or 5
  if registername then
	unregisterSymbol(registername)
	registerSymbol(registername,destination,true)
  end
  local opcodes = {}
  local i = 0
  while(i&lt;size) do
    local ext, opc=splitDisassembledString(disassemble(address+i))
    opcodes[#opcodes+1] = opc
    i=i+getInstructionSize(address+i)
  end
  local copy = table.concat(opcodes,'\r\n')
  local readAsTable = true
  local byt = readBytes(address,i,readAsTable)
  for j=1,#byt do byt[j] = ('%02X'):format(byt[j]) end
  local bytes = table.concat(byt, ' ')
  return i,copy,bytes,size,destination
end

function enablescript(name,registername,addressname,script,disable)
    local address=getAddress(addressname)
    if disable then script=(script):format(address,registername,readBytes(registername,1))
    else
        local i,copy,bytes,size =getInsForJump(address,name)
        script=(script):format(registername, registername, name, copy, registername, i, bytes, address)..string.rep('nop\n',i-size)..'returnhere:'
    end
    local success,erro=autoAssembleCheck(script)
    if not success then print('\n'..erro..'\n')local scriptstr=createStringlist()scriptstr.Text=script for j=0,scriptstr.Count-1 do print(string.format('%u\t%s',j+1,scriptstr[j])) end
    if not disable then deAlloc(name)unregisterSymbol(name)end error(name..' autoAssemble failed')end
    autoAssemble(script)
    if disable then deAlloc(name)unregisterSymbol(name)unregisterSymbol(registername)end
end

function cycleFullCompact(sender,force)
local state = not(compactmenuitem.Caption == 'Compact View Mode')
if force~=nil
then state = not force
end
compactmenuitem.Caption = state and 'Compact View Mode' or 'Full View Mode'
getMainForm().Splitter1.Visible = state
getMainForm().Panel4.Visible = state
getMainForm().Panel5.Visible = state
end

function addCompactMenu()
if compactmenualreadyexists
then return end
local parent = getMainForm().Menu.Items
compactmenuitem = createMenuItem(parent)
parent.add(compactmenuitem)
compactmenuitem.Caption = 'Compact View Mode'
compactmenuitem.OnClick = cycleFullCompact
compactmenualreadyexists = 'yes'
end

addCompactMenu()
--cycleFullCompact(nil,true)

if syntaxcheck then return end

[ENABLE]
if not process or not enumModules()[1] then print('Error: No process selected...') error('process is nil') end
if string.find(process,'MassEffect') then
  isMassEffect=true
  --findAddress('GUObjectArray',1,'4C * * * * * * 49 3B * 0F 84 * * * * 48 89 * * * 48 89banana',process)
  --print('------------------')
  local result2,result=findAddress('FNamePool',0,'C0 CA 45 80 00 00 00 00 00 00 00 00 4E 6F 6E 65 00banana',process,nil,0,true)
  for i=1,#result2 do
    result=pointerscan(getAddress(result2[i]),process)
    for j=1,#result do
      stringoffset=0xC
      unregisterSymbol('FNamePool') registerSymbol('FNamePool',result[j],true)
    end
  end

  else isMassEffect=nil
end
local starttime=os.time()

if not UE4ver then UE4ver=ue4versioncheck() end

if not getAddressSafe('GUObjectArray') and not getAddressSafe('FNamePool')  then

  if targetIs64Bit() then

    local address=findAddress('GUObjectArray',0,'44 8B * * * 48 8D 05 * * * * * * * * * 48 89 71 10banana',process,nil,0,true)[1]
    if not address then address=findAddress('GUObjectArray',0,'40 53 48 83 EC 20 48 8B D9 48 85 D2 74 * 8Bbanana',process,nil,0,true)[1]end
    if not address then address=findAddress('GUObjectArray',0,'4C 8B 05 * * * * 45 3B 88banana',process,nil,0,true)[1]end
    if not address then findAddress('GUObjectArray','1,-0x68','4C 8B 44 24 60 8B 44 24 78 * * * 48 8Dbanana',process)
    else findAddress('GUObjectArray',1,address)end

    if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
      if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
      elseif readInteger('GUObjectArray+14')==0 then UE4ver=9
      else UE4ver=20 end
    end

    ue4config()

    if UE4ver&gt;=23 then
      address=findAddress('FNamePool',0,'4C 8D 05 * * * * EB 16 48 8D 0D * * * * E8banana',process,nil,0,true)[1]
      if not address then address=findAddress('FNamePool',0,'48 8D 0D *  *  *  *  E8 *  *  *  * 4C 8B C0 C6banana',process,nil,0,true)[1]end
      if address then findAddress('FNamePool',1,address)
      else error('FNamePool aob not found...')end
    elseif string.find(process,'StateOfDecay2')then
      findAddress('FNamePool',1,'48 8D * * * * * 8B * * 85 * 74 * 8Dbanana',process,nil,1,nil,true,true)
      findAddress('FNamePool2',3,'48 8D * * * * * 8B * * 85 * 74 * 8Dbanana',process,nil,1,nil,true,true)
      FNamePool=getAddress('FNamePool')
      FNamePool2=getAddress('FNamePool2')
    else
      address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[2]
      if not address then address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[1] end
      if address then findAddress('FNamePool',1,address)
      else findAddress('FNamePool',1,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20banana',process,nil,2)end
    end

  else
    ue4config()
    if UE4ver&gt;2 then
      findAddress('GUObjectArray',1,'8B 44 24 04 56 8B F1 85 C0 74 17 8B 40 08banana',process)
      findAddress('FNamePool',1,'33 F6 89 35 * * * * 8B C6 5Ebanana',process,nil,1,nil,true,true)
    else
      findAddress('FNamePool',1,'8B 07 8B 0D * * * * 8B 04 81banana',process)
      findAddress('GUObjectArray',1,'8B 15 * * * * 8B 04 82 85banana',process)
    end
  end

end

if targetIs64Bit() then
  if UE4ver&gt;7 then
    local address=findAddress('GEngine',0,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process,nil,0,true)[1]
    if not address then address=findAddress('GEngine',0,'48 8B 1D * * * * 48 85 DB 74 * 48 8Dbanana',process,nil,0,true)[1]end
    if not address then error('GEngine aob not found...')end
    findAddress('GEngine',1,address)
 --findAddress('GEngine',1,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process)
  end
else
  if UE4ver&gt;2 then
    findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  else
    findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  end
end

print('AOBScan done : '..os.time()-starttime)

ue4parsetable()

FNameStringAlgo(1,true)
FNameStringAlgo(3,true)
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

print('Table parsing done : '..os.time()-starttime)

if UE4ver&gt;7 then UE4AutoConfig() else UE3AutoConfig() end

--findAddress('GWorld',1,'4D 8B 94 24 50 0C 00 00banana',process)

if UE4ver&gt;7 then

   ue4createstruct({
   '/Script/Engine.GameEngine',
   '/Script/Engine.GameViewportClient',
   '/Script/Engine.GameInstance',
   '/Script/Engine.LocalPlayer',
   '/Script/Engine.PlayerController',
   '/Script/Engine.CharacterMovementComponent',
   '/Script/Engine.CapsuleComponent',
   '/Script/Engine.Character',
   '/Script/Engine.World'
   },{
   'GameEngine',
   'GameViewportClient',
   'GameInstance',
   'LocalPlayer',
   'PlayerController',
   'MovementComponent',
   'CapsuleComponent',
   'GPlayer',
   'World'
   },1)

end
createThread(BasicEnumObject())
print('All done : '..os.time()-starttime..'\n')
if not ue_SymbolLookupCallbackID then
  ue_SymbolLookupCallbackID=registerSymbolLookupCallback(ue_SymbolLookupCallback,slNotSymbol)
end
--registerFuncAlgo()
GetLuaEngine().close()
[DISABLE]
--cycleFullCompact(nil,false)
unregisterSymbolLookupCallback(ue_SymbolLookupCallbackID)
ue_SymbolLookupCallbackID=nil
--[[
unregisterSymbol('GEngine')
unregisterSymbol('GUObjectArray')
unregisterSymbol('FNamePool')]]
</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>26146</ID>
                  <Description>"Enable ue_structureDissectCallback (Experimental)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
if not ue_structureDissectOverrideCallbackID then
  ue_structureDissectOverrideCallbackID=registerStructureDissectOverride(ue_structureDissectOverrideCallback)
end

if not ue_structureNameLookupCallbackID then
  ue_structureNameLookupCallbackID=registerStructureNameLookup(ue_structureNameLookupCallback)
end
--[[
UEObjt=createThread(function()
  while(true)do
    if not UEObj and not enumUEObjIsRunning then enumUEObj(1)
    elseif not enumUEObjIsRunning then enumUEObj(1,1)end
    sleep(30000)
  end
end)
 ]]
[DISABLE]
unregisterStructureDissectOverride(ue_structureDissectOverrideCallbackID)
unregisterStructureNameLookup(ue_structureNameLookupCallbackID)
ue_structureDissectOverrideCallbackID=nil
ue_structureNameLookupCallbackID=nil

--UEObjt:terminate()
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26147</ID>
                  <Description>"Basic UE Object Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local Offset,ObjectId,nextmember,member,Property=UObject.Offset,UObject.ObjectId,UObject.nextmember,UObject.member,UObject.Property
local enumoffset,enummul,enumname,enumindex=UObject.enumoffset,UObject.enummul,UObject.enumname,UObject.enumindex
function ue4dump(file,size,i,start,stop)
 --print(start..' ~ '..stop)
 local k=0
 local pointer,datatable,pointers,propname,offset,list,str,strid,name,objid
 for j=start,stop do

    if UObjectMul then
      if targetIs64Bit() then
        datatable={}
        for m=1,8 do
          if not GUObjectDict[i][j*UObjectMul+m] then break end
          datatable[m]=GUObjectDict[i][j*UObjectMul+m]
        end
        pointer=byteTableToQword(datatable)
      else
        datatable={}
        for m=1,4 do
          if not GUObjectDict[i][j*0x4+m] then break end
          datatable[m]=GUObjectDict[i][j*0x4+m]
        end
        pointer=byteTableToDword(datatable)
      end
    elseif UE4ver&lt;11 and targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x8+m] then break end
        datatable[m]=GUObjectDict[i][j*0x8+m]
      end
      pointer=byteTableToQword(datatable)
    elseif UE4ver&lt;11 then
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x4+m] then break end
        datatable[m]=GUObjectDict[i][j*0x4+m]
      end
      pointer=byteTableToDword(datatable)
    elseif targetIs64Bit() then
      datatable={}
      for m=1,8 do
        if not GUObjectDict[i][j*0x18+m] then break end
        datatable[m]=GUObjectDict[i][j*0x18+m]
      end
      pointer=byteTableToQword(datatable)
    else
      datatable={}
      for m=1,4 do
        if not GUObjectDict[i][j*0x10+m] then break end
        datatable[m]=GUObjectDict[i][j*0x10+m]
      end
      pointer=byteTableToDword(datatable)
    end

    if pointer and pointer~=0 then
       local objid=readInteger(pointer+ObjectId)
       if objid and readPointer(readPointer(pointer)) then
          --if objid&lt;size then
             str=string.format('%016X',pointer)
             strid=string.format('%08u',objid)
             if UObject.super then name=GetFullNameSuperAlgo(pointer,true)
             else name=GetFullNameSafeAlgo(pointer,true)end
             if name then
                 typ=name:sub(1,string.find(name,' ')-1)
                 if string.find(typ,'Property') then
                     if (typ=='StructProperty' or string.find(typ,'ObjectProperty') or string.find(typ,'ArrayProperty') ) and Property then
                       name=hasProperty(pointer)
                     end
                     strid=string.format('%8X',readInteger(pointer+Offset))
                 end

                 file:write(string.format('[%s] %s %s\n',strid,str,name))


                 if (typ=='UserDefinedEnum' or typ=='Enum') and enummul then
                   list=pointer+enumoffset
                   for i=0,readInteger(list+8-sub)-1 do
                     pointers=readPointer(list)+i*enummul
                     offset=readBytes(pointers+enumindex,1)
                     if offset==0 then offset=i end
                     propname=FNameStringAlgo(pointers+enumname)
                     strid=string.format('%8X',offset)
                     str=string.format('%016X',pointers)
                     file:write(string.format('[%s] %s %s\n',strid,str,propname))
                   end
                 elseif ( typ=='MapProperty' or string.find(typ,'ArrayProperty') ) and Property then
                   for n=0,1 do
                     pointers=readPointer(pointer+n*8+Property)
                     propname=hasProperty(pointers)
                     if propname then
                       offset=readInteger(pointers+Offset)
                       strid=string.format('%8X',offset)
                       str=string.format('%016X',pointers)
                       file:write(string.format('[%s] %s %s\n',strid,str,propname))
                     end
                   end
                 end

                 if UE4ver&gt;=25 then
                     local pointers= readPointer(pointer+member)
                     while(true)do
	                     propname=GetFullNameSafeAlgo(pointers)
	                     if not propname then break end
	                     offset=readInteger(pointers+Offset)
	                     strid=string.format('%8X',offset)
                         str=string.format('%016X',pointers)

                         typ=propname:sub(1,string.find(propname,' ')-1)
                         if typ=='StructProperty' or string.find(typ,'ObjectProperty') or string.find(typ,'ArrayProperty') then
                           propname=hasProperty(pointers)
                         end

	                     file:write(string.format('[%s] %s %s\n',strid,str,propname))


                         if typ=='MapProperty' or string.find(typ,'ArrayProperty') then
                           for n=0,2 do
                             pointer=readPointer(pointers+n*8+Property)
                             propname=hasProperty(pointer)
                             if propname then
                               offset=readInteger(pointer+Offset)
                               strid=string.format('%8X',offset)
                               str=string.format('%016X',pointer)
                               file:write(string.format('[%s] %s %s\n',strid,str,propname))
                             end
                           end
                         end

	                     pointers=readPointer(pointers+nextmember)
                     end
                 end
                 k=k+1
             else file:write(string.format('[%s] %s Invalid Object\n',strid,str)) end
          --end
       end
    end
 end
    totalobject=totalobject+k
--print(i..':'..k)
end


 local sub=targetIs64Bit() and 0 or 4
 ue4parsetablecheck()
 local count=0x200
 local size=GUObjectsize
 local sizess= targetIs64Bit() and (UE4ver&gt;10 and 0x18*count or 0x8*count) or (UE4ver&gt;11 and 0x10*count or 0x4*count)
 local starttime=os.time()
 local Path = 'C:\\test\\'
 local filename= string.format('[%s] ObjectsDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
--local re={rei1,rei2,rei3,rei4,rei5}
 totalobject=0
--allobject=createStringlist()

 for i=1,#GUObjectDict do
  local num,start,stop=count,0,0
  for j=0,math.floor(#GUObjectDict[i]/sizess+0.5) do
   start=stop
   stop=stop+num
   createThread(ue4dump(file,size,i,start,stop-1))
  end
 end


 file:close()
 print(string.format('\nA Total of %u objects had been dumped in %u seconds',totalobject,os.time()-starttime))
 print(Path..filename)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26148</ID>
                  <Description>"Basic UE Name Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function uenamedump(file,start,stop)
  for i=start,stop do
    local name=FNameStringAlgo(i,true)
    if name and name:len()&lt;200 and name:len()&gt;3 and not string.find(name,'%c')  then
      --print(name)
      local strid=string.format('%08X',i)

      file:write(string.format('[%s] %s\n',strid,name))
      totalname=totalname+1
    end
  end
end


 local size
 if readPointer(FNameString) or string.find(process,'StateOfDecay2')then size=0xFFFFFFFF
 elseif UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
 elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
 else size=math.floor(#FNameDict[1]/4) end
 local count=0x200
 size=math.floor((size/count)+0.5)

 local starttime=os.time()
 local Path = 'C:\\test\\'
 local filename= string.format('[%s] NamesDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
 totalname=0
 ue4parsetablecheck()
 local num,start,stop=count,0,0
 for i=0,size do
   start=stop
   stop=stop+num
   createThread(uenamedump(file,start,stop-1))
 end
 file:close()
 print(string.format('\nA Total of %u names had been dumped in %u seconds',totalname,os.time()-starttime))
 print(Path..filename)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26149</ID>
                  <Description>"Construct Console"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function AAscript(script)
  local success,erro=autoAssembleCheck(script)
  if not success then
    print('\n'..erro..'\n')
    local scriptstr=createStringlist()scriptstr.Text=script
    for j=0,scriptstr.Count-1 do print(string.format('%u\t%s',j+1,scriptstr[j])) end
    error('autoAssemble failed')
  end
  autoAssemble(script)
end

AAscript("aobscanmodule(StaticConstructObject,$process,4C ?? ?? ?? ?? 55 53 56 57 41 54 41 55 41 56 41 57 48 8D ?? ?? ?? ?? ?? ?? 48 81 ?? ?? ?? ?? ?? 48 8B ?? ?? ?? ?? ?? 48 33 ?? 48 89)\nregistersymbol(StaticConstructObject)")
local StaticConstructObject=getAddress('StaticConstructObject')
local Console=executeCodeEx
(
  0,nil,
  getAddress(StaticConstructObject),
  getAddress('[[GEngine]+GameEngine.ConsoleClass]'),
  getAddress('[[GEngine]+GameEngine.GameViewport]'),
  0,0,0,0,0,0,0
)
writePointer('[[GEngine]+GameEngine.GameViewport]+GameViewportClient.ViewportConsole',Console)


[DISABLE]
--"NewObject with empty name can't be used to create default subobjects"


</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26150</ID>
                  <Description>"Get GEngine "</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
unregisterSymbol('GEngine')
--[[
local result=UEfindInstancesOfClass('/Script/Engine.GameEngine')
for i=1,#result do
  print(string.format('%X:%s',result[i].Address,result[i].Name))
  if string.find(result[i].Name,'e_') then registerSymbol('GEngine',pointerscan(result[i].Address,process)[1]) end
end
]]


--[[

BasicEnumObject()
for i=1,#ObjectTable do
  if string.find(ObjectTable[i].Type,'GameEngine') and not string.find(ObjectTable[i].FullName,'Default') then
    print(string.format('%X:%s',ObjectTable[i].Address,GetFullNameSafeAlgo(ObjectTable[i].Address)))
    registerSymbol('GEngine',pointerscan(ObjectTable[i].Address,process)[1])  break
  end
  if i==#ObjectTable then print('GameEngine instance not found...')end

end
 ]]

function FindObjectName(name)
  for i=1,#ObjectTable do
    if string.find(ObjectTable[i].FullName,name) then return ObjectTable[i]end
  end
end

function FindObjectType(name,exception)
  for i=1,#ObjectTable do
    if string.find(ObjectTable[i].Type,name) and not string.find(ObjectTable[i].FullName,exception) then return ObjectTable[i]end
  end
end
--ue4parsetable()
--BasicEnumObject()
local Object=FindObjectName('GameEngine')
for i=0,4 do
  if Object.Uper and Object.Uper[1] then Object=Object.Uper[1] else break end
end
Object=Object.FullName:sub(string.find(Object.FullName,'%.')+1,Object.FullName:len())

Object=FindObjectType(Object,'Default')
print(string.format('%X : %s %s',Object.Address,Object.Type,Object.FullName))




registerSymbol('GEngine',pointerscan(Object.Address,process)[1],true)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26151</ID>
                  <Description>"NoClip &amp; Fly                                            Numpad6 :Toggle, Space :Up, LeftCtrl :Down"</Description>
                  <Options moHideChildren="1" moDeactivateChildrenAsWell="1"/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end

[ENABLE]

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) &amp; ~ ChildStructStart('PlayerController','bActorEnableCollision')
writeBytes(address,bActorEnableCollision)
end

--[[
Enum /Script/Engine.EMovementMode
0:MOVE_None
1:MOVE_Walking
2:MOVE_NavWalking
3:MOVE_Falling
4:MOVE_Swimming
5:MOVE_Flying
6:MOVE_Custom
7:MOVE_MAX

local list=+0x40
for i=0,readInteger(list+8)-1 do
local pointer=readPointer(list)+i*0x10
local enum=readInteger(pointer+8)
local name=FNameString(pointer)
print(enum..':'..name)
end
]]


if not RelativeLocationZoffset then
  local address=getAddress('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  local value=readInteger(address+getAddress('CapsuleComponent.RelativeLocation.Z'))
  local list=groupscan(string.format('4:%u',value),address,address+0x1000)
  RelativeLocationZoffset={}
  for i=1,#list do
    RelativeLocationZoffset[i]=getAddress(list[i])-address
  end
end

updown = createTimer()
updown.Interval = 5
updown.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_SPACE) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])+20)
      end
    end
    if isKeyPressed(VK_LCONTROL) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])-20)
      end
    end
  end
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MovementMode')
  if address then
  writeBytes(address,5)
  end
end




[DISABLE]
updown.destroy()

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) | ChildStructStart('PlayerController','bActorEnableCollision')
writeBytes(address,bActorEnableCollision)
end

local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MovementMode')
if address then
writeBytes(address,1)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Toggle Activation</Action>
                      <Keys>
                        <Key>102</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                  </Hotkeys>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26152</ID>
                      <Description>"WASD"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
wasd = createTimer()
wasd.Interval = 5
wasd.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_S) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)+20)
      end
    end
    if isKeyPressed(VK_W) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)-20)
      end
    end
    if isKeyPressed(VK_A) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)+20)
      end
    end
    if isKeyPressed(VK_D) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)-20)
      end
    end
  end
end

[DISABLE]
wasd.destroy()
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>26153</ID>
                  <Description>"bCanBeDamaged false (Godmode)      Numpad4 :Deactive, Numpad5 :Active"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end

[ENABLE]
--CanBeDamaged = createTimer()
--CanBeDamaged.setInterval(1000)
--CanBeDamaged.OnTimer = function()
local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bCanBeDamaged')
if address then
local bCanBeDamaged=readBytes(address,1) &amp; ~ ChildStructStart('PlayerController','bCanBeDamaged')
writeBytes(address,bCanBeDamaged)
end
--end
 
 
[DISABLE]
--CanBeDamaged.destroy()

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bCanBeDamaged')
if address then
local bCanBeDamaged=readBytes(address,1) | ChildStructStart('PlayerController','bCanBeDamaged')
writeBytes(address,bCanBeDamaged)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>101</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>100</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26154</ID>
                  <Description>"Jump Multiplier                                       Numpad0 :Deactive, Numpad1 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
jumpmultiplier=1
if syntaxcheck then return end
if not jumpdefault then jumpdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')end
if not MaxAccelerationdefault then MaxAccelerationdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')end
if not AirControldefault then AirControldefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')end
[ENABLE]
jumpmuti=createHotkey(function()jumpmultiplier=jumpmultiplier+0.5 end,VK_NUMPAD1)
jump = createTimer()
jump.setInterval(1000)
jump.OnTimer = function()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')
local address2=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')
local address3=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')
if address then writeFloat(address,jumpdefault*jumpmultiplier)
writeFloat(address2,MaxAccelerationdefault*jumpmultiplier)
writeFloat(address3,AirControldefault*jumpmultiplier)
end
end
[DISABLE]
jump.destroy()
jumpmuti.destroy()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')
local address2=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')
local address3=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')
if address then writeFloat(address,jumpdefault)
writeFloat(address2,MaxAccelerationdefault)
writeFloat(address3,AirControldefault)
end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>97</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>96</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26155</ID>
                  <Description>"WalkSpeed Multiplier                             Numpad2 :Deactive, Numpad3 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
walkmultiplier=1
if syntaxcheck then return end
if not walkdefault then walkdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')end
[ENABLE]
walkpmuti=createHotkey(function() walkmultiplier=walkmultiplier+0.5 end,VK_NUMPAD3)
walk = createTimer()
walk.setInterval(1000)
walk.OnTimer = function()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')
if address then writeFloat(address,walkdefault*walkmultiplier)end
end
[DISABLE]
walk.destroy()
walkpmuti.destroy()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')
if address then writeFloat(address,walkdefault)end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>99</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>98</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26156</ID>
                  <Description>"UWorld"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>GameViewportClient.World</Offset>
                    <Offset>GameEngine.GameViewport</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>26157</ID>
                  <Description>"Player"</Description>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>PlayerController.Character</Offset>
                    <Offset>LocalPlayer.PlayerController</Offset>
                    <Offset>0</Offset>
                    <Offset>GameInstance.LocalPlayers</Offset>
                    <Offset>GameEngine.GameInstance</Offset>
                  </Offsets>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26158</ID>
                      <Description>"CharacterMovement"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <GroupHeader>1</GroupHeader>
                      <Address>+GPlayer.CharacterMovement</Address>
                      <Offsets>
                        <Offset>0</Offset>
                      </Offsets>
                      <CheatEntries>
                        <CheatEntry>
                          <ID>26159</ID>
                          <Description>"JumpZVelocity"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.JumpZVelocity</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26160</ID>
                          <Description>"MaxWalkSpeed"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxWalkSpeed</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26161</ID>
                          <Description>"MaxWalkSpeedCrouched"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxWalkSpeedCrouched</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26162</ID>
                          <Description>"MaxAcceleration"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxAcceleration</Address>
                        </CheatEntry>
                      </CheatEntries>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>26163</ID>
              <Description>"Tools"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>26164</ID>
                  <Description>"FNamePool scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function stringscan(value,modulename,stopaddress,isUnicode)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtString,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,isUnicode,true)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress,value2)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  if type(modulename)==type(0) then modulename=string.format('%X',modulename)
  elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
  if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
    stopaddress=getNameFromAddress(getAddress(modulename),true,false)
    if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
	if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
    modulename=getAddress([["]]..stopaddress..[["]])
	stopaddress=modulename+getModuleSize(stopaddress)
    modulename=string.format('%X',modulename)
  end
  if type(stopaddress)==type(0) then stopaddress=string.format('%X',stopaddress)end
  print(modulename..'~'..stopaddress)
  if value2 then ms.firstScan(soValueBetween,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  else ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)end
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end


print('------------------')
local isUnicode=false
local strlist,result,result2,result3,pointer1,pointer2,pointer3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  result=stringscan('IntProperty',getAddressSafe(strlist[i]),getAddressSafe(strlist[i]..'+50'),isUnicode)
  if #result&gt;0 then
    result=stringscan('None',getAddressSafe(strlist[i]..'-50'),getAddressSafe(strlist[i]),isUnicode)
    print(strlist[i])
    if #result&gt;0 then
      if string.sub(strlist[i],strlist[i]:len()-3,strlist[i]:len()-2)=='00' then
        result=pointerscan(getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00'))
        for j=1,#result do
          pointer1=readPointer(result[j]..(targetIs64Bit() and '+8' or '+4'))
          pointer1=readPointer(pointer1)
          pointer2=readPointer(result[j]..(targetIs64Bit() and '+10' or '+8'))
          pointer2=readPointer(pointer2)
          pointer3=readPointer(result[j]..(targetIs64Bit() and '+18' or '+C'))
          pointer3=readPointer(pointer3)

          if pointer1 and pointer2 and pointer3 then
            print(strlist[i]..'&lt;-'..result[j])
            unregisterSymbol('FNamePool')
            registerSymbol('FNamePool',result[j]..'-10',true)
            if ue4versioncheck()&lt;=2 then UE4ver=23 end

            if string.sub(result[j],result[j]:len()-1,result[j]:len())=='00' then
              result2=pointerscan(getAddressSafe(result[j]))
              for k=1,#result2 do
                print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
                result3=pointerscan(getAddressSafe(result2[k]),getAddress(process),getAddress(process)+getModuleSize(process))
                for l=1,#result3 do
                  print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l])
                  unregisterSymbol('FNamePool')
                  registerSymbol('FNamePool',result3[l],true)
                  if ue4versioncheck()&lt;=2 then UE4ver=22 end
                  goto done
                end
              end
            end
          end
        end
      end
    end
  end
end
::done::
print('done')

[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26165</ID>
                  <Description>"FNamePool scanner V2"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function stringscan(value,modulename,stopaddress,isUnicode)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtString,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,isUnicode,true)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress,value2)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  if type(modulename)==type(0) then modulename=string.format('%X',modulename)
  elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
  if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
    stopaddress=getNameFromAddress(getAddress(modulename),true,false)
    if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
	if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
    modulename=getAddress([["]]..stopaddress..[["]])
	stopaddress=modulename+getModuleSize(stopaddress)
    modulename=string.format('%X',modulename)
  end
  if type(stopaddress)==type(0) then stopaddress=string.format('%X',stopaddress)end
  print(modulename..'~'..stopaddress)
  if value2 then ms.firstScan(soValueBetween,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  else ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)end
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end



print('------------------')
local isUnicode=false
local strlist,result,result2,result3,pointer1,pointer2,pointer3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  result=stringscan('IntProperty',getAddressSafe(strlist[i]),getAddressSafe(strlist[i]..'+50'),isUnicode)
  if #result&gt;0 then
    result=stringscan('None',getAddressSafe(strlist[i]..'-50'),getAddressSafe(strlist[i]),isUnicode)
    print(strlist[i])
    if #result&gt;0 then
      if string.sub(strlist[i],strlist[i]:len()-3,strlist[i]:len()-2)=='00' then
        result=pointerscan(getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00'),nil,nil,getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00')+0x50)
        for j=1,#result do
          pointer1=readPointer(result[j]..(targetIs64Bit() and '+8' or '+4'))
          pointer1=readPointer(pointer1)
          pointer2=readPointer(result[j]..(targetIs64Bit() and '+10' or '+8'))
          pointer2=readPointer(pointer2)
          pointer3=readPointer(result[j]..(targetIs64Bit() and '+18' or '+C'))
          pointer3=readPointer(pointer3)

          if pointer1 and pointer2 and pointer3 then
            print(strlist[i]..'&lt;-'..result[j])
            unregisterSymbol('FNamePool')
            registerSymbol('FNamePool',result[j]..'-10',true)
            if ue4versioncheck()&lt;=2 then UE4ver=23 end

            --if string.sub(result[j],result[j]:len()-1,result[j]:len())=='00' then
              result2=pointerscan(getAddressSafe(result[j]))
              for k=1,#result2 do
                print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
                if inModule(result2[k]) then UE4ver=ue4versioncheck() unregisterSymbol('FNamePool') registerSymbol('FNamePool',result2[k],true) goto done end
                result3=pointerscan(getAddressSafe(result2[k]),getAddress(process),getAddress(process)+getModuleSize(process))
                for l=1,#result3 do
                  print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l])
                  unregisterSymbol('FNamePool')
                  registerSymbol('FNamePool',result3[l],true)
                  if ue4versioncheck()&lt;=2 then UE4ver=22 end
                  goto done
                end
              end
            --end
          end
        end
      end
    end
  end
end
::done::
print('done')

[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26166</ID>
                  <Description>"FNamePool scanner V3"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function stringscan(value,modulename,stopaddress,isUnicode)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtString,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,isUnicode,true)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress,value2)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  if type(modulename)==type(0) then modulename=string.format('%X',modulename)
  elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
  if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
    stopaddress=getNameFromAddress(getAddress(modulename),true,false)
    if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
	if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
    modulename=getAddress([["]]..stopaddress..[["]])
	stopaddress=modulename+getModuleSize(stopaddress)
    modulename=string.format('%X',modulename)
  end
  if type(stopaddress)==type(0) then stopaddress=string.format('%X',stopaddress)end
  print(modulename..'~'..stopaddress)
  if value2 then ms.firstScan(soValueBetween,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  else ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)end
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end



print('------------------')
local isUnicode=true
local strlist,result,result2,result3,pointer1,pointer2,pointer3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  print(strlist[i])
  result=pointerscan(getAddress(strlist[i])-0x50,nil,nil,getAddress(strlist[i]))
  for j=1,#result do
    if string.sub(result[j],result[j]:len()-3,result[j]:len()-2)=='00' then
      print(result[j])
      pointer1=readPointer(result[j]..(targetIs64Bit() and '+8' or '+4'))
      pointer1=readPointer(pointer1)
      pointer2=readPointer(result[j]..(targetIs64Bit() and '+10' or '+8'))
      pointer2=readPointer(pointer2)
      pointer3=readPointer(result[j]..(targetIs64Bit() and '+18' or '+C'))
      pointer3=readPointer(pointer3)
      if pointer1 and pointer2 and pointer3 then
         print(strlist[i]..'&lt;-'..result[j])
         result2=pointerscan(getAddressSafe(string.sub(result[j],1,result[j]:len()-2)..'00'))
         for k=1,#result2 do
           print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
           if inModule(result2[k]) then UE4ver=ue4versioncheck() unregisterSymbol('FNamePool') registerSymbol('FNamePool',result2[k],true) goto done end

         end
      end
    end
  end
end
::done::
print('done')
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26167</ID>
                  <Description>"FNamePool scanner V4"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function stringscan(value,modulename,stopaddress,isUnicode)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  ms.firstScan(soExactValue,vtString,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,isUnicode,true)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress,value2)
  local ms = createMemScan()
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  if type(modulename)==type(0) then modulename=string.format('%X',modulename)
  elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
  if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
    stopaddress=getNameFromAddress(getAddress(modulename),true,false)
    if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
	if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
    modulename=getAddress([["]]..stopaddress..[["]])
	stopaddress=modulename+getModuleSize(stopaddress)
    modulename=string.format('%X',modulename)
  end
  if type(stopaddress)==type(0) then stopaddress=string.format('%X',stopaddress)end
  print(modulename..'~'..stopaddress)
  if value2 then ms.firstScan(soValueBetween,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  else ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)end
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end



print('------------------')
local isUnicode=false
local size= targetIs64Bit() and 8 or 4
local result2,result,result3,result4,pointer1,pointer2,pointer3,tempstringoffset,str,tempfnamepooloffset=stringscan('ByteProperty',nil,nil,isUnicode)
for i=1,#result2 do
--print(result2[i])
  result=pointerscan(getAddress(result2[i]..'-50'),nil,nil,getAddress(result2[i]))

  for j=1,#result do
    tempstringoffset=getAddress(result2[i])-readPointer(getAddress(result[j]))

    for k=size,0x50,4 do
      str=readString(readPointer(getAddress(result[j])+k)+tempstringoffset,0x30,isUnicode)
      if str and str=='IntProperty' then
        stringoffset=tempstringoffset
        print(result2[i]..'&lt;-'..result[j])

        result3=pointerscan(getAddress(result[j]..'-50')-k,nil,nil,getAddress(result[j]))
        for m=1,#result3 do
          --print(result2[i]..'&lt;-'..result[j]..'&lt;-'..result3[m])
          stringoffset2=((getAddress(result[j])-readPointer(result3[m])+size)/2)-size
          --print(string.format('%X',((getAddress(result[j])-readPointer(result3[m])+size)/2)-size))
          stringmul=k
          --[[
          pointer1=readPointer(result3[m]..(targetIs64Bit() and '+8' or '+4'))
          pointer1=readPointer(pointer1)
          pointer2=readPointer(result3[m]..(targetIs64Bit() and '+10' or '+8'))
          pointer2=readPointer(pointer2)
          pointer3=readPointer(result3[m]..(targetIs64Bit() and '+18' or '+C'))
          pointer3=readPointer(pointer3)

          if pointer1 and pointer2 and pointer3 then
            print(result2[i]..'&lt;-'..result[j]..'&lt;-'..result3[m])
          end]]
          result4=pointerscan(getAddress(result3[m])-0x100,process,nil,getAddress(result3[m]))
          for n=1,#result4 do
            print(result2[i]..'&lt;-'..result[j]..'&lt;-'..result3[m]..'&lt;-'..result4[n])
            unregisterSymbol('FNamePool') registerSymbol('FNamePool',result4[n],true)
            goto done
          end
        end
      end
    end
  end
end
::done::
print('done')



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26168</ID>
                  <Description>"UE4 Object scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}

if syntaxcheck then return end

[ENABLE]
--unregisterSymbol('FNamePool')
--registerSymbol('FNamePool','libUE4.so+41DE8A4',true)
--UE4ver=nil
--if not UE4ver then ue4versioncheck()end
--ue4config()
--ue4parsetable()
ue4parsetableFNamePool()

FNameStringAlgo(1,true)
FNameStringAlgo(3,true)
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

Aligned=true
function ue4parsetablecheck()
end


local Object=FindStringFName('Object')
local Class=FindStringFName('Class')
local CoreUObject=FindStringFName('/Script/CoreUObject')
if not UObject then  UObject = {} end
print(Object)
print(Class)
print(CoreUObject)
local size,pointer,pointer2,pointer3=(targetIs64Bit() and 8 or 4)
local result,result2=groupscan('4:'..Object)
print(#result)
for i=1,#result do
  if checkvalue(getAddress(result[i])-0x50,0x50,1,4)then
    for j=0,0x100,size do
      pointer=readPointer(getAddress(result[i])-0x50+j)
      if not pointer then break end
      if checkvalue(pointer,0x50,Class,4) then
        pointer3=pointer
        for k=0,0x100,size do
          local pointer=readPointer(getAddress(result[i])-0x50+k)
          if not pointer then break end
          if checkvalue(pointer,0x50,CoreUObject,4)then

            --print(result[i])
            local value=targetIs64Bit() and readInteger(pointer+4) or readSmallInteger(pointer+2)
            --print(string.format('%X',readInteger(pointer)))

            if targetIs64Bit() then pointer2=checkvalue(getAddress(result[i])-0x50,0x50,value,(size/2))
            else
              for p=0,10 do
                if pointer2 then break end
                pointer2=checkvalue(getAddress(result[i])-0x50,0x50,value-5+p,(size/2))
              end
            end
            if pointer2 then
              pointer2=pointer2-(size/2)
              print(string.format('%X',pointer2))

              UObject.ObjectId=checkvalue(pointer2,0x50,1,4)-pointer2
              UObject.Class=checkvalue(pointer2,0x50,pointer3,size)-pointer2
              UObject.FNameIndex=checkvalue(pointer2,0x50,Object,4)-pointer2
              UObject.Outer=checkvalue(pointer2,0x50,pointer,size)-pointer2

              local str
              if UE4ver&lt;9 and targetIs64Bit() then
                str=string.format('8:0x%X 8:0x%X',pointer,pointer2)
              elseif UE4ver&lt;9 then
                str=string.format('4:0x%X 4:0x%X',pointer,pointer2)
              elseif targetIs64Bit() then
                str=string.format('8:0x%X 8:* 8:* 8:0x%X',pointer,pointer2)
              else
                str=string.format('4:0x%X 4:* 4:* 4:* 4:0x%X',pointer,pointer2)
              end
              print(str)
              result2=groupscan(str)
              for n=1,#result2 do
                local result3
                if not Aligned or getAddress(result2[n])%size==0 then
                  print(string.format('%X&lt;-%s',pointer2,result2[n]))
                  --result3=pointerscan(getAddress(result2[n]:sub(1,result2[n]:len()-2)..'00'))
                end
                if not result3 or #result3&lt;=0 then result3=pointerscan(getAddress(result2[n]))end
                for o=1,#result3 do
                  local result4
                  if not Aligned or getAddress(result3[o])%size==0 then

                    --if not inModule(result3[o]) then
                      print(string.format('%X&lt;-%s&lt;-%s',pointer2,result2[n],result3[o]))

                    --end

                    if inModule(result3[o]) and (readInteger(result3[o]..'-10+1C')&lt;0x7FFFFF or readInteger(result3[o]..'-10+24')&lt;0x7FFFFF) then
                      unregisterSymbol('GUObjectArray')
                      registerSymbol('GUObjectArray',result3[o]..'-10',true)
                      goto done
                    end

                    result4=pointerscan(getAddress(result3[o]))


                  end
                  if not result4 then result4={}end
                  for q=1,#result4 do
                    if not Aligned or getAddress(result4[q])%size==0 then
                      print(string.format('%X&lt;-%s&lt;-%s&lt;-%s',pointer2,result2[n],result3[o],result4[q]))

                      if inModule(result4[q]) then
                        unregisterSymbol('GUObjectArray')
                        registerSymbol('GUObjectArray',result4[q]..'-10',true)
                        goto done
                      end

                    end
                  end
                end
              end
            end
          end
        end
      end
    end
  end
end
::done::

if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
  if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
  else UE4ver=20 end
end

print('done\n')

ue4parsetable() 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26169</ID>
                  <Description>"UE4 Object scanner V2"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}

if syntaxcheck then return end

[ENABLE]
--unregisterSymbol('FNamePool')
--registerSymbol('FNamePool','libUE4.so+41DE8A4',true)
--UE4ver=nil
--if not UE4ver then ue4versioncheck()end
--ue4config()
--ue4parsetable()
ue4parsetableFNamePool()

FNameStringAlgo(1,true)
FNameStringAlgo(3,true)
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

Aligned=true
function ue4parsetablecheck()
end


local Object=FindStringFName('Object')
local Class=FindStringFName('Class')
local CoreUObject=FindStringFName('/Script/CoreUObject')
if not UObject then  UObject = {} end
print(Object)
print(Class)
print(CoreUObject)
local size,pointer,pointer2,pointer3=(targetIs64Bit() and 8 or 4)
local result,result2=groupscan('4:'..Object)
print(#result)
for i=1,#result do
  if checkvalue(getAddress(result[i])-0x50,0x50,1,4)then
    for j=0,0x100,size do
      pointer=readPointer(getAddress(result[i])-0x50+j)
      if not pointer then break end
      if checkvalue(pointer,0x50,Class,4) then
        pointer3=pointer
        for k=0,0x100,size do
          local pointer=readPointer(getAddress(result[i])-0x50+k)
          if not pointer then break end
          if checkvalue(pointer,0x50,CoreUObject,4)then

            --print(result[i])
            local value=targetIs64Bit() and readInteger(pointer+4) or readSmallInteger(pointer+2)
            --print(string.format('%X',readInteger(pointer)))

            if targetIs64Bit() then pointer2=checkvalue(getAddress(result[i])-0x50,0x50,value,(size/2))
            else
              for p=0,10 do
                if pointer2 then break end
                pointer2=checkvalue(getAddress(result[i])-0x50,0x50,value-5+p,(size/2))
              end
            end
            if pointer2 then
              pointer2=pointer2-(size/2)
              print(string.format('%X',pointer2))

              UObject.ObjectId=checkvalue(pointer2,0x50,1,4)-pointer2
              UObject.Class=checkvalue(pointer2,0x50,pointer3,size)-pointer2
              UObject.FNameIndex=checkvalue(pointer2,0x50,Object,4)-pointer2
              UObject.Outer=checkvalue(pointer2,0x50,pointer,size)-pointer2

              local str

              for p=4,0,-1 do
                str=string.format('%u:0x%X',size,pointer)
                for q=1,p do
                  str=str..' 4:*'
                end
                str=str..string.format(' %u:0x%X',size,pointer2)
                UObjectMul=(4*p)+size

                print(str)


                result2=groupscan(str)
                for n=1,#result2 do
                  local result3
                  if result2[n]:sub(result2[n]:len()-1,result2[n]:len())=='00' then
                    print(string.format('%X&lt;-%s',pointer2,result2[n]))
                    result3=pointerscan(getAddress(result2[n]))
                  end
                  if not result3  then result3={}end
                  for o=1,#result3 do
                    local result4
                    if not Aligned or getAddress(result3[o])%size==0 then
                      --if not inModule(result3[o]) then
                        print(string.format('%X&lt;-%s&lt;-%s',pointer2,result2[n],result3[o]))
                      --end
                      if inModule(result3[o]) and (readInteger(result3[o]..'-10+1C')&lt;0x7FFFFF or readInteger(result3[o]..'-10+24')&lt;0x7FFFFF) then
                        unregisterSymbol('GUObjectArray')
                        registerSymbol('GUObjectArray',result3[o]..'-10',true)
                        result4=pointerscan(getAddress(result3[o]..'-10'),process)
                        if result4[1] then
                          print(string.format('%X&lt;-%s&lt;-%s&lt;-%s',pointer2,result2[n],result3[o],result4[1]))
                          unregisterSymbol('GUObjectArray')
                          registerSymbol('GUObjectArray',result4[1],true)
                        end
                        goto done
                      end
                      result4=pointerscan(getAddress(result3[o]))
                    end
                    if not result4 then result4={}end
                    for q=1,#result4 do
                      if not Aligned or getAddress(result4[q])%size==0 then
                        print(string.format('%X&lt;-%s&lt;-%s&lt;-%s',pointer2,result2[n],result3[o],result4[q]))
                        if inModule(result4[q]) then
                          unregisterSymbol('GUObjectArray')
                          registerSymbol('GUObjectArray',result4[q]..'-10',true)

                          goto done
                        end
                      end
                    end
                  end
                end
              end

            end
          end
        end
      end
    end
  end
end
::done::

if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
  if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
  elseif readInteger('GUObjectArray+14')==0 then UE4ver=9
  else UE4ver=20 end
end

print('done\n')

ue4parsetable() 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26170</ID>
                  <Description>"UE4 Auto config"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end

[ENABLE]
if not UObject then UObject = {} end
local size,pointer,pointers=(targetIs64Bit() and 8 or 4)
local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
local GameEngine=StaticFindObjectAlgo('/Script/Engine.GameEngine')
local Engine=StaticFindObjectAlgo('/Script/Engine.Engine')
print(string.format('GameEngine = %X',GameEngine))
print(string.format('Engine = %X\n',Engine))
UObject.super=checkvalue(GameEngine,0x100,Engine,size)-GameEngine
local Name,Typ
for i=GameEngine,GameEngine+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Property ') then pointer=readPointer(i) UObject.member=i-GameEngine break end
end
Typ=Name:sub(1,string.find(Name,' ')-1)

UObject.propsize=checkvalue(pointer,0x100,varsize[ue4type[Typ]],4)-pointer
local classsize=readInteger(UObject.member+size+GameEngine)
UObject.Offset=checkvalue(pointer,0x100,tostring(classsize-0x100)..'~'..tostring(classsize),4)-pointer

for i=pointer,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Property ') then UObject.nextmember=i-pointer break end
end

pointer=readPointer(Engine+UObject.member)
for i=pointer+UObject.nextmember,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Class ') then UObject.Property=i-pointer break end
end

UObject.bitmask=UObject.Property+2

pointer=StaticFindObjectAlgo('/Script/CoreUObject.Object:ExecuteUbergraph')
print(string.format('ExecuteUbergraph = %X\n',pointer))

for i=pointer+UObject.Property,pointer+0x100,size do
  if inModule(readPointer(i)) then UObject.funct=i-pointer break end
end

pointer=StaticFindObjectAlgo('/Script/CoreUObject.EInterpCurveMode')
print(string.format('EInterpCurveMode = %X\n',pointer))
for j=size,0x50,size do
  pointers=readPointer(pointer+UObject.Outer+j)
      --pointers=readPointer(pointers)
  if pointers and checkvalue(pointers,0x50,'CIM_Linear',1) then
    UObject.enumoffset=UObject.Outer+j
    pointer=readPointer(pointer+UObject.enumoffset)
    print(string.format('EInterpCurveMode enums = %X\n',pointer))
    UObject.enumname=checkvalue(pointer,0x50,'CIM_Linear',1)-pointer
    UObject.enumindex=checkvalue(pointer,0x50,1,2) and checkvalue(pointer,0x50,1,2)-checkvalue(pointer,0x50,'CIM_CurveAuto',1) or 4
    for k=UObject.enumname+8,0x50,4 do
      if readInteger(pointer+k)&gt;4 and FNameStringAlgo(readInteger(pointer+k),true) then UObject.enummul=k break end
    end

    break
  end
end

print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
UObject.funct = 0x%X
UObject.enumoffset = 0x%X
UObject.enummul = 0x%X
UObject.enumname = 0x%X
UObject.enumindex = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask,UObject.funct,UObject.enumoffset,
UObject.enummul,UObject.enumname,
UObject.enumindex))
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26171</ID>
                  <Description>"UE3 Object scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}

if syntaxcheck then return end

[ENABLE]
UE4ver=ue4versioncheck()
--unregisterSymbol('FNamePool')
--registerSymbol('FNamePool','libUE4.so+41DE8A4',true)
--UE4ver=nil
--if not UE4ver then ue4versioncheck()end
--ue4config()
--ue4parsetable()
ue4parsetableFNamePool()

FNameStringAlgo(1,true)
FNameStringAlgo(3,true)
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

Aligned=true
function ue4parsetablecheck()
end


local Object=FindStringFName('Object',isMassEffect)
if not UObject then  UObject = {} end
print(Object)
local size,pointer,pointer1,pointer2,pointer3=(targetIs64Bit() and 8 or 4)
local result,result2=groupscan('4:'..Object)
print(#result)
for i=1,#result do
  pointer=getAddress(result[i])-0x50
  for j=0,0x100,4 do
    pointer1=checkvalue(readPointer(pointer+j),0x100,'Class',1)
    if pointer1 then
      for k=0,0x100,4 do
        pointer2=checkvalue(readPointer(pointer+k),0x100,'Core',1)
        if pointer2 then
          pointer1=pointer1-readPointer(pointer+j)
          pointer2=pointer2-readPointer(pointer+k)
          if pointer1==pointer2 then
            pointer=getAddress(result[i])-pointer1
            print(string.format('%X',pointer))
            for l=1,3 do
              pointer3=checkvalue(pointer+size,0x100,l,4)
              if pointer3 then print(l)
                UObject.ObjectId=pointer3-pointer
                UObject.FNameIndex=pointer1
                UObject.Class=pointer1+j-0x50
                UObject.Outer=pointer1+k-0x50

                result2=pointerscan(pointer)
                for m=1,#result2 do
                  local val=0
                  for o=1,100 do
                    val=o
                    if not readPointer(readPointer(readPointer(getAddress(result2[m])+o*size))) then break end
                  end

                  if val==100 then
                    print(string.format('%X',getAddressSafe(result2[m])-(size*l)))
                    result=pointerscan(getAddressSafe(result2[m])-(size*l),process)
                    unregisterSymbol('GUObjectArray')
                    registerSymbol('GUObjectArray',getAddressSafe(result2[m])-(size*l),true)
                    NOGUObjectsize=true

                    for n=1,#result do
                      print(result2[m]..'&lt;-'..result[n])
                      if inModule(result[n]) and getAddress(result[n])%4==0 then
                        unregisterSymbol('GUObjectArray')
                        registerSymbol('GUObjectArray',result[n],true)
                        NOGUObjectsize=nil
                        goto done
                      end
                    end
                  end
                  if m==#result2 then goto done end
                end
              end
            end
          end
        end
      end
    end
  end
end
::done::
--[[
if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
  if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
  elseif readInteger('GUObjectArray+14')==0 then UE4ver=9
  else UE4ver=20 end
end
]]

ue4parsetable()
print('done\n')
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26172</ID>
                  <Description>"UE3 Auto config"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end

[ENABLE]

if not UObject then UObject = {} end
local size,pointer,pointers=(targetIs64Bit() and 8 or 4)
local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
local GameEngine=StaticFindObjectAlgo('Engine.GameEngine')
local Engine=StaticFindObjectAlgo('Engine.Engine')
print(string.format('GameEngine = %X',GameEngine))
print(string.format('Engine = %X\n',Engine))
UObject.super=checkvalue(GameEngine,0x100,Engine,size)-GameEngine
local Name,Typ
for i=GameEngine+UObject.Outer,GameEngine+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and (string.find(Name,'Function ') or string.find(Name,'Property ')) then pointer=readPointer(i) UObject.member=i-GameEngine break end
end

for i=UObject.Outer+size,0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(pointer+i))
  if Name and  (string.find(Name,'Property ') or string.find(Name,'Function ') or string.find(Name,'Struct ')) and not string.find(Name,'Core') then
    Name=GetFullNameSafeAlgo(readPointer(readPointer(pointer+i)+i))
      if Name and  (string.find(Name,'Property ') or string.find(Name,'Function ') or string.find(Name,'Struct ')) and not string.find(Name,'Core') then
        UObject.nextmember=i break
      end
  end
end

for i=0,100 do
  pointer=readPointer(UObject.nextmember+pointer)
  Name=GetFullNameSafeAlgo(pointer)
  --print(Name)
  if Name and string.find(Name,'ObjectProperty ') then break end
end

Typ=Name:sub(1,string.find(Name,' ')-1)
--print(string.format('%X = %s',pointer,GetFullNameSafeAlgo(pointer)))

UObject.propsize=checkvalue(pointer,0x100,varsize[ue4type[Typ]],2)-pointer
local classsize=readInteger(UObject.member+size+GameEngine)

UObject.Offset=checkvalue(pointer,0x100,tostring(classsize-0x200)..'~'..tostring(classsize),4)-pointer


--pointer=readPointer(Engine+UObject.member)
for i=pointer+UObject.nextmember,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Class ') then UObject.Property=i-pointer break end
end

UObject.bitmask=UObject.Property+2

pointer=StaticFindObjectAlgo('Core.Object:FindObject')
print(string.format('FindObject = %X\n',pointer))
for i=pointer+UObject.ObjectId,pointer+0x100,4 do
  if inModule(readPointer(i)) then UObject.funct=i-pointer break end
end

pointer=StaticFindObjectAlgo('Core.Object.EInterpCurveMode')
print(string.format('EInterpCurveMode = %X\n',pointer))
for i=size,0x50,size do
  pointers=readPointer(pointer+UObject.Outer+i)
  pointers=readPointer(pointers)
  if pointers then
    for j=size,0x50,size do
      pointers=readPointer(pointer+UObject.Outer+i+j)
      --pointers=readPointer(pointers)
      if pointers and checkvalue(pointers,0x50,'CIM_Linear',1) then
        UObject.enumoffset=UObject.Outer+i+j
        pointer=readPointer(pointer+UObject.enumoffset)
        UObject.enumname=0--checkvalue(pointer,0x50,FindStringFName('CIM_Linear'),4)-pointer
        UObject.enumindex=4--checkvalue(pointer,0x50,1,4)-checkvalue(pointer,0x50,FindStringFName('CIM_CurveAuto'),4)
        UObject.enummul=8--checkvalue(pointer,0x50,2,4)-checkvalue(pointer,0x50,1,4)
        break
      end
    end
    break
  end
end


print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
UObject.funct = 0x%X
UObject.enumoffset = 0x%X
UObject.enummul = 0x%X
UObject.enumname = 0x%X
UObject.enumindex = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask,UObject.funct,UObject.enumoffset,
UObject.enummul,UObject.enumname,
UObject.enumindex))
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26173</ID>
                  <Description>"to Single Line Address"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
function toStr(rec)
  local tec,str,list=rec,'',{}
  while(true)do
    if not tec or not tec.Address then break end
    list[#list+1]=tec
    tec=tec.Parent
  end
  for i=#list,1,-1 do
    str=string.format('%s%s',str,list[i].Address)
    for j=list[i].OffsetCount-1,0,-1 do
      str=string.format('[%s]+%s',str,list[i].OffsetText[j])
    end
  end
  return str
end

if syntaxcheck then return end
[ENABLE]

memrec.Child[0].Address=toStr(memrec.Child[0]) memrec.Child[0].OffsetCount=0
 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26174</ID>
                  <Description>"to Structural Address"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
function toStr(rec)
  local tec,str,list=rec,'',{}
  while(true)do
    if not tec or not tec.Address then break end
    list[#list+1]=tec
    tec=tec.Parent
  end
  for i=#list,1,-1 do
    str=string.format('%s%s',str,list[i].Address)
    for j=list[i].OffsetCount-1,0,-1 do
      str=string.format('[%s]+%s',str,list[i].OffsetText[j])
    end
  end
  return str
end

function toStructural(rec)
  local str,str2,list=toStr(rec),'',{}
  if str:find(']') then str2=str:sub(1,str:find(']')-1):gsub('%[','')
  else str2=str end
  rec.Address=str2
  while(true)do
    if not str:find(']') then break end
    str=str:sub(str:find(']')+2,str:len())
    if str:find(']') then str2=str:sub(1,str:find(']')-1):gsub('%[','')
    else str2=str end
    list[#list+1]=str2
  end
  rec.OffsetCount=#list+1
  for i=#list,1,-1 do
    rec.OffsetText[#list-i]=list[i]
  end
end

if syntaxcheck then return end
[ENABLE]

toStructural(memrec.Child[0])
 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26175</ID>
                  <Description>"DissectCode (Memory View -&gt; Ctrl+J or (Tools -&gt; Dissect code) )"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26176</ID>
                      <Description>"Save DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
getDissectCode().saveToFile(path)
--getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>26177</ID>
                      <Description>"Load DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
--getDissectCode().saveToFile(path)
getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>26178</ID>
          <Description>"Dumper V6.6"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>26179</ID>
              <Description>"Unreal Engine"</Description>
              <Options moHideChildren="1"/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
function ue4config()
 local sub=targetIs64Bit() and 0 or 4
 UObject = {}

 --if UE4ver&lt;=2 and targetIs64Bit() then ue4determineversion() end
-----------------------------
----------UE4 struct---------
 if UE4ver&gt;2 then

    UObject.ObjectId= 0xC-sub
    UObject.Class = 0x10-sub
    UObject.FNameIndex = 0x18-(sub*2)
    UObject.Outer = 0x20-(sub*2)

  if UE4ver&gt;=25 then
    UObject.super= 0x40
    UObject.member= 0x50
    UObject.nextmember= 0x20
    UObject.Offset= 0x4C
    UObject.propsize=0x3C
    UObject.bitmask= 0x7A
    UObject.funct= 0xD8
    UObject.Property= 0x78
    UObject.enumoffset = 0x40
    UObject.enummul = 0x10
    UObject.enumname = 0x0
    UObject.enumindex = 0x8

  elseif UE4ver&gt;=22 then
    UObject.super= 0x40
    UObject.member= 0x48
    UObject.funct= 0xC0
  else
    UObject.super= 0x30 -(sub*4)
    UObject.member= 0x38 -(sub*5)
    UObject.funct= 0xB0
  end

  if UE4ver&lt;25 then
    UObject.nextmember=0x28-(sub*3)
    UObject.Offset= 0x44-(sub*4)
    UObject.propsize= 0x34-(sub*3/2)
    UObject.bitmask= 0x72-(sub*8)

    UObject.Property= 0x70-(sub*8)

  end

  if UE4ver&lt;11 then
    UObject.Offset= 0x4C
  end

----------------------------
---------UE3 struct---------
--1.25
--[[
 elseif UE4ver&gt;=1 then

    UObject.ObjectId= 0x4
    UObject.Outer = 0x14
    UObject.FNameIndex = 0x18
    UObject.Class = 0x20
    UObject.Offset= 0x48
    UObject.super= 0x34
    UObject.member= 0x38
    UObject.nextmember=0x28
    UObject.propsize= 0x30
    UObject.bitmask= 0x60
    UObject.Property= 0x58

]]
--0.10246
 else
 --[[
    UObject.ObjectId= 0x20
    UObject.Outer = 0x28
    UObject.FNameIndex = 0x2C
    UObject.Class = 0x34

    UObject.Offset= 0x60

    UObject.super= 0x48
    UObject.member= 0x4C

    UObject.nextmember=0x3C
    UObject.propsize= 0x44
    UObject.bitmask= 0x70]]

 end

---------------------------
end


ue4type={
		['BoolProperty']=vtByte,
		['ByteProperty']=vtByte,
		['FloatProperty']=vtSingle,
        ['StructProperty']=vtDword,
		['IntProperty']=vtDword,
        ['NameProperty']=vtQword,
        ['Int64Property']=vtQword,
		['TextProperty']=vtPointer,
        ['StrProperty']=vtPointer,
        ['ArrayProperty']=vtPointer,
        ['MapProperty']=vtPointer,
        ['ClassProperty']=vtPointer,
		['ObjectProperty']=vtPointer}

function ue4versioncheck()
 --if true then return 0 end
 local fileversion,info =getFileVersion(enumModules()[1].PathToFile)
 if not info then return 0 end
 return tonumber(info.minor..'.'..info.release)
end

function FNameStringAlgo(FName,IndexOnly)
 if not FName then return nil end
 local UEver=UE4ver
 local sub=targetIs64Bit() and 0 or 4
 local size=targetIs64Bit() and 8 or 4
 local number,str,pointer
 if not IndexOnly then
   number=UEver&gt;2 and readInteger(FName+4) or 0
   FName=readInteger(FName)
 else number=FName&gt;&gt;32 FName=FName&amp;0xFFFFFFFF
 end


 if not FName then return nil end

 if FNameList[FName] then
   if number&gt;0 then return FNameList[FName]..'_'..number-1 end
   return FNameList[FName]
 end

 local CFName=FName

 if readPointer(FNameString) then
   if not FNameStringStub then FNameStringStub=createExecuteCodeExStub(0,FNameString,0,0)end
   if not FNameStringRE then FNameStringRE=createRemoteExecutor()end

   if not mem then mem=allocateMemory(0x100)end
   writeQword(mem+0x50+UObject.FNameIndex,FName)
   FNameStringRE.executeStub(FNameStringStub,{mem+0x50,mem})
   str=readPointer(mem)
   if str then str=readString(str,readInteger(mem+0x8)*2,true) end
   --deAlloc(mem)

 elseif UEver&gt;=23 then
  local i=(FName&gt;&gt;0x10)
  FName=(FName&amp;0xFFFF)*2
  pointer=readPointer(FNamePool+i*size)

  local le =  readSmallInteger(pointer+FName)
  if not le then return nil end
  le=le&gt;&gt;6
  if le&gt;200 then return nil end
  local widechar=true and readBytes(pointer+FName,1)==1 or false
  --print(FName)
  le=(widechar and le*2 or le)-1
  if CFName==3 and not stringoffset then
    for k=2,0x20,2 do
      if readString(pointer+FName+k,le,widechar)=='ByteProperty' then stringoffset=k break end
      --print(k)
    end
  end

  if not stringoffset then return end

  str=readString(pointer+FName+stringoffset,le,widechar)
 else
  local i

  if isMassEffect then
    i=(FName&gt;&gt;0x1D)&amp;7
    FName=FName&amp;0x1FFFFFFF
  elseif FNamePool2 then FName= FName &lt;0x25A and readInteger(FName*4+FNamePool) or FName
  else
    i=UEver&gt;7 and (FName&gt;&gt;0xE) or 0
    FName= (UEver&gt;7 and (FName&amp;0x3FFF) or FName) *  (8-sub)
  end

  --print(i)
  --print(FName)


  local pointer
  if FNamePool2 then
    pointer=readPointer(FNamePool2)+FName
  else
    pointer=readPointer(FNamePool+i*size)
    if not readPointer(pointer) then return nil end
    pointer=readPointer(pointer+FName)
  end

  --print(string.format('%X',pointer))

  if not readPointer(pointer) then return nil end
  local pointers,pointers2=pointer
  if stringoffset2 then pointer=readPointer(pointer+stringoffset2)end
  pointers2=pointer

  --print(string.format('%X',pointer))

  --local offset=UE4ver&gt;=22 and 0xC-sub or 0x10-(sub*2)
  if CFName==1 and (not stringoffset or not stringoffsetid) then

     for k=0,0x30,4 do
        str=readString(pointer+k,13)
        if str=='ByteProperty' then stringoffset=k break end
      end

      if not stringoffset then
        for k=0,0x30,4 do
          str=readString(pointer+k,13*2,true)
          if str=='ByteProperty' then stringoffset=k forcewidechar=true break end
        end
      end

      pointer=pointers

     for j=0, stringoffset-4,4 do
       if readInteger(pointer+j)==2 then stringoffsetid=j end
     end
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
  --print(string.format('%X',offset))

  else
  if not stringoffset then return end
  --print(string.format('%X',pointer))

  pointer=pointers

  local widechar=stringoffsetid and (readInteger(pointer+stringoffsetid)&amp;1==1 or false) or false

  pointer=pointers2

  if stringoffset2 and not readPointer(pointer) then pointer=pointers+stringoffset2 end

  widechar= forcewidechar and true or widechar

  str= readString(pointer+stringoffset,200,widechar)

  if not str then str= readString(pointer+stringoffset,100,widechar) end
  if not str then str= readString(pointer+stringoffset,50,widechar) end
  if not str then str= readString(pointer+stringoffset,30,widechar) end
  if not str then
   local le=0
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
   while(true)do
    if le&gt;50 then break end
    if readBytes(pointer+stringoffset+le)==0 then break end
    le=le+1
   end
   str= readString(pointer+stringoffset,le)
  end
  --print(stringoffset)


 end end
 if not str then return nil end
 if number&gt;0 then return str..'_'..number-1 end
 --print(str)
 FNameList[CFName]=str
 --print(str)
 return str
end

function GetNameAlgo(object)
 if not object then return nil end

 if ObjectList[object] then --print(ObjectList[object])
   return ObjectList[object]
 end
 local pointer,size,str1,str2=readPointer(object+UObject.Class),targetIs64Bit() and 8 or 4
 if not pointer then return nil end
 --print(string.format('%X',fnameoffset))
 --print(string.format('%X',object+fnameoffset))
 str1=FNameStringAlgo(readInteger(pointer+UObject.FNameIndex),true)

 --print(str1)
 --if readInteger(pointer+fnameoffset+4)~=0 then return nil end

 str2=FNameStringAlgo(readInteger(object+UObject.FNameIndex),true)
 --print(str2)
 if not str2 then str2=FNameStringAlgo(readInteger(object+UObject.FNameIndex-8),true)end
 --if str2=='None' then str2=FNameStringAlgo(readInteger(pointer+UObject.Outer+size),true)end
 if not str1 or str1=='None' or not str2 or str2=='None' then return nil end


 str1=str1..' '..str2
 --print(ObjectList[object])
 ObjectList[object]=str1
 return str1
end

function GetFullNameAlgo(object)
 if not object then return nil end
 --if ObjectList[object] then return ObjectList[object] end
 local pathoffset=UObject.Outer
 local fnameoffset=UObject.FNameIndex
 local str=GetNameAlgo(object)
 if not str then return nil end
 local number=readInteger(object+fnameoffset+4)
 local typ=str:sub(1,string.find(str,' ')-1)
 local isProperty=string.find(typ,'Property')
 if not isProperty then isProperty=string.find(typ,'Function') end
 local pointer=readPointer(object+pathoffset)
 while(true)do
  if not pointer or pointer==0 then break end
  local stri=GetNameAlgo(pointer)
  if not stri then break end
  typ=stri:sub(1,string.find(stri,' ')-1)
  local isPropertyc=string.find(typ,'Property')
  if not isPropertyc then isPropertyc=string.find(typ,'Function') end
  stri=string.sub(str,1,string.find(str,' '))..stri:sub(string.find(stri,' ')+1,stri:len())
  local num=readInteger(pointer+fnameoffset+4)

  if number~=num and num==0 or  not isPropertyc and isProperty then stri=stri..':'
  else stri=stri..'.' end
  number=num
  isProperty=isPropertyc

  str=stri..string.sub(str,string.find(str,' ')+1,str:len())
  pointer=readPointer(pointer+pathoffset)

  if string.find(str,'%./') then
    stri=string.sub(str,1,string.find(str,' '))
    str=stri..str:sub(string.find(str,'%./')+1,str:len())
  break end

 end
 if not str then return nil end
 --ObjectList[object]=str
 return str
end

function GetFullNameSuperAlgo(object)
  local super=UObject.super
  local str1 = GetFullNameSafeAlgo(object)
  if not str1 then return nil end
  local pointer = readPointer(object+super)
  if pointer then
    local str2 = GetFullNameSafeAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function GetFullNameSafesAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 local str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end


function GetFullNameSafeAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local str= GetFullNameAlgo(object)
 if str then return str end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str3 then str3=GetFullNameSafesAlgo(pointer)end

 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end

function FindString(namestr,start,stop,isNoIndex)
  local acclen=0
  for i=start,stop do
    local name=FNameStringAlgo(i+acclen,true)
    if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
      --print(name)
      if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
        if namestr==name then FNameResult=i+acclen return end
        if isNoIndex then acclen=acclen+name:len()end
      end
    end
  end
end


function FindStringFName(namestr,isNoIndex)
  local size=targetIs64Bit() and 8 or 4
  if FNamePool2 then size=readInteger(FNamePool2+8)

  elseif UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
  elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
  else size=math.floor(#FNameDict[1]/size) end
  local count=0x200
  size=math.floor((size/count)+0.5)
  ue4parsetablecheck()
  FNameResult=nil
  local result
  local num,start,stop=count,0,0
  for i=0,size do
    start=i*num
    stop=(i+1)*num
    if FNameResult then break end
    createThread(FindString(namestr,start,stop-1,isNoIndex))
  end
  result=FNameResult
  FNameResult=nil
  return result
end

function hasProperty(object)
  local str1,str2
  str1=GetFullNameSafeAlgo(object)
  if not str1 then return nil end
  local pointer =readPointer(object+UObject.Property)
  if pointer then
    str2=GetFullNameSafeAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function printInheritC(class)
  for i=0,10 do
    if not class or class==0 then break end
    print(GetFullNameSuperAlgo(class))
    class=readPointer(class+UObject.super)
  end
end

function printInheritI(instance)
  instance=readPointer(instance+UObject.Class)
  printInheritC(instance)
end

function getregionsize(address)
local allregion=enumMemoryRegions()
 for i=#allregion,1,-1 do
  if allregion[i].BaseAddress&lt;=address then
   local BaseAddress=allregion[i].BaseAddress
   local RegionSize=allregion[i].RegionSize
   local curSize=BaseAddress+RegionSize-address
   return curSize,RegionSize,BaseAddress,i
  end
 end
end
--[[
function parsefrombig(tab,index,size)
 local datatable={}
 if not tab then return nil end
 for i=1,size do
  datatable[i]=tab[index+i]
 end
 return datatable
end
]]
sub=targetIs64Bit() and 0 or 4

function ue4parsetableFNamePool()
  ObjectList={}
  FNameList={}
  if readPointer(FNameString) or string.find(process,'StateOfDecay2')then return end
  local pool=getAddressSafe('FNamePool')
  if pool then
    local pointer,pointers
    if not readPointer(readPointer(pool)) then pointer=pool+0x10
    else
      pointer=pool
      if readPointer(readPointer(readPointer(pointer)))then
        if readPointer(readPointer(readPointer(readPointer(pointer))))then
          pointer=readPointer(pointer)
        end
      end
    end
    if not readPointer(pointer)then pointer=readPointer(pool2+0x10)end
    FNamePool=pointer
    FNameDict={}
    local j=0
    for i=0,500 do
      pointers=readPointer(pointer+i*(8-sub))
      if readPointer(pointers) then
        FNameDict[i+1]=readBytes(pointers,getregionsize(pointers)-1,true)
      else j=j+1 end
      if j&gt;5 then break end
    end
  end
end

function ue4parsetables()
 local size=targetIs64Bit() and 8 or 4
 ue4parsetableFNamePool()
 local pool2=getAddressSafe('GUObjectArray')
 if pool2 then
  if NOGUObjectsize then
    GUObjectsize=0xFFFFFFFF
    if not readPointer(readPointer(GUObjectAddress))then
      GUObjectAddress=allocateMemory(0x100) writePointer(GUObjectAddress,pool2)
    end
    return
  end


  local pointer,pointers=readPointer(pool2)
  GUObjectsize=readInteger(pool2+size)
  if not readPointer(pointer)then GUObjectsize=readInteger(pool2+0x10+size*2+4) GUObjectsize= GUObjectsize==0xFFFFFFFF and readInteger(pool2+0x10+size+4)or GUObjectsize  pointer=readPointer(pool2+0x10)end
  if not readPointer(readPointer(pointer)) then pointer=pointer+0x10 end
  --if GetFullNameSafeAlgo(readPointer(pointer)) then pointer=pool2 end
  if not readPointer(readPointer(readPointer(readPointer(readPointer(pointer))))) then pointer=pool2 end
  if not readPointer(readPointer(pointer)) then pointer=pointer+0x10 end
  GUObjectAddress=pointer
 end
end

function ue4parsetable()
  ue4parsetables()
  local size=targetIs64Bit() and 8 or 4

  local pointerss=readPointer(GUObjectAddress)
  for i=size,0x50,4 do
    if readPointer(pointerss+i) and readPointer(readPointer(readPointer(pointerss+i))) then UObjectMul=i print(string.format('%X',i))break end
  end

  if not UObject.FNameIndex then
    for i=0,3 do
      pointer = readPointer(pointerss+i*UObjectMul)
      if readPointer(pointer) and checkvalue(pointer+size,0x100,'Object',1) then
        UObject.FNameIndex=checkvalue(pointer+size,0x50,'Object',1)-pointer
        UObject.ObjectId=checkvalue(pointer+size,0x100,i,4)-pointer
        for j=size,0x100,4 do
          if checkvalue(readPointer(pointer+j),0x100,'Class',1) then UObject.Class=j break end
        end
        for j=size,0x100,4 do
          if checkvalue(readPointer(pointer+j),0x100,'Core',1) then UObject.Outer=j break end
        end
        break
      end
    end
  end
  return true
end


function ue4parsetablecheck()
  if not readPointer(GUObjectAddress) or not readPointer(FNamePool) then return ue4parsetable() end
  local pointer
  pointer=readPointer(readPointer(GUObjectAddress))
  if not ObjectTable or not ObjectTable[1] or (ObjectTable[1].Address ~= pointer) then return ue4parsetable() end

  local Address,FullName
  for i=1,#ObjectTable do
    if ObjectTable[i] and i&gt;#ObjectTable-0x10 then FullName=ObjectTable[i].Type..' '..ObjectTable[i].FullName Address=ObjectTable[i].Address  break end
  end

  if not GetFullNameSafeAlgo(Address) or FullName~=GetFullNameSafeAlgo(Address) then return ue4parsetable()end

 return false
end

function UE4AutoConfig()

if not UObject then UObject = {} end
local size,pointer,pointers=(targetIs64Bit() and 8 or 4)
local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
local GameEngine=StaticFindObjectAlgo('/Script/Engine.GameEngine')
local Engine=StaticFindObjectAlgo('/Script/Engine.Engine')
print(string.format('GameEngine = %X',GameEngine))
print(string.format('Engine = %X\n',Engine))
UObject.super=checkvalue(GameEngine,0x100,Engine,size)-GameEngine
local Name,Typ
for i=GameEngine,GameEngine+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Property ') then pointer=readPointer(i) UObject.member=i-GameEngine break end
end
Typ=Name:sub(1,string.find(Name,' ')-1)

UObject.propsize=checkvalue(pointer,0x100,varsize[ue4type[Typ]],4)-pointer
local classsize=readInteger(UObject.member+size+GameEngine)
UObject.Offset=checkvalue(pointer,0x100,tostring(classsize-0x100)..'~'..tostring(classsize),4)-pointer

for i=pointer,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Property ') then UObject.nextmember=i-pointer break end
end

pointer=readPointer(Engine+UObject.member)
for i=pointer+UObject.nextmember,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Class ') then UObject.Property=i-pointer break end
end

UObject.bitmask=UObject.Property+2

pointer=StaticFindObjectAlgo('/Script/CoreUObject.Object:ExecuteUbergraph')
print(string.format('ExecuteUbergraph = %X\n',pointer))

for i=pointer+UObject.Property,pointer+0x100,size do
  if inModule(readPointer(i)) then UObject.funct=i-pointer break end
end

pointer=StaticFindObjectAlgo('/Script/CoreUObject.EInterpCurveMode')
print(string.format('EInterpCurveMode = %X\n',pointer))
for j=size,0x50,size do
  pointers=readPointer(pointer+UObject.Outer+j)
      --pointers=readPointer(pointers)
  if pointers and checkvalue(pointers,0x50,'CIM_Linear',1) then
    UObject.enumoffset=UObject.Outer+j
    pointer=readPointer(pointer+UObject.enumoffset)
    print(string.format('EInterpCurveMode enums = %X\n',pointer))
    UObject.enumname=checkvalue(pointer,0x50,'CIM_Linear',1)-pointer
    UObject.enumindex=checkvalue(pointer,0x50,1,2) and checkvalue(pointer,0x50,1,2)-checkvalue(pointer,0x50,'CIM_CurveAuto',1) or 4
    for k=UObject.enumname+8,0x50,4 do
      if readInteger(pointer+k)&gt;4 and FNameStringAlgo(readInteger(pointer+k),true) then UObject.enummul=k break end
    end

    break
  end
end

print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
UObject.funct = 0x%X
UObject.enumoffset = 0x%X
UObject.enummul = 0x%X
UObject.enumname = 0x%X
UObject.enumindex = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask,UObject.funct,UObject.enumoffset,
UObject.enummul,UObject.enumname,
UObject.enumindex))

end

function UE3AutoConfig()


if not UObject then UObject = {} end
local size,pointer,pointers=(targetIs64Bit() and 8 or 4)
local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
local GameEngine=StaticFindObjectAlgo('Engine.GameEngine')
local Engine=StaticFindObjectAlgo('Engine.Engine')
print(string.format('GameEngine = %X',GameEngine))
print(string.format('Engine = %X\n',Engine))
UObject.super=checkvalue(GameEngine,0x100,Engine,size)-GameEngine
local Name,Typ
for i=GameEngine+UObject.Outer,GameEngine+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and (string.find(Name,'Function ') or string.find(Name,'Property ')) then pointer=readPointer(i) UObject.member=i-GameEngine break end
end

for i=UObject.Outer+size,0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(pointer+i))
  if Name and  (string.find(Name,'Property ') or string.find(Name,'Function ') or string.find(Name,'Struct ')) and not string.find(Name,'Core') then
    Name=GetFullNameSafeAlgo(readPointer(readPointer(pointer+i)+i))
      if Name and  (string.find(Name,'Property ') or string.find(Name,'Function ') or string.find(Name,'Struct ')) and not string.find(Name,'Core') then
        UObject.nextmember=i break
      end
  end
end

for i=0,100 do
  pointer=readPointer(UObject.nextmember+pointer)
  Name=GetFullNameSafeAlgo(pointer)
  --print(Name)
  if Name and string.find(Name,'ObjectProperty ') then break end
end

Typ=Name:sub(1,string.find(Name,' ')-1)
--print(string.format('%X = %s',pointer,GetFullNameSafeAlgo(pointer)))
print(string.format('%s = %X',Name,pointer))
UObject.propsize=checkvalue(pointer+UObject.Outer,0x100,varsize[ue4type[Typ]],2)-pointer
local classsize=readInteger(UObject.member+size+GameEngine)
if classsize==0 then classsize=UObject.Outer+0x200 end
print((classsize-0x200)..' ~ '..(classsize+0x1000))
UObject.Offset=checkvalue(pointer+UObject.propsize,0x50,tostring(classsize-0x200)..'~'..tostring(classsize+0x1000),2)-pointer


--pointer=readPointer(Engine+UObject.member)
for i=pointer+UObject.nextmember,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Class ') then UObject.Property=i-pointer break end
end

UObject.bitmask=UObject.Property+2

pointer=StaticFindObjectAlgo('Core.Object:FindObject')
print(string.format('FindObject = %X\n',pointer))
for i=pointer+UObject.ObjectId,pointer+0x100,4 do
  if inModule(readPointer(i)) then UObject.funct=i-pointer break end
end

pointer=StaticFindObjectAlgo('Core.Object.EInterpCurveMode')
print(string.format('EInterpCurveMode = %X\n',pointer))
for i=size,0x50,size do
  pointers=readPointer(pointer+UObject.Outer+i)
  pointers=readPointer(pointers)
  if pointers then
    for j=size,0x50,size do
      pointers=readPointer(pointer+UObject.Outer+i+j)
      --pointers=readPointer(pointers)
      if pointers and checkvalue(pointers,0x50,'CIM_Linear',1) then
        UObject.enumoffset=UObject.Outer+i+j
        pointer=readPointer(pointer+UObject.enumoffset)
        UObject.enumname=0--checkvalue(pointer,0x50,FindStringFName('CIM_Linear'),4)-pointer
        UObject.enumindex=4--checkvalue(pointer,0x50,1,4)-checkvalue(pointer,0x50,FindStringFName('CIM_CurveAuto'),4)
        UObject.enummul=8--checkvalue(pointer,0x50,2,4)-checkvalue(pointer,0x50,1,4)
        break
      end
    end
    break
  end
end


print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
UObject.funct = 0x%X
UObject.enumoffset = 0x%X
UObject.enummul = 0x%X
UObject.enumname = 0x%X
UObject.enumindex = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask,UObject.funct,UObject.enumoffset,
UObject.enummul,UObject.enumname,
UObject.enumindex))


end

function FindObject(pointer,start,stop,fullname)
  for j=start,stop do
    SaveObject(readPointer(pointer+j*UObjectMul))
    if FullNameList[fullname] then break end
  end
end

function StaticFindObjectAlgo(fullname)
  fullname=fullname:lower()
  if ue4parsetablecheck() then
    FullNameList={}
    ObjectLists={}
    ObjectTable={}
    HighestObjectID=0
  end
  if FullNameList[fullname] then return FullNameList[fullname].Address end

  local count=0x200
  local sizess= UObjectMul*count
  local ObjectId=UObject.ObjectId
  local num,start,stop
  totalobjects=0
  local size,pointer=targetIs64Bit() and 8 or 4

  for i=0,0x1000,size do
    pointer=readPointer(GUObjectAddress+i)
    if not readPointer(pointer) then break end
    size=getregionsize(pointer)
    num,start,stop=count,0,0
    for j=0,math.floor(size/sizess) do
      start=stop
      stop=stop+num
      --print(start..'~'..stop)

      createThread(FindObject(pointer,start,stop-1,fullname))
      if FullNameList[fullname] then return FullNameList[fullname].Address end
    end
  end
  return nil
end

function BasicObject(pointer,start,stop)
  Threadlist[#Threadlist+1]=i
  for j=start,stop do
    SaveObject(readPointer(pointer+j*UObjectMul))
  end
  Threadlist[#Threadlist]=nil
end

function BasicEnumObject()
  --ue4parsetablecheck()
  ObjectLists={}
  ObjectTable={}
  Threadlist={}
  FullNameList={}
  HighestObjectID=0
  local starttime=os.time()
  local count=0x200
  local sizess= UObjectMul*count
  local ObjectId=UObject.ObjectId
  local num,start,stop
  totalobjects=0
  local size,pointer=targetIs64Bit() and 8 or 4

  for i=0,0x1000,size do
    pointer=readPointer(GUObjectAddress+i)
    if not readPointer(pointer) then break end
    size=getregionsize(pointer)
    num,start,stop=count,0,0
    for j=0,math.floor(size/sizess) do
      start=stop
      stop=stop+num
      --print(start..'~'..stop)
      createThread(BasicObject(pointer,start,stop-1))
    end
  end
  for i=0,10000 do
    if #Threadlist==0 then break end
    sleep(1)
  end

  print(string.format('\nA Total of %u objects has been found in %u seconds',totalobjects,os.time()-starttime))
end

function registerFuncAlgo()
 if not extralist then
   extralist=createSymbolList()
   extralist.register()
 end
 local sizes,pointer=HighestObjectID+10
 for i=1,sizes do
   if string.find(ObjectTable[i].Type,'Function') then
     pointer=readPointer(ObjectTable[i].Address+UObject.funct)
     if readPointer(pointer) then extralist.addSymbol('UE',ObjectTable[i].FullName,pointer,1)end
   end
 end
end

function GetName1(pointer)
  if not readPointer(pointer+UObject.Class) then return nil end
  local typ=readQword(readPointer(pointer+UObject.Class)+UObject.FNameIndex)
  if not typ then return nil end
  local name=readQword(pointer+UObject.FNameIndex)
  typ=FNameStringAlgo(typ,true)
  name=FNameStringAlgo(name,true)
  return typ,name,readPointer(pointer+UObject.Outer)
end

function GetName2(pointer)
  if not readPointer(pointer) then return nil end
  local typ=readQword(readPointer(pointer+8))
  if not typ then return nil end
  local name=readQword(pointer+0x28)
  typ=FNameStringAlgo(typ,true)
  name=FNameStringAlgo(name,true)
  return typ,name,readPointer(pointer+0x10)
end

function SaveObject(pointer)
   if not readPointer(pointer)then return nil end
   if ObjectLists[pointer] then return ObjectLists[pointer] end
   local objid=readInteger(pointer+UObject.ObjectId)
   if not objid then return nil end

   local typ,name,outer
   if UE4ver&lt;25 then typ,name,outer=GetName1(pointer)
   else typ,name,outer=GetName2(pointer)
     if not typ or string.find(typ,'None') or not name or string.find(name,'None') then
       typ,name,outer=GetName1(pointer)
     end
   end

   if not typ or string.find(typ,'None') or not name or string.find(name,'None') then return nil end

   local ObjectData,size,pointers={},targetIs64Bit() and 8 or 4

   ObjectData.Outer= outer~=0 and outer or nil
   ObjectData.Name=name
   ObjectData.Type=typ
   ObjectData.Address=pointer

   if not ObjectData.Name then
     --print(ObjectData.Address)
     ObjectData.Name='InvalidName'
   end
   if ObjectTable[objid+1] and ( not string.find(typ,'Property') or UE4ver&lt;25 ) then return ObjectTable[objid+1] end

   ObjectData.ObjectId=objid

   if not readPointer(objid) and objid&lt;0xFFFFFFF and ( not string.find(typ,'Property') or UE4ver&lt;25 ) then
     ObjectTable[objid+1]=ObjectData
     if HighestObjectID&lt;objid then HighestObjectID=objid end
   end

   ObjectLists[pointer]=ObjectData

   SaveObject(ObjectData.Outer)
   local dataNew,str,dataOld=ObjectData,ObjectData.Name

   for x=0,10 do
     if not dataNew.Outer or not ObjectLists[dataNew.Outer] then break end
     dataOld=dataNew
     dataNew=ObjectLists[dataNew.Outer]
     if (string.find(dataOld.Type,'Property') or string.find(dataOld.Type,'Function'))
     and (not string.find(dataNew.Type,'Property') and not string.find(dataNew.Type,'Function'))
     then
       str=dataNew.Name..':'..str
     else
       str=dataNew.Name..'.'..str
     end
   end
   ObjectData.FullName=str
   FullNameList[str:lower()]=ObjectData

   totalobjects=totalobjects+1

   if not UObject.super or not UObject.member or not UObject.nextmember or not UObject.Offset
   or not UObject.propsize or not UObject.bitmask or not UObject.Property then
   return ObjectData end

   local super=readPointer(pointer+UObject.super)
   ObjectData.Super= super~=0 and super or nil
   if ObjectData.Super then ObjectData.Super=SaveObject(ObjectData.Super)end
   if ObjectData.Super then
     if not ObjectData.Super.Uper then ObjectData.Super.Uper={}end
     ObjectData.Super.Uper[#ObjectData.Super.Uper+1]=ObjectData
   end

   if string.find(typ,'Property')then
     ObjectData.Offset=readSmallInteger(pointer+UObject.Offset)
     ObjectData.Propsize=readSmallInteger(pointer+UObject.propsize)
     if string.find(typ,'StructProperty') or string.find(typ,'ObjectProperty') then
       ObjectData.Property={SaveObject(readPointer(pointer+UObject.Property))}
       if not ObjectData.Property[1] then ObjectData.Property=nil end
     elseif string.find(typ,'MapProperty') or string.find(typ,'ArrayProperty') then
       ObjectData.Property={SaveObject(readPointer(pointer+UObject.Property)),SaveObject(readPointer(pointer+UObject.Property+size))}
       if not ObjectData.Property[1] then ObjectData.Property=nil end
     elseif string.find(typ,'BoolProperty')then ObjectData.Bit=readBytes(pointer+UObject.bitmask,1) end
   else
     local member=SaveObject(readPointer(pointer+UObject.member))
     if member and (string.find(member.Type,'Function') or string.find(member.Type,'Property')) then
       ObjectData.Member={member}
       for i=0,300 do
         member=SaveObject(readPointer(member.Address+UObject.nextmember))
         if not member then break end
         if not string.find(member.Type,'Function') then
           ObjectData.Member[#ObjectData.Member+1]=member
         end
       end
     end
   end

   return ObjectData
end

function isStructExist(name)
  for i=1,#StructList do
    if StructList[i].Name==name then return StructList[i] end
  end
  return nil
end

function SaveAndRemoveStruct()
  StructList={}
  local count=getStructureCount()
  for i=count-1,0,-1 do
    local struct=getStructure(i)
    StructList[i+1]=struct
    struct:removeFromGlobalStructureList()
  end
end

function DeleteStruct(Struct)
  local count=#StructList
  for i=1,count do
    if Struct==StructList[i] then
      Struct:Destroy()
      StructList[i]=nil
    end
    if not StructList[i] and StructList[i+1] then
      StructList[i]=StructList[i+1]
      StructList[i+1]=nil
    end
  end
end

function LoadStruct()
  for i=1,#StructList do
    StructList[i]:addToGlobalStructureList()
  end
end

function ChildStructStart(structname,elementname)
local struct=isStructExist(structname)
if struct then
for i=0,struct.Count-1 do
if struct.Element[i].Name==elementname then return struct.Element[i].ChildStructStart end end
else return nil end
end

function findAddress(name,number,AddressOrAOBString,modulename,stopaddress,Nth,aobscanOnly,gethead,nop)
	local size,address=0x100
    AddressOrAOBString,address=string.lower(AddressOrAOBString):gsub('banana','')
	if(address&gt;0)then
		local f
		if(modulename==0 or modulename==nil or modulename=='')then f=AOBScan(AddressOrAOBString)
		else
            if type(modulename)==type(0) then modulename=string.format('%X',modulename)
            elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
			local ms = createMemScan()
			if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
				stopaddress=getNameFromAddress(getAddress(modulename),true,false)
                if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
				if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
                modulename=getAddress([["]]..stopaddress..[["]])
				stopaddress=modulename+getModuleSize(stopaddress)
                modulename=string.format('%X',modulename)
			end
			ms.firstScan(soExactValue,vtByteArray,rtTruncated,AddressOrAOBString,'',getAddress(modulename),getAddress(stopaddress),'',fsmNotAligned,'',true,false,false,false)
			ms.waitTillDone()
			f = createFoundList(ms)
			f.initialize()
			ms.destroy()
		end
		address={}
		for i=0,f.Count-1 do address[i+1]=f[i]end
		f.destroy()
        if Nth==nil or Nth==0 or Nth=='' then Nth=1 end
        if gethead then
           local addresss=GetAddressSafe(address[Nth])
           if not addresss then addresss=GetAddressSafe(address[Nth-1])end
           if addresss and addresss~=0 then
           for i=0,0x1000 do
               addresss=addresss-1
               if readBytes(addresss,1)==0xCC then break end
               if nop then local ext, opc, byt, add=splitDisassembledString(disassemble(addresss)) if string.find(opc,'nop') then addresss=addresss+getInstructionSize(addresss)-1 break end end
           end
           address[Nth]=addresss+1 end
        end
		if number==nil or number==0 or number=='' then
			if aobscanOnly then return address end
		else
            if(#address==0)then error(name..' aob no result found') end
            if(getAddress(address[Nth])==nil)then error(name..' aob result '..Nth..' doesnt exist') end
            unregisterSymbol(name)
            registerSymbol(name,getAddressSafe(address[Nth]),true)
            if aobscanOnly then return end
		end
		AddressOrAOBString=GetAddressSafe(address[Nth])
	end
    AddressOrAOBString=getAddressSafe(AddressOrAOBString)
	if(AddressOrAOBString==nil)then error(name..' still cant be found')end
	local addr={}
	local i=0
	local j=1
	while(i&lt;size) do
		local ext, opc, byt, add=splitDisassembledString(disassemble(getAddressSafe(AddressOrAOBString)+i))
		if(ext~="")then
			if(opc:find(",")~=nil)then
				opc=opc:sub(opc:find(",")+1,opc:len())
			else
				opc=opc:sub(opc:find(" ")+1,opc:len())
			end
			addr[j]=opc:gsub("%[",""):gsub("]","") j=j+1
		end
        if opc:find('],') then
            opc=opc:sub(opc:find("%[")+1,opc:find("]")-1)
            if tonumber(opc,16) then addr[j]=opc j=j+1 end
        end
		i=i+getInstructionSize(AddressOrAOBString+i)
	end
    --for i=1,#addr do print(addr[i]) end
	if number==nil or number==0 or number=='' then return addr end
	local offset
	if(type(number)==type(''))then
		offset=string.find(number,',')
		if(offset==nil)then number=getAddress(number)
		else offset=getAddress(string.sub(number,offset+1,number:len()))
			number=getAddress(string.sub(number,1,string.find(number,',')-1))
		end
	end
	if offset==nil then offset=0 end
	unregisterSymbol(name)
	registerSymbol(name,getAddressSafe(addr[number])-offset,true)
end

function checkvalue(address,size,value,typ)
  local cvalue,tempvalue,value2=readBytes(address,size,true)

  if type(value)==type('') and string.find(value,'~') then
    value2=tonumber(value:sub(string.find(value,'~')+1,value:len()))
    value=tonumber(value:sub(1,string.find(value,'~')-1))
  end

  if not cvalue then return false end
  if typ==1 then
    for i=1,#cvalue,4 do
      datatable={}
      for m=1,4 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToDword(datatable)
      --print(FNameStringAlgo(tempvalue,true))
      local str=FNameStringAlgo(tempvalue,true)

      if str and string.find(str,value) then return address+i-1 end
    end

  elseif typ==2 then
    for i=1,#cvalue,2 do
      datatable={}
      for m=1,2 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToWord(datatable)
      if tempvalue==value or (value2 and tempvalue&gt;=value and tempvalue&lt;=value2 ) then return address+i-1 end
    end
  elseif typ==4 then
    for i=1,#cvalue,4 do
      datatable={}
      for m=1,4 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToDword(datatable)
      if tempvalue==value or (value2 and tempvalue&gt;=value and tempvalue&lt;=value2 ) then return address+i-1 end
    end
  elseif typ==8 then
    for i=1,#cvalue,4 do
      datatable={}
      for m=1,8 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToQword(datatable)
      if tempvalue==value or (value2 and tempvalue&gt;=value and tempvalue&lt;=value2 ) then return address+i-1 end
    end
  end
  return nil
end

function fillstruct4bytes(Struct)
  if not getElementByOffset(Struct,0) then local e=Struct.addElement() e.Offset=0 e.Vartype=vtDword end
  Struct.beginUpdate()
  local count=Struct.Count-1
  local list,k,element1,element2,size,bytesize={},1
  for i=0,count do
    element1=Struct.Element[i]
    element2=Struct.Element[i+1]
    if element2 then
      bytesize=element1.Bytesize
      if bytesize&lt;4 then bytesize=4 end
      size=element2.Offset-element1.Offset-bytesize
      if size&gt;0 then
        if size%4&gt;0 then size=4-size%4+size end
        local start=element1.Offset
        if start%4&gt;0 then start=4-start%4+start
        else start=start+4 end
        size=size/4
        for j=0,size-1 do
          if (start+j*4)&gt;=(element1.Offset+bytesize) then
            list[k]=start+j*4
            k=k+1
          end
        end
      end
    end
  end
  for i,v in ipairs(list) do local e=Struct.addElement() e.Offset=v e.Vartype=vtDword end
  Struct.endUpdate()
end

function ue4createstruct(FullNameOrAddress,StructName,isGlobal,isfullname,Structu,AddedOffset,AddedName,Instance)
  if not FullNameOrAddress then return
  elseif type(FullNameOrAddress)==type({})then
    RunningStructCounter=0
    SaveAndRemoveStruct()
    for i=1,#FullNameOrAddress do
      createThread(ue4createstruct(FullNameOrAddress[i],StructName[i],isGlobal,isfullname,Structu,AddedOffset,AddedName,Instance))
    end

    while(true)do
      if not RunningStruct or #RunningStruct==0 then break
      else sleep(1)end
      RunningStructCounter=RunningStructCounter+1
      if RunningStructCounter&gt;180000 then break end
    end
    RunningStructCounter=nil
    LoadStruct()
    return
  end
  if StructName and isGlobal then local Struct=isStructExist(StructName) if Struct then return end end--DeleteStruct(Struct)end end

  local member,Offset,Property,bitmask,nextmember,super,propsize=UObject.member,UObject.Offset,UObject.Property,UObject.bitmask,UObject.nextmember,UObject.super,UObject.propsize
  local Object,Name,Class,PropName,Typ,Off,pointer,e,f=FullNameOrAddress

  if type(FullNameOrAddress)==type('') then Object=StaticFindObjectAlgo(FullNameOrAddress) end
  if not Object then print(FullNameOrAddress..' not found...') return end
  Name=GetNameAlgo(Object)
  if not Name or not string.find(Name,' ') then print(FullNameOrAddress..' invalid Object?') return end
  if not StructName then
    Class=Name:sub(1,string.find(Name,' ')-1)
    Name=Name:sub(string.find(Name,' ')+1,Name:len())
  else Name=StructName end

  local Struct=Structu
  if not Struct then Struct=createStructure(Name)end

  if not AddedName then AddedName='' end
  local RunningStructName=name
  if not AddedOffset then
    if not RunningStruct then RunningStruct={} end
    RunningStruct[#RunningStruct+1]=RunningStructName

    AddedOffset=0 Struct.beginUpdate()
  else
    local FullName=GetFullNameSafeAlgo(Object)
    FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())

    if not LocalStruct then LocalStruct={}end
    if LocalStruct[FullName] then copyStruct(LocalStruct[FullName],Struct,AddedOffset,AddedName)
    else
      local copy=createStructure(FullName)
      ue4createstruct(Object,nil,nil,isfullname,copy)
      LocalStruct[FullName]=copy
      copyStruct(LocalStruct[FullName],Struct,AddedOffset,AddedName)
    end
    return
  end
  --if not RunningStructCounter and AddedName=='' then SaveAndRemoveStruct() end

  --print(string.format('%X',Object))
  while(true)do
    if not Object or Object==0 then break end
    Name=GetNameAlgo(Object)
    if not Name then break end
    Name=Name:sub(string.find(Name,' ')+1,Name:len())
    if Name=='Object' then break end
    print(GetFullNameSafeAlgo(Object))
    pointer=readPointer(Object+UObject.member)
    while(true)do
      if not pointer or pointer==0 then break end
      PropName=GetFullNameSafeAlgo(pointer)
      if PropName and string.find(PropName,':') then
        Typ=PropName:sub(1,string.find(PropName,' ')-1)
        if not string.find(Typ,'Function')then
          if not isfullname then PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())
          else PropName=PropName:sub(string.find(PropName,' ')+1,PropName:len())end
          PropName=AddedName..PropName
          Off=readInteger(pointer+Offset)+AddedOffset
          if Class=='UserDefinedStruct' and string.find(PropName,'_') then PropName=PropName:sub(1,string.find(PropName,'_')-1)end
          if Typ=='StructProperty' then
            ue4createstruct(readPointer(pointer+Property),nil,nil,isfullname,Struct,Off,PropName..'.')
            if not getElementByOffset(Struct,Off) then e=Struct.addElement() e.Offset=Off e.Name=PropName e.Vartype=vtDword end
          else
            e=Struct.addElement()
            e.Offset=Off
            e.Name=PropName
            if Instance and PropName=='RowStruct' then
              local spointer=readPointer(Instance+Off)
              local sname,sstruct=GetFullNameSafeAlgo(spointer)
              if sname then
                print(sname)
                if string.find(sname,'.') then sname=sname:sub(string.find(sname,'.')+1,sname:len())end

                if not ArrayStruct then ArrayStruct={} end
                if ArrayStruct[sname] then sstruct=ArrayStruct[PropName]
                else
                  sstruct=createStructure(sname)
                  ArrayStruct[sname]=sstruct
                  ue4createstruct(spointer,nil,nil,isfullname,sstruct)
                end

                f=Struct.addElement() f.Offset=e.Offset+8-sub f.Name='Table' f.Vartype=vtPointer
                local ssstruct=createStructure('DataTable')
                f.setChildStruct(ssstruct)

                for r=0,10 do
                  f=ssstruct.addElement() f.Offset=r*0x18 f.Name=string.format('[%u] FName',r)  f.Vartype=vtQword
                  f=ssstruct.addElement() f.Offset=r*0x18+8 f.Name=string.format('[%u] Data',r) f.Vartype=vtPointer
                  f.setChildStruct(sstruct)
                end
                fillstruct4bytes(ssstruct)

                f=Struct.addElement() f.Offset=e.Offset+0x10-sub*2 f.Name='Size' f.Vartype=vtDword
              end
            end
            if not ue4type[Typ] then e.Vartype=vtDword
            else e.Vartype=ue4type[Typ]end
            if Typ=='ArrayProperty' or Typ=='MapProperty' then
              f=Struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=Struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
              local isMap= Typ=='MapProperty'

              Prop=readPointer(pointer+Property)
              PropName=GetFullNameSafeAlgo(Prop)
              if not PropName then PropName=GetFullNameSafeAlgo(Prop)end
              if PropName then
                Typ=PropName:sub(1,string.find(PropName,' ')-1)
                PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())
                if string.find(PropName,':') then PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())end
                if Typ=='StructProperty' then
                  Prop=readPointer(Prop+Property)
                  PropName=GetNameAlgo(Prop)
                  if PropName then
                    PropName=PropName:sub(string.find(PropName,' ')+1,PropName:len())..'[]'
                    --print(Typ..' '..PropName)
                  end
                else PropName=PropName..'[]' end
                if not ArrayStruct then ArrayStruct={} end
                if ArrayStruct[PropName] then e.setChildStruct(ArrayStruct[PropName])
                else
                  local stru=createStructure(PropName)
                  ArrayStruct[PropName]=stru
                  e.setChildStruct(stru)

                  stru.beginUpdate()
                  local ppsize=0
                  if isMap then
                    for j=0,1 do
                      Prop=readPointer(pointer+Property+j*(8-sub))
                      PropName=GetFullNameSafeAlgo(Prop)
                      if PropName then
                        ppsize=(readInteger(Prop+propsize)&lt;4 and 4 or readInteger(Prop+propsize))+ppsize
                      end
                    end
                    ppsize=ppsize+0x8
                    --print(ppsize)
                  end

                  for j=0,1 do
                    Prop=readPointer(pointer+Property+j*(8-sub))
                    PropName=GetFullNameSafeAlgo(Prop)
                    if PropName and string.find(PropName,':') then
                      Typ=PropName:sub(1,string.find(PropName,' ')-1)
                      --if Typ=='StructProperty' then print(PropName)end
                      PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())
                      if string.find(PropName,':') then PropName=PropName:sub(string.find(PropName,':')+1,PropName:len())end

                      local psize=isMap and ppsize or readInteger(Prop+propsize)
                      local Offs=isMap and readInteger(Prop+Offset) or 0
                      local Propt
                      if Typ=='StructProperty' then
                        Propt=readPointer(Prop+Property)
                      end
                      for p=0,10 do
                        Off=p*psize+Offs
                        local ItemName=string.format('[%u] ',p)
                        if Typ=='StructProperty' then
                          ue4createstruct(Propt,nil,nil,isfullname,stru,Off,ItemName)
                          --if not getElementByOffset(stru,Off) then e=stru.addElement() e.Offset=Off e.Name=PropName e.Vartype=vtDword end
                        else
                          local g=stru.addElement()
                          g.Offset=Off
                          g.Name=ItemName..PropName
                          if not ue4type[Typ] then g.Vartype=vtDword
                          else g.Vartype=ue4type[Typ]end
                        end
                      end
                    end
                  end
                  stru.endUpdate()
                  fillstruct4bytes(stru)
                end
              end
            elseif Typ=='BoolProperty' then e.ChildStructStart=readBytes(pointer+bitmask,1)end
          end
        end
      end
      pointer=readPointer(pointer+nextmember)
    end
    Object=readPointer(Object+super)
  end

  if AddedName~='' then return end


  Struct.endUpdate()
  fillstruct4bytes(Struct)
  if isGlobal then StructList[#StructList+1]=Struct end

  local count=#RunningStruct
  for i=1,count do
    if RunningStruct[i]==RunningStructName then RunningStruct[i]=nil end
    if not RunningStruct[i] and RunningStruct[i+1] then RunningStruct[i]=RunningStruct[i+1] RunningStruct[i+1]=nil end
  end
  if not RunningStructCounter then LoadStruct() end

end


function getElementByOffset(struct,offset)
  for i=0,struct.Count-1 do
    if struct.Element[i].Offset==offset then return i end
  end
  return nil
end

function copyStruct(original,copy,AddedOffset,AddedName)
  if not copy then copy=createStructure(original.Name..'_copy')end
  if not AddedOffset then AddedOffset=0 end
  if not AddedName then AddedName='' end
  copy.beginUpdate()
  for i=0,original.Count-1 do
    local e=copy.addElement()
    e.Offset=original.Element[i].Offset+AddedOffset
    if original.Element[i].Name=='' then e.Name=original.Element[i].Name
    else e.Name=AddedName..original.Element[i].Name end
    e.Vartype=original.Element[i].Vartype
    e.ChildStruct=original.Element[i].ChildStruct
    e.ChildStructStart=original.Element[i].ChildStructStart
    e.Bytesize=original.Element[i].Bytesize
  end
  copy.endUpdate()
  return copy
end

function uecreatestruct(instance,name,depth,isfullname)
  local pointer=readPointer(instance+UObject.Class)
  local classname=GetFullNameSafeAlgo(pointer)
  if not classname then print('instance is invalid') return end
  if classname:find(' ') then classname=classname:sub(classname:find(' ')+1) end

  print(string.format("createThread(ue4createstruct(\'%s\',\'%s\',0))",classname,name))
  ue4createstruct(pointer,name,depth,isfullname)
end

function ue_structureDissectOverrideCallback(Struct, Instance)
  --print('banana2')
  local name,fullname,class
  address,name,fullname,class=ue_findRealStartOfObject(Instance)

  if class then
   -- print('banana3')
    --if UEObj and (not enumUEObjIsRunning or enumUEObjIsUpdateOnly) then ue4createstructfast(fullname,nil,nil,nil,Struct) end
    SaveAndRemoveStruct()
    ue4createstruct(class,nil,nil,nil,Struct,nil,nil,Instance)
    --LoadStruct()
    if Struct.Count&gt;1 then return true
    else return false end
  end

  --ue_fillstruct(readPointer(Instance+UObject.Class),structure)
  --print('banana4')

  return nil
end

function ue_structureNameLookupCallback(address)
  --print('banana1')
  local name,fullname
  address,name,fullname=ue_findRealStartOfObject(address)
  if name then return name,address end
  return nil
end

function ue_SymbolLookupCallback(symbol)
  --print('banana1')
  local str='Function '
  if string.find(symbol,str) then
    symbol=symbol:sub(string.find(symbol,str)+str:len(),symbol:len())
    local pointer=StaticFindObjectAlgo(symbol)
    if pointer then return readPointer(pointer+UObject.funct)end
  end
  return nil
end

function ue_findRealStartOfObject(address)
  local pointer=readPointer(address+UObject.Class)
  if pointer then
    local FullName=GetFullNameSafeAlgo(pointer)
    if FullName then
      local Name=GetNameAlgo(pointer)
      FullName=FullName:sub(string.find(FullName,' ')+1,FullName:len())
      Name=Name:sub(string.find(Name,' ')+1,Name:len())
      return address,Name,FullName,pointer
    end
  end

  if UEObj and (not enumUEObjIsRunning or enumUEObjIsUpdateOnly) then
    for i=1,#UEObj do
      if UEObj[i].MemberSize and UEObj[i].Class and UEObj[i].Class.MemberSize and UEObj[i].Class.MemberSize&gt;0 and not string.find(UEObj[i].Class.FullName,'/Script/CoreUObject.') then
         if address&gt;=UEObj[i].Address and address&lt;UEObj[i].Address+UEObj[i].Class.MemberSize then
           local name
           return UEObj[i].Address,UEObj[i].Class.Name,UEObj[i].Class.FullName,UEObj[i].Class.Address
         end
      end
    end
  end

  return address
end


function findOpcodes(address,opcode,size)
  if not size then size=0x50 end
  address=getAddressSafe(address)
  if not address then return nil end
  local addr={}
  local i=0
  local j=1
  while(i&lt;size) do
    local ext, opc, byt, add=splitDisassembledString(disassemble(address+i))
    if string.find(opc,opcode) then
      addr[j]=address+i
      j=j+1
    end
    i=i+getInstructionSize(address+i)
  end
  return addr
end

function findLastCall(address,size)
  if not size then size=0x1000 end
  local result=findOpcode(address,'ret',size)
  if not result then print(address..' cant find ret?') return nil end
  result=result-getAddress(address)
  result=findOpcodes(address,'call ',result)
  local ext, opc, byt, add=splitDisassembledString(disassemble(result[#result]))
  opc=opc:gsub('call ','')
  return opc
end

function followjmp(address,size)
  if not size then size=0x1000 end
  local result=findOpcode(address,'jmp ',size)
  if not result then print(address..' cant find jmp?') return nil end
  local ext, opc, byt, add=splitDisassembledString(disassemble(result))
  opc=opc:gsub('jmp ','')
  return opc
end

function followcall(address,size)
  if not size then size=0x1000 end
  local result=findOpcode(address,'call ',size)
  if not result then print(address..' cant find call?') return nil end
  local ext, opc, byt, add=splitDisassembledString(disassemble(result))
  opc=opc:gsub('call ','')
  return opc
end

--local ext, opc, byt, add=splitDisassembledString(disassemble(findOpcodes('/Script/Astro.PrinterComponent:UpdatePreprinting_exec','call')[1]))
--return opc:sub(string.find(opc,' ')+1,opc:len())

function startstop(modulename,stopaddress)
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  if type(modulename)==type(0) then modulename=string.format('%X',modulename)
  elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
  if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
    stopaddress=getNameFromAddress(getAddress(modulename),true,false)
    if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
	if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
    modulename=getAddress([["]]..stopaddress..[["]])
	stopaddress=modulename+getModuleSize(stopaddress)
    modulename=string.format('%X',modulename)
  end
  if type(stopaddress)==type(0) then stopaddress=string.format('%X',stopaddress)end
  return modulename,stopaddress
end

function groupscan(value,modulename,stopaddress)
  local ms = createMemScan()
  modulename,stopaddress=startstop(modulename,stopaddress)
  ms.firstScan(soExactValue,vtGrouped,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress,value2)
  local ms = createMemScan()
  modulename,stopaddress=startstop(modulename,stopaddress)
  print(modulename..'~'..stopaddress)
  if value2 then ms.firstScan(soValueBetween,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  else ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)end
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function stringscan(value,modulename,stopaddress,isUnicode)
  local ms = createMemScan()
  modulename,stopaddress=startstop(modulename,stopaddress)
  ms.firstScan(soExactValue,vtString,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,isUnicode,true)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function StructAddToListSymbol(StructName,StartOffset,StopOffset,BaseAddress,OffsetOnly)
  if not StartOffset then StartOffset=0 end
  if not StopOffset then StopOffset=0xFFFFFF end
  local structCount=getStructureCount()
  local struct
  for i=0,structCount-1 do
    local stru=getStructure(i)
    if stru.Name==StructName then struct=stru break end
  end
  if struct then
    for i=0,struct.Count-1 do
      local e=struct.Element[i]
      if e.Offset&gt;=StartOffset and e.Offset&lt;=StopOffset then
        local rec=getAddressList().createMemoryRecord()
        rec.setDescription(e.Name)
        if OffsetOnly then
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.Offset[0]=e.Offset
          else rec.setAddress(string.format('+%X',e.Offset))end
        else
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.OffsetText[0]=StructName..'.'..e.Name
          else rec.setAddress(string.format('+%s.%s',StructName,e.Name))end
        end
        rec.Type=e.Vartype
      end
    end
  end
end

function getInsForJump(address,registername,destination,allocsize,SharedMemoryName)
  address = getAddressSafe(address)
  if not address then error('getInsForJump address nil') return end
  if not allocsize then allocsize=4096 end
  destination=getAddressSafe(destination)
  if not destination then
	if not SharedMemoryName then destination = allocateMemory(allocsize,address)
	else destination = allocateSharedMemory(SharedMemoryName,allocsize) end
  end
  local size = (address+5-destination&gt;0x7FFFFFFF) and 14 or 5
  if registername then
	unregisterSymbol(registername)
	registerSymbol(registername,destination,true)
  end
  local opcodes = {}
  local i = 0
  while(i&lt;size) do
    local ext, opc=splitDisassembledString(disassemble(address+i))
    opcodes[#opcodes+1] = opc
    i=i+getInstructionSize(address+i)
  end
  local copy = table.concat(opcodes,'\r\n')
  local readAsTable = true
  local byt = readBytes(address,i,readAsTable)
  for j=1,#byt do byt[j] = ('%02X'):format(byt[j]) end
  local bytes = table.concat(byt, ' ')
  return i,copy,bytes,size,destination
end

function enablescript(name,registername,addressname,script,disable)
    local address=getAddress(addressname)
    if disable then script=(script):format(address,registername,readBytes(registername,1))
    else
        local i,copy,bytes,size =getInsForJump(address,name)
        script=(script):format(registername, registername, name, copy, registername, i, bytes, address)..string.rep('nop\n',i-size)..'returnhere:'
    end
    local success,erro=autoAssembleCheck(script)
    if not success then print('\n'..erro..'\n')local scriptstr=createStringlist()scriptstr.Text=script for j=0,scriptstr.Count-1 do print(string.format('%u\t%s',j+1,scriptstr[j])) end
    if not disable then deAlloc(name)unregisterSymbol(name)end error(name..' autoAssemble failed')end
    autoAssemble(script)
    if disable then deAlloc(name)unregisterSymbol(name)unregisterSymbol(registername)end
end

function cycleFullCompact(sender,force)
  local state = not(compactmenuitem.Caption == 'Compact View Mode')
  if force~=nil then state = not force end
  compactmenuitem.Caption = state and 'Compact View Mode' or 'Full View Mode'
  getMainForm().Splitter1.Visible = state
  getMainForm().Panel4.Visible = state
  getMainForm().Panel5.Visible = state
end

function addCompactMenu()
  if compactmenualreadyexists then return end
  local parent = getMainForm().Menu.Items
  compactmenuitem = createMenuItem(parent)
  parent.add(compactmenuitem)
  compactmenuitem.Caption = 'Compact View Mode'
  compactmenuitem.OnClick = cycleFullCompact
  compactmenualreadyexists = 'yes'
end

addCompactMenu()
--cycleFullCompact(nil,true)

if syntaxcheck then return end

[ENABLE]
if not process or not enumModules()[1] then print('Error: No process selected...') error('process is nil') end
if string.find(process,'MassEffect') then
  isMassEffect=true
  --findAddress('GUObjectArray',1,'4C * * * * * * 49 3B * 0F 84 * * * * 48 89 * * * 48 89banana',process)
  --print('------------------')
  local result2,result=findAddress('FNamePool',0,'C0 CA 45 80 00 00 00 00 00 00 00 00 4E 6F 6E 65 00banana',process,nil,0,true)
  for i=1,#result2 do
    result=pointerscan(getAddress(result2[i]),process)
    for j=1,#result do
      stringoffset=0xC
      unregisterSymbol('FNamePool') registerSymbol('FNamePool',result[j],true)
    end
  end

  else isMassEffect=nil
end
local starttime=os.time()

if not UE4ver then UE4ver=ue4versioncheck() end

if not getAddressSafe('GUObjectArray') and not getAddressSafe('FNamePool')  then

  if targetIs64Bit() then

    local address=findAddress('GUObjectArray',0,'44 8B * * * 48 8D 05 * * * * * * * * * 48 89 71 10banana',process,nil,0,true)[1]
    if not address then address=findAddress('GUObjectArray',0,'40 53 48 83 EC 20 48 8B D9 48 85 D2 74 * 8Bbanana',process,nil,0,true)[1]end
    if not address then address=findAddress('GUObjectArray',0,'4C 8B 05 * * * * 45 3B 88banana',process,nil,0,true)[1]end
    if not address then findAddress('GUObjectArray','1,-0x68','4C 8B 44 24 60 8B 44 24 78 * * * 48 8Dbanana',process)
    else findAddress('GUObjectArray',1,address)end

    if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
      if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
      elseif readInteger('GUObjectArray+14')==0 then UE4ver=9
      else UE4ver=20 end
    end

    ue4config()

    if UE4ver&gt;=23 then
      address=findAddress('FNamePool',0,'4C 8D 05 * * * * EB 16 48 8D 0D * * * * E8banana',process,nil,0,true)[1]
      if not address then address=findAddress('FNamePool',0,'48 8D 0D *  *  *  *  E8 *  *  *  * 4C 8B C0 C6banana',process,nil,0,true)[1]end
      if address then findAddress('FNamePool',1,address)
      else error('FNamePool aob not found...')end
    elseif string.find(process,'StateOfDecay2')then
      findAddress('FNamePool',1,'48 8D * * * * * 8B * * 85 * 74 * 8Dbanana',process,nil,1,nil,true,true)
      findAddress('FNamePool2',3,'48 8D * * * * * 8B * * 85 * 74 * 8Dbanana',process,nil,1,nil,true,true)
      FNamePool=getAddress('FNamePool')
      FNamePool2=getAddress('FNamePool2')
    else
      address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[2]
      if not address then address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[1] end
      if address then findAddress('FNamePool',1,address)
      else findAddress('FNamePool',1,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20banana',process,nil,2)end
    end

  else
    ue4config()
    if UE4ver&gt;2 then
      findAddress('GUObjectArray',1,'8B 44 24 04 56 8B F1 85 C0 74 17 8B 40 08banana',process)
      findAddress('FNamePool',1,'33 F6 89 35 * * * * 8B C6 5Ebanana',process,nil,1,nil,true,true)
    else
      findAddress('FNamePool',1,'8B 07 8B 0D * * * * 8B 04 81banana',process)
      findAddress('GUObjectArray',1,'8B 15 * * * * 8B 04 82 85banana',process)
    end
  end

end

if targetIs64Bit() then
  if UE4ver&gt;7 then
    local address=findAddress('GEngine',0,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process,nil,0,true)[1]
    if not address then address=findAddress('GEngine',0,'48 8B 1D * * * * 48 85 DB 74 * 48 8Dbanana',process,nil,0,true)[1]end
    if not address then error('GEngine aob not found...')end
    findAddress('GEngine',1,address)
 --findAddress('GEngine',1,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process)
  end
else
  if UE4ver&gt;2 then
    findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  else
    findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  end
end

print('AOBScan done : '..os.time()-starttime)

ue4parsetable()

FNameStringAlgo(1,true)
FNameStringAlgo(3,true)
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

print('Table parsing done : '..os.time()-starttime)


if not UObject.super or not UObject.member or not UObject.nextmember or not UObject.Offset
or not UObject.propsize or not UObject.bitmask or not UObject.Property or not UObject.funct
or not UObject.enumoffset or  not UObject.enummul or not UObject.enumname or not UObject.enumindex
then if UE4ver&gt;7 then UE4AutoConfig() else UE3AutoConfig() end end




--findAddress('GWorld',1,'4D 8B 94 24 50 0C 00 00banana',process)

if UE4ver&gt;7 then

   ue4createstruct({
   '/Script/Engine.GameEngine',
   '/Script/Engine.GameViewportClient',
   '/Script/Engine.GameInstance',
   '/Script/Engine.LocalPlayer',
   '/Script/Engine.PlayerController',
   '/Script/Engine.CharacterMovementComponent',
   '/Script/Engine.CapsuleComponent',
   '/Script/Engine.Character',
   '/Script/Engine.World'
   },{
   'GameEngine',
   'GameViewportClient',
   'GameInstance',
   'LocalPlayer',
   'PlayerController',
   'MovementComponent',
   'CapsuleComponent',
   'GPlayer',
   'World'
   },1)

end
print('All done : '..os.time()-starttime..'\n')
if not ue_SymbolLookupCallbackID then
  ue_SymbolLookupCallbackID=registerSymbolLookupCallback(ue_SymbolLookupCallback,slNotSymbol)
end
--registerFuncAlgo()
GetLuaEngine().close()
[DISABLE]
--cycleFullCompact(nil,false)
unregisterSymbolLookupCallback(ue_SymbolLookupCallbackID)
ue_SymbolLookupCallbackID=nil
--[[
unregisterSymbol('GEngine')
unregisterSymbol('GUObjectArray')
unregisterSymbol('FNamePool')]]
</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>26180</ID>
                  <Description>"Enable ue_structureDissectCallback (Experimental)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
if not ue_structureDissectOverrideCallbackID then
  ue_structureDissectOverrideCallbackID=registerStructureDissectOverride(ue_structureDissectOverrideCallback)
end

if not ue_structureNameLookupCallbackID then
  ue_structureNameLookupCallbackID=registerStructureNameLookup(ue_structureNameLookupCallback)
end
--[[
UEObjt=createThread(function()
  while(true)do
    if not UEObj and not enumUEObjIsRunning then enumUEObj(1)
    elseif not enumUEObjIsRunning then enumUEObj(1,1)end
    sleep(30000)
  end
end)
 ]]
[DISABLE]
unregisterStructureDissectOverride(ue_structureDissectOverrideCallbackID)
unregisterStructureNameLookup(ue_structureNameLookupCallbackID)
ue_structureDissectOverrideCallbackID=nil
ue_structureNameLookupCallbackID=nil

--UEObjt:terminate()
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26181</ID>
                  <Description>"Basic UE Object Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

local starttime=os.time()
if ue4parsetablecheck() or #ObjectTable&lt;0x30000 then BasicEnumObject() end

totalobject=0
local Path = 'C:\\test\\'
local filename= string.format('[%s] ObjectsDump.txt',process)
local file,err = io.open(Path..filename, 'w')
assert(file,err)
print(Path..filename)
file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
local size,sizes,pointer,datatable,pointers,propname,offset,list,str,strid,name,objid=targetIs64Bit() and 8 or 4,HighestObjectID+10
for i=1,sizes do
  if ObjectTable[i] then
    totalobject=totalobject+1
    str=string.format('%016X',ObjectTable[i].Address)
    strid=string.format('%08u',ObjectTable[i].ObjectId)
    name=ObjectTable[i].Type..' '..ObjectTable[i].FullName
    if ObjectTable[i].Offset then
      strid=string.format('%8X',ObjectTable[i].Offset)
    end
    if ObjectTable[i].Property and #ObjectTable[i].Property==1 then
      name=string.format('%s ~ %s %s',name,ObjectTable[i].Property[1].Type,ObjectTable[i].Property[1].FullName)
    end

    file:write(string.format('[%s] %s %s\n',strid,str,name))

    if ObjectTable[i].Property and #ObjectTable[i].Property==2 then
      for j=1,2 do
        name=string.format('%s %s',ObjectTable[i].Property[j].Type,ObjectTable[i].Property[j].FullName)
        if ObjectTable[i].Property[j].Property and ObjectTable[i].Property[j].Property[1] then
          name=string.format('%s ~ %s %s',name,ObjectTable[i].Property[j].Property[1].Type,ObjectTable[i].Property[j].Property[1].FullName)
        end
        file:write(string.format('[%8X] %016X %s\n',readInteger(ObjectTable[i].Property[j].Address+UObject.Offset),ObjectTable[i].Property[j].Address,name))
      end
    end

    if UObject.enumoffset and UObject.enummul and UObject.enumindex and UObject.enumname then
    if ObjectTable[i].Type=='UserDefinedEnum' or ObjectTable[i].Type=='Enum' then
      list=ObjectTable[i].Address+UObject.enumoffset
      for k=0,readInteger(list+size)-1 do
        pointers=readPointer(list)+k*UObject.enummul
        offset=readBytes(pointers+UObject.enumindex,1)
        if not offset then break end
        if offset==0 then offset=k end
        propname=FNameStringAlgo(pointers+UObject.enumname)
        strid=string.format('%8X',offset)
        str=string.format('%016X',pointers)
        file:write(string.format('[%s] %s %s\n',strid,str,propname))
      end
    end
    end

    if ObjectTable[i].Member and UE4ver&gt;=25 then
      for m=1,#ObjectTable[i].Member do
        if not string.find(ObjectTable[i].Member[m].Type,'Function')then

        totalobject=totalobject+1


        str=string.format('%016X',ObjectTable[i].Member[m].Address)
        strid=string.format('%08u',ObjectTable[i].Member[m].ObjectId)
        name=ObjectTable[i].Member[m].Type..' '..ObjectTable[i].Member[m].FullName
        if ObjectTable[i].Member[m].Offset then
          strid=string.format('%8X',ObjectTable[i].Member[m].Offset)
        end
        if ObjectTable[i].Member[m].Property and #ObjectTable[i].Member[m].Property==1 then
          name=string.format('%s ~ %s %s',name,ObjectTable[i].Member[m].Property[1].Type,ObjectTable[i].Member[m].Property[1].FullName)
        end

        file:write(string.format('[%s] %s %s\n',strid,str,name))

        if ObjectTable[i].Member[m].Property and #ObjectTable[i].Member[m].Property==2 then
        for j=1,2 do
          name=string.format('%s %s',ObjectTable[i].Member[m].Property[j].Type,ObjectTable[i].Member[m].Property[j].FullName)
          if ObjectTable[i].Member[m].Property[j].Property and ObjectTable[i].Member[m].Property[j].Property[1] then
            name=string.format('%s ~ %s %s',name,ObjectTable[i].Member[m].Property[j].Property[1].Type,ObjectTable[i].Member[m].Property[j].Property[1].FullName)
          end
          file:write(string.format('[%8X] %016X %s\n',readInteger(ObjectTable[i].Member[m].Property[j].Address+UObject.Offset),ObjectTable[i].Member[m].Property[j].Address,name))
        end
        end
    end



      end
    end

  end
end
file:close()
print(string.format('\nA Total of %u objects has been dumped in %u seconds',totalobject,os.time()-starttime))

shellExecute(Path..filename)

[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26182</ID>
                  <Description>"Basic UE Name Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function uenamedump(file,start,stop)
  for i=start,stop do
    local name=FNameStringAlgo(i,true)
    if name and name:len()&lt;200 and name:len()&gt;3 and not string.find(name,'%c')  then
      --print(name)
      local strid=string.format('%08X',i)

      file:write(string.format('[%s] %s\n',strid,name))
      totalname=totalname+1
    end
  end
end


 local size
 if readPointer(FNameString) or string.find(process,'StateOfDecay2')then size=0xFFFFFFFF
 elseif UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
 elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
 else size=math.floor(#FNameDict[1]/4) end
 local count=0x200
 size=math.floor((size/count)+0.5)

 local starttime=os.time()
 local Path = 'C:\\test\\'
 local filename= string.format('[%s] NamesDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
 totalname=0
 ue4parsetablecheck()
 local num,start,stop=count,0,0
 for i=0,size do
   start=stop
   stop=stop+num
   createThread(uenamedump(file,start,stop-1))
 end
 file:close()
 print(string.format('\nA Total of %u names had been dumped in %u seconds',totalname,os.time()-starttime))
 print(Path..filename)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26183</ID>
                  <Description>"Construct Console"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function AAscript(script)
  local success,erro=autoAssembleCheck(script)
  if not success then
    print('\n'..erro..'\n')
    local scriptstr=createStringlist()scriptstr.Text=script
    for j=0,scriptstr.Count-1 do print(string.format('%u\t%s',j+1,scriptstr[j])) end
    error('autoAssemble failed')
  end
  autoAssemble(script)
end

AAscript("aobscanmodule(StaticConstructObject,$process,4C ?? ?? ?? ?? 55 53 56 57 41 54 41 55 41 56 41 57 48 8D ?? ?? ?? ?? ?? ?? 48 81 ?? ?? ?? ?? ?? 48 8B ?? ?? ?? ?? ?? 48 33 ?? 48 89)\nregistersymbol(StaticConstructObject)")
local StaticConstructObject=getAddress('StaticConstructObject')
local Console=executeCodeEx
(
  0,nil,
  getAddress(StaticConstructObject),
  getAddress('[[GEngine]+GameEngine.ConsoleClass]'),
  getAddress('[[GEngine]+GameEngine.GameViewport]'),
  0,0,0,0,0,0,0
)
writePointer('[[GEngine]+GameEngine.GameViewport]+GameViewportClient.ViewportConsole',Console)


[DISABLE]
--"NewObject with empty name can't be used to create default subobjects"


</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26184</ID>
                  <Description>"Get GEngine "</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
unregisterSymbol('GEngine')
--[[
local result=UEfindInstancesOfClass('/Script/Engine.GameEngine')
for i=1,#result do
  print(string.format('%X:%s',result[i].Address,result[i].Name))
  if string.find(result[i].Name,'e_') then registerSymbol('GEngine',pointerscan(result[i].Address,process)[1]) end
end
]]


--[[

BasicEnumObject()
for i=1,#ObjectTable do
  if string.find(ObjectTable[i].Type,'GameEngine') and not string.find(ObjectTable[i].FullName,'Default') then
    print(string.format('%X:%s',ObjectTable[i].Address,GetFullNameSafeAlgo(ObjectTable[i].Address)))
    registerSymbol('GEngine',pointerscan(ObjectTable[i].Address,process)[1])  break
  end
  if i==#ObjectTable then print('GameEngine instance not found...')end

end
 ]]

function FindObjectName(name)
  for i=1,#ObjectTable do
    if string.find(ObjectTable[i].FullName,name) then return ObjectTable[i]end
  end
end

function FindObjectType(name,exception)
  for i=1,#ObjectTable do
    if string.find(ObjectTable[i].Type,name) and not string.find(ObjectTable[i].FullName,exception) then return ObjectTable[i]end
  end
end
--ue4parsetable()
--BasicEnumObject()
local Object=FindObjectName('GameEngine')
for i=0,4 do
  if Object.Uper and Object.Uper[1] then Object=Object.Uper[1] else break end
end
Object=Object.FullName:sub(string.find(Object.FullName,'%.')+1,Object.FullName:len())

Object=FindObjectType(Object,'Default')
print(string.format('%X : %s %s',Object.Address,Object.Type,Object.FullName))




registerSymbol('GEngine',pointerscan(Object.Address,process)[1],true)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26185</ID>
                  <Description>"NoClip &amp; Fly                                            Numpad6 :Toggle, Space :Up, LeftCtrl :Down"</Description>
                  <Options moHideChildren="1" moDeactivateChildrenAsWell="1"/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end

[ENABLE]

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) &amp; ~ ChildStructStart('PlayerController','bActorEnableCollision')
writeBytes(address,bActorEnableCollision)
end

--[[
Enum /Script/Engine.EMovementMode
0:MOVE_None
1:MOVE_Walking
2:MOVE_NavWalking
3:MOVE_Falling
4:MOVE_Swimming
5:MOVE_Flying
6:MOVE_Custom
7:MOVE_MAX

local list=+0x40
for i=0,readInteger(list+8)-1 do
local pointer=readPointer(list)+i*0x10
local enum=readInteger(pointer+8)
local name=FNameString(pointer)
print(enum..':'..name)
end
]]


if not RelativeLocationZoffset then
  local address=getAddress('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  local value=readInteger(address+getAddress('CapsuleComponent.RelativeLocation.Z'))
  local list=groupscan(string.format('4:%u',value),address,address+0x1000)
  RelativeLocationZoffset={}
  for i=1,#list do
    RelativeLocationZoffset[i]=getAddress(list[i])-address
  end
end

updown = createTimer()
updown.Interval = 5
updown.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_SPACE) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])+20)
      end
    end
    if isKeyPressed(VK_LCONTROL) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])-20)
      end
    end
  end
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MovementMode')
  if address then
  writeBytes(address,5)
  end
end




[DISABLE]
updown.destroy()

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) | ChildStructStart('PlayerController','bActorEnableCollision')
writeBytes(address,bActorEnableCollision)
end

local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MovementMode')
if address then
writeBytes(address,1)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Toggle Activation</Action>
                      <Keys>
                        <Key>102</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                  </Hotkeys>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26186</ID>
                      <Description>"WASD"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
wasd = createTimer()
wasd.Interval = 5
wasd.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_S) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)+20)
      end
    end
    if isKeyPressed(VK_W) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)-20)
      end
    end
    if isKeyPressed(VK_A) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)+20)
      end
    end
    if isKeyPressed(VK_D) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)-20)
      end
    end
  end
end

[DISABLE]
wasd.destroy()
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>26187</ID>
                  <Description>"bCanBeDamaged false (Godmode)      Numpad4 :Deactive, Numpad5 :Active"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end

[ENABLE]
--CanBeDamaged = createTimer()
--CanBeDamaged.setInterval(1000)
--CanBeDamaged.OnTimer = function()
local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bCanBeDamaged')
if address then
local bCanBeDamaged=readBytes(address,1) &amp; ~ ChildStructStart('PlayerController','bCanBeDamaged')
writeBytes(address,bCanBeDamaged)
end
--end
 
 
[DISABLE]
--CanBeDamaged.destroy()

local address=getAddressSafe('[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+PlayerController.bCanBeDamaged')
if address then
local bCanBeDamaged=readBytes(address,1) | ChildStructStart('PlayerController','bCanBeDamaged')
writeBytes(address,bCanBeDamaged)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>101</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>100</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26188</ID>
                  <Description>"Jump Multiplier                                       Numpad0 :Deactive, Numpad1 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
jumpmultiplier=1
if syntaxcheck then return end
if not jumpdefault then jumpdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')end
if not MaxAccelerationdefault then MaxAccelerationdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')end
if not AirControldefault then AirControldefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')end
[ENABLE]
jumpmuti=createHotkey(function()jumpmultiplier=jumpmultiplier+0.5 end,VK_NUMPAD1)
jump = createTimer()
jump.setInterval(1000)
jump.OnTimer = function()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')
local address2=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')
local address3=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')
if address then writeFloat(address,jumpdefault*jumpmultiplier)
writeFloat(address2,MaxAccelerationdefault*jumpmultiplier)
writeFloat(address3,AirControldefault*jumpmultiplier)
end
end
[DISABLE]
jump.destroy()
jumpmuti.destroy()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.JumpZVelocity')
local address2=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxAcceleration')
local address3=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.AirControl')
if address then writeFloat(address,jumpdefault)
writeFloat(address2,MaxAccelerationdefault)
writeFloat(address3,AirControldefault)
end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>97</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>96</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26189</ID>
                  <Description>"WalkSpeed Multiplier                             Numpad2 :Deactive, Numpad3 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
walkmultiplier=1
if syntaxcheck then return end
if not walkdefault then walkdefault=readFloat('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')end
[ENABLE]
walkpmuti=createHotkey(function() walkmultiplier=walkmultiplier+0.5 end,VK_NUMPAD3)
walk = createTimer()
walk.setInterval(1000)
walk.OnTimer = function()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')
if address then writeFloat(address,walkdefault*walkmultiplier)end
end
[DISABLE]
walk.destroy()
walkpmuti.destroy()
local address=getAddressSafe('[[[[[[[GEngine]+GameEngine.GameInstance]+GameInstance.LocalPlayers]]+LocalPlayer.PlayerController]+PlayerController.Character]+GPlayer.CharacterMovement]+MovementComponent.MaxWalkSpeed')
if address then writeFloat(address,walkdefault)end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>99</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>98</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26190</ID>
                  <Description>"UWorld"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>GameViewportClient.World</Offset>
                    <Offset>GameEngine.GameViewport</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>26191</ID>
                  <Description>"Player"</Description>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>PlayerController.Character</Offset>
                    <Offset>LocalPlayer.PlayerController</Offset>
                    <Offset>0</Offset>
                    <Offset>GameInstance.LocalPlayers</Offset>
                    <Offset>GameEngine.GameInstance</Offset>
                  </Offsets>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26192</ID>
                      <Description>"CharacterMovement"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <GroupHeader>1</GroupHeader>
                      <Address>+GPlayer.CharacterMovement</Address>
                      <Offsets>
                        <Offset>0</Offset>
                      </Offsets>
                      <CheatEntries>
                        <CheatEntry>
                          <ID>26193</ID>
                          <Description>"JumpZVelocity"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.JumpZVelocity</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26194</ID>
                          <Description>"MaxWalkSpeed"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxWalkSpeed</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26195</ID>
                          <Description>"MaxWalkSpeedCrouched"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxWalkSpeedCrouched</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26196</ID>
                          <Description>"MaxAcceleration"</Description>
                          <VariableType>Float</VariableType>
                          <Address>+MovementComponent.MaxAcceleration</Address>
                        </CheatEntry>
                      </CheatEntries>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>26197</ID>
              <Description>"Tools"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>26198</ID>
                  <Description>"FNamePool scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

print('------------------')
local isUnicode=false
local strlist,result,result2,result3,pointer1,pointer2,pointer3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  result=stringscan('IntProperty',getAddressSafe(strlist[i]),getAddressSafe(strlist[i]..'+50'),isUnicode)
  if #result&gt;0 then
    result=stringscan('None',getAddressSafe(strlist[i]..'-50'),getAddressSafe(strlist[i]),isUnicode)
    print(strlist[i])
    if #result&gt;0 then
      if string.sub(strlist[i],strlist[i]:len()-3,strlist[i]:len()-2)=='00' then
        result=pointerscan(getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00'))
        for j=1,#result do
          pointer1=readPointer(result[j]..(targetIs64Bit() and '+8' or '+4'))
          pointer1=readPointer(pointer1)
          pointer2=readPointer(result[j]..(targetIs64Bit() and '+10' or '+8'))
          pointer2=readPointer(pointer2)
          pointer3=readPointer(result[j]..(targetIs64Bit() and '+18' or '+C'))
          pointer3=readPointer(pointer3)

          if pointer1 and pointer2 and pointer3 then
            print(strlist[i]..'&lt;-'..result[j])
            unregisterSymbol('FNamePool')
            registerSymbol('FNamePool',result[j]..'-10',true)
            if ue4versioncheck()&lt;=2 then UE4ver=23 end

            if string.sub(result[j],result[j]:len()-1,result[j]:len())=='00' then
              result2=pointerscan(getAddressSafe(result[j]))
              for k=1,#result2 do
                print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
                result3=pointerscan(getAddressSafe(result2[k]),getAddress(process),getAddress(process)+getModuleSize(process))
                for l=1,#result3 do
                  print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l])
                  unregisterSymbol('FNamePool')
                  registerSymbol('FNamePool',result3[l],true)
                  if ue4versioncheck()&lt;=2 then UE4ver=22 end
                  goto done
                end
              end
            end
          end
        end
      end
    end
  end
end
::done::
print('done')

[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26199</ID>
                  <Description>"FNamePool scanner V2 (Generic)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

print('------------------')
local isUnicode=false
local strlist,result,result2,result3,pointer1,pointer2,pointer3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  result=stringscan('IntProperty',getAddressSafe(strlist[i]),getAddressSafe(strlist[i]..'+50'),isUnicode)
  if #result&gt;0 then
    result=stringscan('None',getAddressSafe(strlist[i]..'-50'),getAddressSafe(strlist[i]),isUnicode)
    print(strlist[i])
    if #result&gt;0 then
      if string.sub(strlist[i],strlist[i]:len()-3,strlist[i]:len()-2)=='00' then
        result=pointerscan(getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00'),nil,nil,getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00')+0x50)
        for j=1,#result do
          pointer1=readPointer(result[j]..(targetIs64Bit() and '+8' or '+4'))
          pointer1=readPointer(pointer1)
          pointer2=readPointer(result[j]..(targetIs64Bit() and '+10' or '+8'))
          pointer2=readPointer(pointer2)
          pointer3=readPointer(result[j]..(targetIs64Bit() and '+18' or '+C'))
          pointer3=readPointer(pointer3)

          if pointer1 and pointer2 and pointer3 then
            print(strlist[i]..'&lt;-'..result[j])
            unregisterSymbol('FNamePool')
            registerSymbol('FNamePool',result[j]..'-10',true)
            if ue4versioncheck()&lt;=2 then UE4ver=23 end

            --if string.sub(result[j],result[j]:len()-1,result[j]:len())=='00' then
              result2=pointerscan(getAddressSafe(result[j]))
              for k=1,#result2 do
                print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
                if inModule(result2[k]) then UE4ver=ue4versioncheck() unregisterSymbol('FNamePool') registerSymbol('FNamePool',result2[k],true) goto done end
                result3=pointerscan(getAddressSafe(result2[k]),getAddress(process),getAddress(process)+getModuleSize(process))
                for l=1,#result3 do
                  print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l])
                  unregisterSymbol('FNamePool')
                  registerSymbol('FNamePool',result3[l],true)
                  if ue4versioncheck()&lt;=2 then UE4ver=22 end
                  goto done
                end
              end
            --end
          end
        end
      end
    end
  end
end
::done::
print('done')

[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26200</ID>
                  <Description>"FNamePool scanner V3 (Unicode)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

print('------------------')
local isUnicode=true
local strlist,result,result2,result3,pointer1,pointer2,pointer3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  print(strlist[i])
  result=pointerscan(getAddress(strlist[i])-0x50,nil,nil,getAddress(strlist[i]))
  for j=1,#result do
    if string.sub(result[j],result[j]:len()-3,result[j]:len()-2)=='00' then
      print(result[j])
      pointer1=readPointer(result[j]..(targetIs64Bit() and '+8' or '+4'))
      pointer1=readPointer(pointer1)
      pointer2=readPointer(result[j]..(targetIs64Bit() and '+10' or '+8'))
      pointer2=readPointer(pointer2)
      pointer3=readPointer(result[j]..(targetIs64Bit() and '+18' or '+C'))
      pointer3=readPointer(pointer3)
      if pointer1 and pointer2 and pointer3 then
         print(strlist[i]..'&lt;-'..result[j])
         result2=pointerscan(getAddressSafe(string.sub(result[j],1,result[j]:len()-2)..'00'))
         for k=1,#result2 do
           print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
           if inModule(result2[k]) then UE4ver=ue4versioncheck() unregisterSymbol('FNamePool') registerSymbol('FNamePool',result2[k],true) goto done end

         end
      end
    end
  end
end
::done::
print('done')
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26201</ID>
                  <Description>"FNamePool scanner V4 (BatmanAk)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

print('------------------')
local isUnicode=false
local size= targetIs64Bit() and 8 or 4
local result2,result,result3,result4,pointer1,pointer2,pointer3,tempstringoffset,str,tempfnamepooloffset=stringscan('ByteProperty',nil,nil,isUnicode)
for i=1,#result2 do
--print(result2[i])
  result=pointerscan(getAddress(result2[i]..'-50'),nil,nil,getAddress(result2[i]))

  for j=1,#result do
    tempstringoffset=getAddress(result2[i])-readPointer(getAddress(result[j]))

    for k=size,0x50,4 do
      str=readString(readPointer(getAddress(result[j])+k)+tempstringoffset,0x30,isUnicode)
      if str and str=='IntProperty' then
        stringoffset=tempstringoffset
        print(result2[i]..'&lt;-'..result[j])

        result3=pointerscan(getAddress(result[j]..'-50')-k,nil,nil,getAddress(result[j]))
        for m=1,#result3 do


          pointer1=readPointer(result3[m]..(targetIs64Bit() and '+8' or '+4'))
          pointer1=readPointer(pointer1)
          pointer2=readPointer(result3[m]..(targetIs64Bit() and '+10' or '+8'))
          pointer2=readPointer(pointer2)
          pointer3=readPointer(result3[m]..(targetIs64Bit() and '+18' or '+C'))
          pointer3=readPointer(pointer3)

          if pointer1 and pointer2 and pointer3 then
            print(result2[i]..'&lt;-'..result[j]..'&lt;-'..result3[m])

            --print(result2[i]..'&lt;-'..result[j]..'&lt;-'..result3[m])
            stringoffset2=0xc--((getAddress(result[j])-readPointer(result3[m])+size)/2)-size
          --print(string.format('%X',((getAddress(result[j])-readPointer(result3[m])+size)/2)-size))
            stringmul=k

            result4=pointerscan(getAddress(result3[m])-0x50,process,nil,getAddress(result3[m])+0x50)
            for n=1,#result4 do
              print(result2[i]..'&lt;-'..result[j]..'&lt;-'..result3[m]..'&lt;-'..result4[n])
              unregisterSymbol('FNamePool') registerSymbol('FNamePool',result4[n],true)
            end
          end
        end
      end
    end
  end
end
::done::
print('done')



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26202</ID>
                  <Description>"UE4 Object scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}

if syntaxcheck then return end

[ENABLE]
--unregisterSymbol('FNamePool')
--registerSymbol('FNamePool','libUE4.so+41DE8A4',true)
--UE4ver=nil
--if not UE4ver then ue4versioncheck()end
--ue4config()
--ue4parsetable()
ue4parsetableFNamePool()

FNameStringAlgo(1,true)
FNameStringAlgo(3,true)
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

Aligned=true
function ue4parsetablecheck()
end


local Object=FindStringFName('Object')
local Class=FindStringFName('Class')
local CoreUObject=FindStringFName('/Script/CoreUObject')
if not UObject then  UObject = {} end
print(Object)
print(Class)
print(CoreUObject)
local size,pointer,pointer2,pointer3=(targetIs64Bit() and 8 or 4)
local result,result2=groupscan('4:'..Object)
print(#result)
for i=1,#result do
  if checkvalue(getAddress(result[i])-0x50,0x50,1,4)then
    for j=0,0x100,size do
      pointer=readPointer(getAddress(result[i])-0x50+j)
      if not pointer then break end
      if checkvalue(pointer,0x50,Class,4) then
        pointer3=pointer
        for k=0,0x100,size do
          local pointer=readPointer(getAddress(result[i])-0x50+k)
          if not pointer then break end
          if checkvalue(pointer,0x50,CoreUObject,4)then

            --print(result[i])
            local value=targetIs64Bit() and readInteger(pointer+4) or readSmallInteger(pointer+2)
            --print(string.format('%X',readInteger(pointer)))

            if targetIs64Bit() then pointer2=checkvalue(getAddress(result[i])-0x50,0x50,value,(size/2))
            else
              for p=0,10 do
                if pointer2 then break end
                pointer2=checkvalue(getAddress(result[i])-0x50,0x50,value-5+p,(size/2))
              end
            end
            if pointer2 then
              pointer2=pointer2-(size/2)
              print(string.format('%X',pointer2))

              if checkvalue(pointer2+size,0x50,1,4)then UObject.ObjectId=checkvalue(pointer2+size,0x50,1,4)-pointer2
              else UObject.ObjectId=checkvalue(pointer2,0x50,1,4)-pointer2 end
              UObject.Class=checkvalue(pointer2+size,0x50,pointer3,size)-pointer2
              UObject.FNameIndex=checkvalue(pointer2+size,0x50,Object,4)-pointer2
              UObject.Outer=checkvalue(pointer2+size,0x50,pointer,size)-pointer2

              local str
              if UE4ver&lt;9 and targetIs64Bit() then
                str=string.format('8:0x%X 8:0x%X',pointer,pointer2)
              elseif UE4ver&lt;9 then
                str=string.format('4:0x%X 4:0x%X',pointer,pointer2)
              elseif targetIs64Bit() then
                str=string.format('8:0x%X 8:* 8:* 8:0x%X',pointer,pointer2)
              else
                str=string.format('4:0x%X 4:* 4:* 4:* 4:0x%X',pointer,pointer2)
              end
              print(str)
              result2=groupscan(str)
              for n=1,#result2 do
                local result3
                if not Aligned or getAddress(result2[n])%size==0 then
                  print(string.format('%X&lt;-%s',pointer2,result2[n]))
                  --result3=pointerscan(getAddress(result2[n]:sub(1,result2[n]:len()-2)..'00'))
                end
                if not result3 or #result3&lt;=0 then result3=pointerscan(getAddress(result2[n]))end
                for o=1,#result3 do
                  local result4
                  if not Aligned or getAddress(result3[o])%size==0 then

                    --if not inModule(result3[o]) then
                      print(string.format('%X&lt;-%s&lt;-%s',pointer2,result2[n],result3[o]))

                    --end

                    if inModule(result3[o]) and (readInteger(result3[o]..'-10+1C')&lt;0x7FFFFF or readInteger(result3[o]..'-10+24')&lt;0x7FFFFF) then
                      unregisterSymbol('GUObjectArray')
                      registerSymbol('GUObjectArray',result3[o]..'-10',true)
                      goto done
                    end

                    result4=pointerscan(getAddress(result3[o]))


                  end
                  if not result4 then result4={}end
                  for q=1,#result4 do
                    if not Aligned or getAddress(result4[q])%size==0 then
                      print(string.format('%X&lt;-%s&lt;-%s&lt;-%s',pointer2,result2[n],result3[o],result4[q]))

                      if inModule(result4[q]) then
                        unregisterSymbol('GUObjectArray')
                        registerSymbol('GUObjectArray',result4[q]..'-10',true)
                        goto done
                      end

                    end
                  end
                end
              end
            end
          end
        end
      end
    end
  end
end
::done::

if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
  if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
  else UE4ver=20 end
end

print('done\n')

ue4parsetable() 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26203</ID>
                  <Description>"UE4 Object scanner V2"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}

if syntaxcheck then return end

[ENABLE]
--unregisterSymbol('FNamePool')
--registerSymbol('FNamePool','libUE4.so+41DE8A4',true)
--UE4ver=nil
--if not UE4ver then ue4versioncheck()end
--ue4config()
--ue4parsetable()
ue4parsetableFNamePool()

FNameStringAlgo(1,true)
FNameStringAlgo(3,true)
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

Aligned=true
function ue4parsetablecheck()
end


local Object=FindStringFName('Object')
local Class=FindStringFName('Class')
local CoreUObject=FindStringFName('/Script/CoreUObject')
if not UObject then  UObject = {} end
print(Object)
print(Class)
print(CoreUObject)
local size,pointer,pointer2,pointer3=(targetIs64Bit() and 8 or 4)
local result,result2=groupscan('4:'..Object)
print(#result)
for i=1,#result do
  if checkvalue(getAddress(result[i])-0x50,0x50,1,4)then
    for j=0,0x100,size do
      pointer=readPointer(getAddress(result[i])-0x50+j)
      if not pointer then break end
      if checkvalue(pointer,0x50,Class,4) then
        pointer3=pointer
        for k=0,0x100,size do
          local pointer=readPointer(getAddress(result[i])-0x50+k)
          if not pointer then break end
          if checkvalue(pointer,0x50,CoreUObject,4)then

            --print(result[i])
            local value=targetIs64Bit() and readInteger(pointer+4) or readSmallInteger(pointer+2)
            --print(string.format('%X',readInteger(pointer)))

            if targetIs64Bit() then pointer2=checkvalue(getAddress(result[i])-0x50,0x50,value,(size/2))
            else
              for p=0,10 do
                if pointer2 then break end
                pointer2=checkvalue(getAddress(result[i])-0x50,0x50,value-5+p,(size/2))
              end
            end
            if pointer2 then
              pointer2=pointer2-(size/2)
              print(string.format('%X',pointer2))

              UObject.ObjectId=checkvalue(pointer2+size,0x50,1,4)-pointer2
              UObject.Class=checkvalue(pointer2+size,0x50,pointer3,size)-pointer2
              UObject.FNameIndex=checkvalue(pointer2+size,0x50,Object,4)-pointer2
              UObject.Outer=checkvalue(pointer2+size,0x50,pointer,size)-pointer2

              local str

              for p=4,0,-1 do
                str=string.format('%u:0x%X',size,pointer)
                for q=1,p do
                  str=str..' 4:*'
                end
                str=str..string.format(' %u:0x%X',size,pointer2)
                UObjectMul=(4*p)+size

                print(str)


                result2=groupscan(str)
                for n=1,#result2 do
                  local result3
                  if result2[n]:sub(result2[n]:len()-1,result2[n]:len())=='00' then
                    print(string.format('%X&lt;-%s',pointer2,result2[n]))
                    result3=pointerscan(getAddress(result2[n]))
                  end
                  if not result3  then result3={}end
                  for o=1,#result3 do
                    local result4
                    if not Aligned or getAddress(result3[o])%size==0 then
                      --if not inModule(result3[o]) then
                        print(string.format('%X&lt;-%s&lt;-%s',pointer2,result2[n],result3[o]))
                      --end
                      if inModule(result3[o]) and (readInteger(result3[o]..'-10+1C')&lt;0x7FFFFF or readInteger(result3[o]..'-10+24')&lt;0x7FFFFF) then
                        unregisterSymbol('GUObjectArray')
                        registerSymbol('GUObjectArray',result3[o]..'-10',true)
                        result4=pointerscan(getAddress(result3[o]..'-10'),process)
                        if result4[1] then
                          print(string.format('%X&lt;-%s&lt;-%s&lt;-%s',pointer2,result2[n],result3[o],result4[1]))
                          unregisterSymbol('GUObjectArray')
                          registerSymbol('GUObjectArray',result4[1],true)
                        end
                        goto done
                      end
                      result4=pointerscan(getAddress(result3[o]))
                    end
                    if not result4 then result4={}end
                    for q=1,#result4 do
                      if not Aligned or getAddress(result4[q])%size==0 then
                        print(string.format('%X&lt;-%s&lt;-%s&lt;-%s',pointer2,result2[n],result3[o],result4[q]))
                        if inModule(result4[q]) then
                          unregisterSymbol('GUObjectArray')
                          registerSymbol('GUObjectArray',result4[q]..'-10',true)

                          goto done
                        end
                      end
                    end
                  end
                end
              end

            end
          end
        end
      end
    end
  end
end
::done::

if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
  if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
  elseif readInteger('GUObjectArray+14')==0 then UE4ver=9
  else UE4ver=20 end
end

print('done\n')

ue4parsetable() 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26204</ID>
                  <Description>"UE4 Auto config"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end

[ENABLE]
if not UObject then UObject = {} end
local size,pointer,pointers=(targetIs64Bit() and 8 or 4)
local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
local GameEngine=StaticFindObjectAlgo('/Script/Engine.GameEngine')
local Engine=StaticFindObjectAlgo('/Script/Engine.Engine')
print(string.format('GameEngine = %X',GameEngine))
print(string.format('Engine = %X\n',Engine))
UObject.super=checkvalue(GameEngine,0x100,Engine,size)-GameEngine
local Name,Typ
for i=GameEngine,GameEngine+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Property ') then pointer=readPointer(i) UObject.member=i-GameEngine break end
end
Typ=Name:sub(1,string.find(Name,' ')-1)

UObject.propsize=checkvalue(pointer,0x100,varsize[ue4type[Typ]],4)-pointer
local classsize=readInteger(UObject.member+size+GameEngine)
UObject.Offset=checkvalue(pointer,0x100,tostring(classsize-0x100)..'~'..tostring(classsize),4)-pointer

for i=pointer,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Property ') then UObject.nextmember=i-pointer break end
end

pointer=readPointer(Engine+UObject.member)
for i=pointer+UObject.nextmember,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Class ') then UObject.Property=i-pointer break end
end

UObject.bitmask=UObject.Property+2

pointer=StaticFindObjectAlgo('/Script/CoreUObject.Object:ExecuteUbergraph')
print(string.format('ExecuteUbergraph = %X\n',pointer))

for i=pointer+UObject.Property,pointer+0x100,size do
  if inModule(readPointer(i)) then UObject.funct=i-pointer break end
end

pointer=StaticFindObjectAlgo('/Script/CoreUObject.EInterpCurveMode')
print(string.format('EInterpCurveMode = %X\n',pointer))
for j=size,0x50,size do
  pointers=readPointer(pointer+UObject.Outer+j)
      --pointers=readPointer(pointers)
  if pointers and checkvalue(pointers,0x50,'CIM_Linear',1) then
    UObject.enumoffset=UObject.Outer+j
    pointer=readPointer(pointer+UObject.enumoffset)
    print(string.format('EInterpCurveMode enums = %X\n',pointer))
    UObject.enumname=checkvalue(pointer,0x50,'CIM_Linear',1)-pointer
    UObject.enumindex=checkvalue(pointer,0x50,1,2) and checkvalue(pointer,0x50,1,2)-checkvalue(pointer,0x50,'CIM_CurveAuto',1) or 4
    for k=UObject.enumname+8,0x50,4 do
      if readInteger(pointer+k)&gt;4 and FNameStringAlgo(readInteger(pointer+k),true) then UObject.enummul=k break end
    end

    break
  end
end

print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
UObject.funct = 0x%X
UObject.enumoffset = 0x%X
UObject.enummul = 0x%X
UObject.enumname = 0x%X
UObject.enumindex = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask,UObject.funct,UObject.enumoffset,
UObject.enummul,UObject.enumname,
UObject.enumindex))
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26205</ID>
                  <Description>"UE3 Object scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}

if syntaxcheck then return end

[ENABLE]
UE4ver=ue4versioncheck()
--unregisterSymbol('FNamePool')
--registerSymbol('FNamePool','libUE4.so+41DE8A4',true)
--UE4ver=nil
--if not UE4ver then ue4versioncheck()end
--ue4config()
--ue4parsetable()
ue4parsetableFNamePool()

FNameStringAlgo(1,true)
FNameStringAlgo(3,true)
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

Aligned=true
function ue4parsetablecheck()
end


local Object=FindStringFName('Object',isMassEffect)
if not UObject then  UObject = {} end
print(Object)
local size,pointer,pointer1,pointer2,pointer3=(targetIs64Bit() and 8 or 4)
local result,result2=groupscan('4:'..Object)
print(#result)
for i=1,#result do
  pointer=getAddress(result[i])-0x50
  for j=0,0x200,4 do
    pointer1=checkvalue(readPointer(pointer+j),0x200,'Class',1)
    if pointer1 then
      for k=0,0x200,4 do
        pointer2=checkvalue(readPointer(pointer+k),0x200,'Core',1)
        if pointer2 then
          print(result[i])
          pointer1=pointer1-readPointer(pointer+j)
          pointer2=pointer2-readPointer(pointer+k)
          if pointer1==pointer2 then
            pointer=getAddress(result[i])-pointer1
            print(string.format('%X',pointer))
            for l=1,3 do
              pointer3=checkvalue(pointer+size,0x100,l,4)
              if pointer3 then print(l)
                UObject.ObjectId=pointer3-pointer
                UObject.FNameIndex=pointer1
                UObject.Class=pointer1+j-0x50
                UObject.Outer=pointer1+k-0x50

                result2=pointerscan(pointer)
                for m=1,#result2 do
                  local val=0
                  for o=1,100 do
                    val=o
                    if not readPointer(readPointer(readPointer(getAddress(result2[m])+o*size))) then break end
                  end

                  if val==100 then
                    print(string.format('%X',getAddressSafe(result2[m])-(size*l)))
                    result=pointerscan(getAddressSafe(result2[m])-(size*l),process)
                    unregisterSymbol('GUObjectArray')
                    registerSymbol('GUObjectArray',getAddressSafe(result2[m])-(size*l),true)
                    NOGUObjectsize=true

                    for n=1,#result do
                      print(result2[m]..'&lt;-'..result[n])
                      if inModule(result[n]) and getAddress(result[n])%4==0 then
                        unregisterSymbol('GUObjectArray')
                        registerSymbol('GUObjectArray',result[n],true)
                        NOGUObjectsize=nil
                        goto done
                      end
                    end
                  end
                  if m==#result2 then goto done end
                end
              end
            end
          end
        end
      end
    end
  end
end
::done::
--[[
if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
  if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
  elseif readInteger('GUObjectArray+14')==0 then UE4ver=9
  else UE4ver=20 end
end
]]

ue4parsetable()
print('done\n')
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26206</ID>
                  <Description>"UE3 Auto config"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end

[ENABLE]

if not UObject then UObject = {} end
local size,pointer,pointers=(targetIs64Bit() and 8 or 4)
local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
local GameEngine=StaticFindObjectAlgo('Engine.GameEngine')
local Engine=StaticFindObjectAlgo('Engine.Engine')
print(string.format('GameEngine = %X',GameEngine))
print(string.format('Engine = %X\n',Engine))
UObject.super=checkvalue(GameEngine,0x100,Engine,size)-GameEngine
local Name,Typ
for i=GameEngine+UObject.Outer,GameEngine+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and (string.find(Name,'Function ') or string.find(Name,'Property ')) then pointer=readPointer(i) UObject.member=i-GameEngine break end
end

for i=UObject.Outer+size,0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(pointer+i))
  if Name and  (string.find(Name,'Property ') or string.find(Name,'Function ') or string.find(Name,'Struct ')) and not string.find(Name,'Core') then
    Name=GetFullNameSafeAlgo(readPointer(readPointer(pointer+i)+i))
      if Name and  (string.find(Name,'Property ') or string.find(Name,'Function ') or string.find(Name,'Struct ')) and not string.find(Name,'Core') then
        UObject.nextmember=i break
      end
  end
end

for i=0,100 do
  pointer=readPointer(UObject.nextmember+pointer)
  Name=GetFullNameSafeAlgo(pointer)
  --print(Name)
  if Name and string.find(Name,'ObjectProperty ') then break end
end

Typ=Name:sub(1,string.find(Name,' ')-1)
--print(string.format('%X = %s',pointer,GetFullNameSafeAlgo(pointer)))
print(string.format('%s = %X',Name,pointer))
UObject.propsize=checkvalue(pointer+UObject.Outer,0x100,varsize[ue4type[Typ]],2)-pointer
local classsize=readInteger(UObject.member+size+GameEngine)
if classsize==0 then classsize=UObject.Outer+0x200 end
print((classsize-0x200)..' ~ '..(classsize+0x1000))
UObject.Offset=checkvalue(pointer+UObject.propsize,0x50,tostring(classsize-0x200)..'~'..tostring(classsize+0x1000),2)-pointer


--pointer=readPointer(Engine+UObject.member)
for i=pointer+UObject.nextmember,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Class ') then UObject.Property=i-pointer break end
end

UObject.bitmask=UObject.Property+2

pointer=StaticFindObjectAlgo('Core.Object:FindObject')
print(string.format('FindObject = %X\n',pointer))
for i=pointer+UObject.ObjectId,pointer+0x100,4 do
  if inModule(readPointer(i)) then UObject.funct=i-pointer break end
end

pointer=StaticFindObjectAlgo('Core.Object.EInterpCurveMode')
print(string.format('EInterpCurveMode = %X\n',pointer))
for i=size,0x50,size do
  pointers=readPointer(pointer+UObject.Outer+i)
  pointers=readPointer(pointers)
  if pointers then
    for j=size,0x50,size do
      pointers=readPointer(pointer+UObject.Outer+i+j)
      --pointers=readPointer(pointers)
      if pointers and checkvalue(pointers,0x50,'CIM_Linear',1) then
        UObject.enumoffset=UObject.Outer+i+j
        pointer=readPointer(pointer+UObject.enumoffset)
        UObject.enumname=0--checkvalue(pointer,0x50,FindStringFName('CIM_Linear'),4)-pointer
        UObject.enumindex=4--checkvalue(pointer,0x50,1,4)-checkvalue(pointer,0x50,FindStringFName('CIM_CurveAuto'),4)
        UObject.enummul=8--checkvalue(pointer,0x50,2,4)-checkvalue(pointer,0x50,1,4)
        break
      end
    end
    break
  end
end


print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
UObject.funct = 0x%X
UObject.enumoffset = 0x%X
UObject.enummul = 0x%X
UObject.enumname = 0x%X
UObject.enumindex = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask,UObject.funct,UObject.enumoffset,
UObject.enummul,UObject.enumname,
UObject.enumindex))
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26207</ID>
                  <Description>"to Single Line Address"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
function toStr(rec)
  local tec,str,list=rec,'',{}
  while(true)do
    if not tec or not tec.Address then break end
    list[#list+1]=tec
    tec=tec.Parent
  end
  for i=#list,1,-1 do
    str=string.format('%s%s',str,list[i].Address)
    for j=list[i].OffsetCount-1,0,-1 do
      str=string.format('[%s]+%s',str,list[i].OffsetText[j])
    end
  end
  return str
end

if syntaxcheck then return end
[ENABLE]

memrec.Child[0].Address=toStr(memrec.Child[0]) memrec.Child[0].OffsetCount=0
 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26208</ID>
                  <Description>"to Structural Address"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
function toStr(rec)
  local tec,str,list=rec,'',{}
  while(true)do
    if not tec or not tec.Address then break end
    list[#list+1]=tec
    tec=tec.Parent
  end
  for i=#list,1,-1 do
    str=string.format('%s%s',str,list[i].Address)
    for j=list[i].OffsetCount-1,0,-1 do
      str=string.format('[%s]+%s',str,list[i].OffsetText[j])
    end
  end
  return str
end

function toStructural(rec)
  local str,str2,list=toStr(rec),'',{}
  if str:find(']') then str2=str:sub(1,str:find(']')-1):gsub('%[','')
  else str2=str end
  rec.Address=str2
  while(true)do
    if not str:find(']') then break end
    str=str:sub(str:find(']')+2,str:len())
    if str:find(']') then str2=str:sub(1,str:find(']')-1):gsub('%[','')
    else str2=str end
    list[#list+1]=str2
  end
  rec.OffsetCount=#list+1
  for i=#list,1,-1 do
    rec.OffsetText[#list-i]=list[i]
  end
end

if syntaxcheck then return end
[ENABLE]

toStructural(memrec.Child[0])
 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26209</ID>
                  <Description>"Auto Assemble script"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
function GetFullName(object)
  if not GetFullNameMem then GetFullNameMem=allocateMemory(0x100)end
  executeCodeEx(0, nil, getAddress('GetFullName'), object, GetFullNameMem)
  local str=readPointer(GetFullNameMem)
  if str then str=readString(str,readInteger(GetFullNameMem+0x8)*2,true) end
  return str
end


if syntaxcheck then return end
[ENABLE]


 
 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26210</ID>
                  <Description>"DissectCode (Memory View -&gt; Ctrl+J or (Tools -&gt; Dissect code) )"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26211</ID>
                      <Description>"Save DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
getDissectCode().saveToFile(path)
--getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>26212</ID>
                      <Description>"Load DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
--getDissectCode().saveToFile(path)
getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>26214</ID>
          <Description>"Dumper V6.7"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>26215</ID>
              <Description>"Unreal Engine"</Description>
              <Options moHideChildren="1"/>
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript Async="1">{$lua}
function ue4config()
 local sub=targetIs64Bit() and 0 or 4
 UObject = {}

 --if UE4ver&lt;=2 and targetIs64Bit() then ue4determineversion() end
-----------------------------
----------UE4 struct---------
 if UE4ver&gt;7 then

    UObject.ObjectId= 0xC-sub
    UObject.Class = 0x10-sub
    UObject.FNameIndex = 0x18-(sub*2)
    UObject.Outer = 0x20-(sub*2)

  if UE4ver&gt;=25 then
    UObject.super= 0x40
    UObject.member= 0x50
    UObject.nextmember= 0x20
    UObject.Offset= 0x4C
    UObject.propsize=0x3C
    UObject.bitmask= 0x7A
    UObject.funct= 0xD8
    UObject.Property= 0x78
    UObject.enumoffset = 0x40
    UObject.enummul = 0x10
    UObject.enumname = 0x0
    UObject.enumindex = 0x8

  elseif UE4ver&gt;=22 then
    UObject.super= 0x40
    UObject.member= 0x48
    UObject.funct= 0xC0
  else
    UObject.super= 0x30 -(sub*4)
    UObject.member= 0x38 -(sub*5)
    UObject.funct= 0xB0
  end

  if UE4ver&lt;25 then
    UObject.nextmember=0x28-(sub*3)
    UObject.Offset= 0x44-(sub*4)
    UObject.propsize= 0x34-(sub*3/2)
    UObject.bitmask= 0x72-(sub*8)

    UObject.Property= 0x70-(sub*8)

  end

  if UE4ver&lt;11 then
    UObject.Offset= 0x4C
  end

----------------------------
---------UE3 struct---------
--1.25
--[[
 elseif UE4ver&gt;=1 then

    UObject.ObjectId= 0x4
    UObject.Outer = 0x14
    UObject.FNameIndex = 0x18
    UObject.Class = 0x20
    UObject.Offset= 0x48
    UObject.super= 0x34
    UObject.member= 0x38
    UObject.nextmember=0x28
    UObject.propsize= 0x30
    UObject.bitmask= 0x60
    UObject.Property= 0x58

]]
--0.10246
 else
 --[[
    UObject.ObjectId= 0x20
    UObject.Outer = 0x28
    UObject.FNameIndex = 0x2C
    UObject.Class = 0x34

    UObject.Offset= 0x60

    UObject.super= 0x48
    UObject.member= 0x4C

    UObject.nextmember=0x3C
    UObject.propsize= 0x44
    UObject.bitmask= 0x70]]

 end

---------------------------
end


ue4type={
		['BoolProperty']=vtByte,
		['ByteProperty']=vtByte,
		['FloatProperty']=vtSingle,
        ['StructProperty']=vtDword,
		['IntProperty']=vtDword,
        ['NameProperty']=vtQword,
        ['Int64Property']=vtQword,
		['TextProperty']=vtPointer,
        ['StrProperty']=vtPointer,
        ['ArrayProperty']=vtPointer,
        ['MapProperty']=vtPointer,
        ['ClassProperty']=vtPointer,
		['ObjectProperty']=vtPointer}

function ue4versioncheck()
 --if true then return 0 end
 local fileversion,info =getFileVersion(enumModules()[1].PathToFile)
 if not info then return 0 end
 return tonumber(info.minor..'.'..info.release)
end

function FNameStringAlgo(FName,IndexOnly)
 if not FName then return nil end
 local UEver=UE4ver
 local sub=targetIs64Bit() and 0 or 4
 local size=targetIs64Bit() and 8 or 4
 local number,str,pointer
 if not IndexOnly then
   number=UEver&gt;2 and readInteger(FName+4) or 0
   FName=readInteger(FName)
 else number=FName&gt;&gt;32 FName=FName&amp;0xFFFFFFFF
 end


 if not FName then return nil end

 if isMassEffect then
   local i=(FName&gt;&gt;0x1D)&amp;7
   FName=FName&amp;0x1FFFFFFF
   str=readString(readPointer(getAddress('FNamePool')+i*8)+FName+stringoffset)
   return str
 end

 if FNameList[FName] then
   if number&gt;0 then return FNameList[FName]..'_'..number-1 end
   return FNameList[FName]
 end

 local CFName=FName

 if readPointer(FNameString) then
   if not FNameStringStub then FNameStringStub=createExecuteCodeExStub(0,FNameString,0,0)end
   if not FNameStringRE then FNameStringRE=createRemoteExecutor()end

   if not mem then mem=allocateMemory(0x100)end
   writeQword(mem+0x50+UObject.FNameIndex,FName)
   FNameStringRE.executeStub(FNameStringStub,{mem+0x50,mem})
   str=readPointer(mem)
   if str then str=readString(str,readInteger(mem+0x8)*2,true) end
   --deAlloc(mem)

 elseif UEver&gt;=23 then
  local i=(FName&gt;&gt;0x10)
  FName=(FName&amp;0xFFFF)*2
  pointer=readPointer(FNamePool+i*size)

  local le =  readSmallInteger(pointer+FName)
  if not le then return nil end
  le=le&gt;&gt;6
  if le&gt;200 then return nil end
  local widechar=true and readBytes(pointer+FName,1)==1 or false
  --print(FName)
  le=(widechar and le*2 or le)-1
  if CFName==3 and not stringoffset then
    for k=2,0x20,2 do
      if readString(pointer+FName+k,le,widechar)=='ByteProperty' then stringoffset=k break end
      --print(k)
    end
  end

  if not stringoffset then return end

  str=readString(pointer+FName+stringoffset,le,widechar)
 else
  local i

  if FNamePool2 then FName= FName &lt;0x25A and readInteger(FName*4+FNamePool) or FName
  else
    i=UEver&gt;7 and (FName&gt;&gt;0xE) or 0
    FName= (UEver&gt;7 and (FName&amp;0x3FFF) or FName) *  (8-sub)
  end

  --print(i)
  --print(FName)


  local pointer
  if FNamePool2 then
    pointer=readPointer(FNamePool2)+FName
  else
    pointer=readPointer(FNamePool+i*size)
    if not readPointer(pointer) then return nil end
    pointer=readPointer(pointer+FName)
  end

  --print(string.format('%X',pointer))

  if not readPointer(pointer) then return nil end
  local pointers,pointers2=pointer
  if stringoffset2 then pointer=readPointer(pointer+stringoffset2)end
  pointers2=pointer

  --print(string.format('%X',pointer))

  --local offset=UE4ver&gt;=22 and 0xC-sub or 0x10-(sub*2)
  if CFName==1 and (not stringoffset or not stringoffsetid) then

     for k=0,0x30,4 do
        str=readString(pointer+k,13)
        if str=='ByteProperty' then stringoffset=k break end
      end

      if not stringoffset then
        for k=0,0x30,4 do
          str=readString(pointer+k,13*2,true)
          if str=='ByteProperty' then stringoffset=k forcewidechar=true break end
        end
      end

      pointer=pointers

     for j=0, stringoffset-4,4 do
       if readInteger(pointer+j)==2 then stringoffsetid=j end
     end
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
  --print(string.format('%X',offset))

  else
  if not stringoffset then return end
  --print(string.format('%X',pointer))

  pointer=pointers

  local widechar=stringoffsetid and (readInteger(pointer+stringoffsetid)&amp;1==1 or false) or false

  pointer=pointers2

  if stringoffset2 and not readPointer(pointer) then pointer=pointers+stringoffset2 end

  widechar= forcewidechar and true or widechar

  str= readString(pointer+stringoffset,200,widechar)

  if not str then str= readString(pointer+stringoffset,100,widechar) end
  if not str then str= readString(pointer+stringoffset,50,widechar) end
  if not str then str= readString(pointer+stringoffset,30,widechar) end
  if not str then
   local le=0
  --print(string.format('%X',FName))
  --print(string.format('%X',pointer))
   while(true)do
    if le&gt;50 then break end
    if readBytes(pointer+stringoffset+le)==0 then break end
    le=le+1
   end
   str= readString(pointer+stringoffset,le)
  end
  --print(stringoffset)


 end end
 if not str then return nil end
 if number&gt;0 then return str..'_'..number-1 end
 --print(str)
 FNameList[CFName]=str
 --print(str)
 return str
end

function GetNameAlgo(object)
 if not object then return nil end

 if ObjectList[object] then --print(ObjectList[object])
   return ObjectList[object]
 end
 local pointer,size,str1,str2=readPointer(object+UObject.Class),targetIs64Bit() and 8 or 4
 if not pointer then return nil end
 --print(string.format('%X',fnameoffset))
 --print(string.format('%X',object+fnameoffset))
 str1=FNameStringAlgo(readInteger(pointer+UObject.FNameIndex),true)

 --print(str1)
 --if readInteger(pointer+fnameoffset+4)~=0 then return nil end

 str2=FNameStringAlgo(readInteger(object+UObject.FNameIndex),true)
 --print(str2)
 if not str2 then str2=FNameStringAlgo(readInteger(object+UObject.FNameIndex-8),true)end
 --if str2=='None' then str2=FNameStringAlgo(readInteger(pointer+UObject.Outer+size),true)end
 if not str1 or str1=='None' or not str2 or str2=='None' then return nil end


 str1=str1..' '..str2
 --print(ObjectList[object])
 ObjectList[object]=str1
 return str1
end

function GetFullNameAlgo(object)
 if not object then return nil end
 --if ObjectList[object] then return ObjectList[object] end
 local pathoffset=UObject.Outer
 local fnameoffset=UObject.FNameIndex
 local str=GetNameAlgo(object)
 if not str then return nil end
 local number=readInteger(object+fnameoffset+4)
 local typ=str:sub(1,string.find(str,' ')-1)
 local isProperty=string.find(typ,'Property')
 if not isProperty then isProperty=string.find(typ,'Function') end
 local pointer=readPointer(object+pathoffset)
 while(true)do
  if not pointer or pointer==0 then break end
  local stri=GetNameAlgo(pointer)
  if not stri then break end
  typ=stri:sub(1,string.find(stri,' ')-1)
  local isPropertyc=string.find(typ,'Property')
  if not isPropertyc then isPropertyc=string.find(typ,'Function') end
  stri=string.sub(str,1,string.find(str,' '))..stri:sub(string.find(stri,' ')+1,stri:len())
  local num=readInteger(pointer+fnameoffset+4)

  if number~=num and num==0 or  not isPropertyc and isProperty then stri=stri..':'
  else stri=stri..'.' end
  number=num
  isProperty=isPropertyc

  str=stri..string.sub(str,string.find(str,' ')+1,str:len())
  pointer=readPointer(pointer+pathoffset)

  if string.find(str,'%./') then
    stri=string.sub(str,1,string.find(str,' '))
    str=stri..str:sub(string.find(str,'%./')+1,str:len())
  break end

 end
 if not str then return nil end
 --ObjectList[object]=str
 return str
end

function GetFullNameSuperAlgo(object)
  local super=UObject.super
  local str1 = GetFullNameSafeAlgo(object)
  if not str1 then return nil end
  local pointer = readPointer(object+super)
  if pointer then
    local str2 = GetFullNameSafeAlgo(pointer)
    if str2 then return str1..' ~ '..str2 end
  end
  return str1
end

function GetFullNameSafesAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 local str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end


function GetFullNameSafeAlgo(object)
 --if ObjectList[object] then return ObjectList[object] end
 local str= GetFullNameAlgo(object)
 if str then return str end
 local fnameoffset=0x28
 local typeoffset=0x8
 local pathoffset=0x10
 if not object then return nil end
 local pointer=readPointer(object+typeoffset)
 if not pointer then return nil end
 local str1=FNameStringAlgo(pointer)
 local str2=FNameStringAlgo(object+fnameoffset)
 local pointer=readPointer(object+pathoffset)
 if not pointer then return nil end
 local str3=GetFullNameAlgo(pointer)
 if not str3 then str3=GetFullNameSafesAlgo(pointer)end

 if not str1 or str1=='None' or not str2 or str2=='None' or not str3 then return nil end
 --print(str3)
 --if string.find(str3,'%./') then string.sub
 str=str1..string.sub(str3,string.find(str3,' '),str3:len())..':'..str2
 --ObjectList[object]=str
 return str
end

function FindString(namestr,start,stop,isNoIndex)
  local acclen=0
  for i=start,stop do
    local name=FNameStringAlgo(i+acclen,true)
    if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
      --print(name)
      if name and name:len()&lt;200 and name:len()&gt;2 and not string.find(name,'%c')  then
        if namestr==name then FNameResult=i+acclen return end
        if isNoIndex then acclen=acclen+name:len()end
      end
    end
  end
end


function FindStringFName(namestr,isNoIndex)
  local size
  if FNamePool2 then size=readInteger(FNamePool2+8)

  elseif UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
  elseif UE4ver&gt;7 then size=(#FNameDict&lt;&lt;0xE)-1
  else size=math.floor(#FNameDict[1]/4) end
  local count=0x200
  size=math.floor((size/count)+0.5)
  ue4parsetablecheck()
  FNameResult=nil
  local result
  local num,start,stop=count,0,0
  for i=0,size do
    start=i*num
    stop=(i+1)*num
    if FNameResult then break end
    createThread(FindString(namestr,start,stop-1,isNoIndex))
  end
  result=FNameResult
  FNameResult=nil
  return result
end

function getregionsize(address)
local allregion=enumMemoryRegions()
 for i=#allregion,1,-1 do
  if allregion[i].BaseAddress&lt;=address then
   local BaseAddress=allregion[i].BaseAddress
   local RegionSize=allregion[i].RegionSize
   local curSize=BaseAddress+RegionSize-address
   return curSize,RegionSize,BaseAddress,i
  end
 end
end

sub=targetIs64Bit() and 0 or 4

function ue4parsetableFNamePool()
  ObjectList={}
  FNameList={}
  if readPointer(FNameString) or string.find(process,'StateOfDecay2')then return end
  local pool=getAddressSafe('FNamePool')
  if pool then
    local pointer,pointers
    if not readPointer(readPointer(pool)) then pointer=pool+0x10
    else
      pointer=pool
      if readPointer(readPointer(readPointer(pointer)))then
        if readPointer(readPointer(readPointer(readPointer(pointer))))then
          pointer=readPointer(pointer)
        end
      end
    end
    if not readPointer(pointer)then pointer=readPointer(pool2+0x10)end
    FNamePool=pointer
    FNameDict={}
    local j=0
    for i=0,500 do
      pointers=readPointer(pointer+i*(8-sub))
      if readPointer(pointers) then
        FNameDict[i+1]=readBytes(pointers,getregionsize(pointers)-1,true)
      else j=j+1 end
      if j&gt;5 then break end
    end
  end
end

function ue4parsetables()
 local size=targetIs64Bit() and 8 or 4
 ue4parsetableFNamePool()
 local pool2=getAddressSafe('GUObjectArray')
 if pool2 then
  if NOGUObjectsize then
    GUObjectsize=0xFFFFFFFF
    if not readPointer(readPointer(GUObjectAddress))then
      GUObjectAddress=allocateMemory(0x100) writePointer(GUObjectAddress,pool2)
    end
    return
  end


  local pointer,pointers=readPointer(pool2)
  GUObjectsize=readInteger(pool2+size)
  if not readPointer(pointer)then GUObjectsize=readInteger(pool2+0x10+size*2+4) GUObjectsize= GUObjectsize==0xFFFFFFFF and readInteger(pool2+0x10+size+4)or GUObjectsize  pointer=readPointer(pool2+0x10)end
  if not readPointer(readPointer(pointer)) then pointer=pointer+0x10 end
  --if GetFullNameSafeAlgo(readPointer(pointer)) then pointer=pool2 end
  if not readPointer(readPointer(readPointer(readPointer(readPointer(pointer))))) then pointer=pool2 end
  if not readPointer(readPointer(pointer)) then pointer=pointer+0x10 end
  GUObjectAddress=pointer
 end
end

function ue4parsetable()
  ue4parsetables()
  local size=targetIs64Bit() and 8 or 4

  local pointerss=readPointer(GUObjectAddress)
  for i=size,0x50,4 do
    if readPointer(pointerss+i) and readPointer(readPointer(readPointer(pointerss+i))) then UObjectMul=i print(string.format('%X',i))break end
  end

  if not UObject.FNameIndex then
    for i=0,3 do
      pointer = readPointer(pointerss+i*UObjectMul)
      if readPointer(pointer) and checkvalue(pointer+size,0x100,'Object',1) then
        UObject.FNameIndex=checkvalue(pointer+size,0x50,'Object',1)-pointer
        UObject.ObjectId=checkvalue(pointer+size,0x100,i,4)-pointer
        for j=size,0x100,4 do
          if checkvalue(readPointer(pointer+j),0x100,'Class',1) then UObject.Class=j break end
        end
        for j=size,0x100,4 do
          if checkvalue(readPointer(pointer+j),0x100,'Core',1) then UObject.Outer=j break end
        end
        break
      end
    end
  end
  return true
end


function ue4parsetablecheck()
  if not readPointer(GUObjectAddress) or not readPointer(FNamePool) then return ue4parsetable() end
  local pointer
  pointer=readPointer(readPointer(GUObjectAddress))
  if not ObjectTable or not ObjectTable[1] or (ObjectTable[1].Address ~= pointer) then return ue4parsetable() end
--[[
  local Address,FullName
  for i=1,#ObjectTable do
    if ObjectTable[i] and i&gt;#ObjectTable-0x10 then FullName=ObjectTable[i].Type..' '..ObjectTable[i].FullName Address=ObjectTable[i].Address  break end
  end

  if not GetFullNameSafeAlgo(Address) or FullName~=GetFullNameSafeAlgo(Address) then return ue4parsetable()end
]]
 return false
end

function UE4AutoConfig()

if not UObject then UObject = {} end
local size,pointer,pointers=(targetIs64Bit() and 8 or 4)
local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
local GameEngine=StaticFindObjectAlgo('/Script/Engine.GameEngine')
local Engine=StaticFindObjectAlgo('/Script/Engine.Engine')
print(string.format('GameEngine = %X',GameEngine))
print(string.format('Engine = %X\n',Engine))
UObject.super=checkvalue(GameEngine,0x100,Engine,size)-GameEngine
local Name,Typ
for i=GameEngine,GameEngine+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Property ') then pointer=readPointer(i) UObject.member=i-GameEngine break end
end
Typ=Name:sub(1,string.find(Name,' ')-1)

UObject.propsize=checkvalue(pointer,0x100,varsize[ue4type[Typ]],4)-pointer
local classsize=readInteger(UObject.member+size+GameEngine)
UObject.Offset=checkvalue(pointer,0x100,tostring(classsize-0x100)..'~'..tostring(classsize),4)-pointer

for i=pointer,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Property ') then UObject.nextmember=i-pointer break end
end

pointer=readPointer(Engine+UObject.member)
for i=pointer+UObject.nextmember,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Class ') then UObject.Property=i-pointer break end
end

UObject.bitmask=UObject.Property+2

pointer=StaticFindObjectAlgo('/Script/CoreUObject.Object:ExecuteUbergraph')
print(string.format('ExecuteUbergraph = %X\n',pointer))

for i=pointer+UObject.Property,pointer+0x100,size do
  if inModule(readPointer(i)) then UObject.funct=i-pointer break end
end

pointer=StaticFindObjectAlgo('/Script/CoreUObject.EInterpCurveMode')
print(string.format('EInterpCurveMode = %X\n',pointer))
for j=size,0x50,size do
  pointers=readPointer(pointer+UObject.Outer+j)
      --pointers=readPointer(pointers)
  if pointers and checkvalue(pointers,0x50,'CIM_Linear',1) then
    UObject.enumoffset=UObject.Outer+j
    pointer=readPointer(pointer+UObject.enumoffset)
    print(string.format('EInterpCurveMode enums = %X\n',pointer))
    UObject.enumname=checkvalue(pointer,0x50,'CIM_Linear',1)-pointer
    UObject.enumindex=checkvalue(pointer,0x50,1,2) and (checkvalue(pointer,0x50,1,2)-checkvalue(pointer,0x50,'CIM_CurveAuto',1))&gt;0 and (checkvalue(pointer,0x50,1,2)-checkvalue(pointer,0x50,'CIM_CurveAuto',1)) or size
    for k=UObject.enumname+8,0x50,4 do
      if readInteger(pointer+k)&gt;4 and FNameStringAlgo(readInteger(pointer+k),true) then UObject.enummul=k break end
    end

    break
  end
end

print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
UObject.funct = 0x%X
UObject.enumoffset = 0x%X
UObject.enummul = 0x%X
UObject.enumname = 0x%X
UObject.enumindex = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask,UObject.funct,UObject.enumoffset,
UObject.enummul,UObject.enumname,
UObject.enumindex))

end

function UE3AutoConfig()


if not UObject then UObject = {} end
local size,pointer,pointers=(targetIs64Bit() and 8 or 4)
local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
local GameEngine=StaticFindObjectAlgo('Engine.GameEngine')
local Engine=StaticFindObjectAlgo('Engine.Engine')
print(string.format('GameEngine = %X',GameEngine))
print(string.format('Engine = %X\n',Engine))
UObject.super=checkvalue(GameEngine,0x100,Engine,size)-GameEngine
local Name,Typ
for i=GameEngine+UObject.Outer,GameEngine+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and (string.find(Name,'Function ') or string.find(Name,'Property ')) then pointer=readPointer(i) UObject.member=i-GameEngine break end
end

for i=UObject.Outer+size,0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(pointer+i))
  if Name and  (string.find(Name,'Property ') or string.find(Name,'Function ') or string.find(Name,'Struct ')) and not string.find(Name,'Core') then
    Name=GetFullNameSafeAlgo(readPointer(readPointer(pointer+i)+i))
      if Name and  (string.find(Name,'Property ') or string.find(Name,'Function ') or string.find(Name,'Struct ')) and not string.find(Name,'Core') then
        UObject.nextmember=i break
      end
  end
end

for i=0,100 do
  pointer=readPointer(UObject.nextmember+pointer)
  Name=GetFullNameSafeAlgo(pointer)
  --print(Name)
  if Name and string.find(Name,'ObjectProperty ') then break end
end

Typ=Name:sub(1,string.find(Name,' ')-1)
--print(string.format('%X = %s',pointer,GetFullNameSafeAlgo(pointer)))
print(string.format('%s = %X',Name,pointer))
UObject.propsize=checkvalue(pointer+UObject.Outer,0x100,varsize[ue4type[Typ]],2)-pointer
local classsize=readInteger(UObject.member+size+GameEngine)
if classsize==0 then classsize=UObject.Outer+0x200 end
print((classsize-0x200)..' ~ '..(classsize+0x1000))
UObject.Offset=checkvalue(pointer+UObject.propsize,0x50,tostring(classsize-0x200)..'~'..tostring(classsize+0x1000),2)-pointer


--pointer=readPointer(Engine+UObject.member)
for i=pointer+UObject.nextmember,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Class ') then UObject.Property=i-pointer break end
end

UObject.bitmask=UObject.Property+2

pointer=StaticFindObjectAlgo('Core.Object:FindObject')
print(string.format('FindObject = %X\n',pointer))
for i=pointer+UObject.ObjectId,pointer+0x100,4 do
  if inModule(readPointer(i)) then UObject.funct=i-pointer break end
end

pointer=StaticFindObjectAlgo('Core.Object.EInterpCurveMode')
print(string.format('EInterpCurveMode = %X\n',pointer))
for i=size,0x50,size do
  pointers=readPointer(pointer+UObject.Outer+i)
  pointers=readPointer(pointers)
  if pointers then
    for j=size,0x50,size do
      pointers=readPointer(pointer+UObject.Outer+i+j)
      --pointers=readPointer(pointers)
      if pointers and checkvalue(pointers,0x50,'CIM_Linear',1) then
        UObject.enumoffset=UObject.Outer+i+j
        pointer=readPointer(pointer+UObject.enumoffset)
        UObject.enumname=0--checkvalue(pointer,0x50,FindStringFName('CIM_Linear'),4)-pointer
        UObject.enumindex=4--checkvalue(pointer,0x50,1,4)-checkvalue(pointer,0x50,FindStringFName('CIM_CurveAuto'),4)
        UObject.enummul=8--checkvalue(pointer,0x50,2,4)-checkvalue(pointer,0x50,1,4)
        break
      end
    end
    break
  end
end


print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
UObject.funct = 0x%X
UObject.enumoffset = 0x%X
UObject.enummul = 0x%X
UObject.enumname = 0x%X
UObject.enumindex = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask,UObject.funct,UObject.enumoffset,
UObject.enummul,UObject.enumname,
UObject.enumindex))


end

function FindObject(pointer,start,stop,fullname)
  for j=start,stop do
    SaveObject(readPointer(pointer+j*UObjectMul))
    if FullNameList[fullname] then break end
  end
end

function StaticFindObjectAlgo(fullname)
  fullname=fullname:lower()
  if ue4parsetablecheck() then
    FullNameList={}
    ObjectLists={}
    ObjectTable={}
    HighestObjectID=0
  end
  if FullNameList[fullname] then return FullNameList[fullname].Address end

  local count=0x200
  local sizess= UObjectMul*count
  local ObjectId=UObject.ObjectId
  local num,start,stop
  totalobjects=0
  local size,pointer=targetIs64Bit() and 8 or 4

  for i=0,0x1000,size do
    pointer=readPointer(GUObjectAddress+i)
    if not readPointer(pointer) then break end
    size=getregionsize(pointer)
    num,start,stop=count,0,0
    for j=0,math.floor(size/sizess) do
      start=stop
      stop=stop+num
      --print(start..'~'..stop)

      createThread(FindObject(pointer,start,stop-1,fullname))
      if FullNameList[fullname] then return FullNameList[fullname].Address end
    end
  end
  return nil
end

function BasicObject(pointer,start,stop)
  Threadlist[#Threadlist+1]=i
  for j=start,stop do
    SaveObject(readPointer(pointer+j*UObjectMul))
  end
  Threadlist[#Threadlist]=nil
end

function BasicEnumObject()
  --ue4parsetablecheck()
  ObjectLists={}
  ObjectTable={}
  Threadlist={}
  FullNameList={}
  HighestObjectID=0
  starttime=os.clock()
  local count=0x200
  local sizess= UObjectMul*count
  local ObjectId=UObject.ObjectId
  local num,start,stop
  totalobjects=0
  local size,pointer=targetIs64Bit() and 8 or 4

  for i=0,0x1000,size do
    pointer=readPointer(GUObjectAddress+i)
    if not readPointer(pointer) then break end
    size=getregionsize(pointer)
    num,start,stop=count,0,0
    for j=0,math.floor(size/sizess) do
      start=stop
      stop=stop+num
      --print(start..'~'..stop)
      createThread(BasicObject(pointer,start,stop-1))
    end
  end
  for i=0,10000 do
    if #Threadlist==0 then break end
    sleep(1)
  end
  BasicEnumObjectCooldown=true
  createTimer(180000, function()BasicEnumObjectCooldown=nil end)
  print(string.format('\nA Total of %u objects has been found in %.3f seconds',totalobjects,os.clock()-starttime))
end

function registerFuncAlgo()
 if not UE_function then
   UE_function=createSymbolList()
   UE_function.register()
 end
 local sizes,pointer=HighestObjectID+10
 for i=1,sizes do
   if ObjectTable[i] and string.find(ObjectTable[i].Type,'Function') then
     pointer=readPointer(ObjectTable[i].Address+UObject.funct)
     if readPointer(pointer) then UE_function.addSymbol('UE_function',ObjectTable[i].FullName,pointer,1)end
   end
 end
end

function registerMemberAlgo()
  UEMember={}
  UEMemberClassFullName={}
  local size,Super=HighestObjectID+10
  for i=1,size do
    if ObjectTable[i] and ObjectTable[i].Member then
      Super=ObjectTable[i]
      Class={''}
      for k=0,5 do
        Class[#Class+1]=Super.Name..'.'
        if not Super.Super then break end
        Super=Super.Super
      end
      registerMember(ObjectTable[i].Address,ObjectTable[i].FullName)
    end
  end
  Class=nil
end


function registerMember(ObjectData,FullName,AddedName,AddedOffset)
  ObjectData=ObjectLists[ObjectData]
  local Name,Offset
  if not AddedName then AddedName='' end
  if not AddedOffset then AddedOffset=0 end
  if ObjectData.Member then
    for j=1,#ObjectData.Member do
      if ObjectData.Member[j].Offset then
        Offset=AddedOffset+ObjectData.Member[j].Offset
        Name=ObjectData.Member[j].Name
        if string.find(ObjectData.Type,'UserDefinedStruct') and string.find(Name,'_') then Name=Name:sub(1,string.find(Name,'_')-1)end
        Name=AddedName..Name
        for i=1,#Class do
          if not UEMember[(Class[i]..Name):lower()] then
            UEMember[(Class[i]..Name):lower()]=Offset
            UEMemberClassFullName[(Class[i]..Name):lower()]=FullName
          end
          if ObjectData.Member[j].Bit and not UEMember[(Class[i]..Name..'.Bit'):lower()] then
            UEMember[(Class[i]..Name..'.Bit'):lower()]=ObjectData.Member[j].Bit
            UEMemberClassFullName[(Class[i]..Name..'.Bit'):lower()]=FullName
          end
        end
        if string.find(ObjectData.Member[j].Type,'StructProperty') and ObjectData.Member[j].Property then registerMember(ObjectData.Member[j].Property[1].Address,FullName,Name..'.',Offset)end
      end
    end
  end
end


function GetName1(pointer)
  local class=readPointer(pointer+UObject.Class)
  if not class then return nil end
  local typ=readQword(class+UObject.FNameIndex)
  if not typ then return nil end
  local name=readQword(pointer+UObject.FNameIndex)
  typ=FNameStringAlgo(typ,true)
  name=FNameStringAlgo(name,true)
  return typ,name,readPointer(pointer+UObject.Outer),class
end

function GetName2(pointer)
  if not readPointer(pointer) then return nil end
  local typ=readQword(readPointer(pointer+8))
  if not typ then return nil end
  local name=readQword(pointer+0x28)
  typ=FNameStringAlgo(typ,true)
  name=FNameStringAlgo(name,true)
  return typ,name,readPointer(pointer+0x10)
end

function SaveObject(pointer)
   if not readPointer(pointer)then return nil end
   if ObjectLists[pointer] then return ObjectLists[pointer] end
   local objid=readInteger(pointer+UObject.ObjectId)
   if not objid then return nil end

   local typ,name,outer,class
   if UE4ver&lt;25 then typ,name,outer,class=GetName1(pointer)
   else typ,name,outer=GetName2(pointer)
     if not typ or string.find(typ,'None') or not name or string.find(name,'None') then
       typ,name,outer,class=GetName1(pointer)
     end
   end

   if not typ or string.find(typ,'None') or not name or string.find(name,'None') then return nil end

   local ObjectData,size,pointers={},targetIs64Bit() and 8 or 4

   ObjectData.Outer= outer~=0 and outer or nil
   ObjectData.Name=name
   ObjectData.Type=typ
   ObjectData.Address=pointer

   if not ObjectData.Name then
     --print(ObjectData.Address)
     ObjectData.Name='InvalidName'
   end
   if ObjectTable[objid+1] and ( not string.find(typ,'Property') or UE4ver&lt;25 ) then return ObjectTable[objid+1] end

   ObjectData.ObjectId=objid

   if not readPointer(objid) and objid&lt;0xFFFFFFF and ( not string.find(typ,'Property') or UE4ver&lt;25 ) then
     ObjectTable[objid+1]=ObjectData
     if HighestObjectID&lt;objid then HighestObjectID=objid end
   end

   ObjectLists[pointer]=ObjectData

   SaveObject(ObjectData.Outer)
   local dataNew,str,dataOld=ObjectData,ObjectData.Name

   for x=0,10 do
     if not dataNew.Outer or not ObjectLists[dataNew.Outer] then break end
     dataOld=dataNew
     dataNew=ObjectLists[dataNew.Outer]
     if (string.find(dataOld.Type,'Property') or string.find(dataOld.Type,'Function'))
     and (not string.find(dataNew.Type,'Property') and not string.find(dataNew.Type,'Function'))
     then
       str=dataNew.Name..':'..str
     else
       str=dataNew.Name..'.'..str
     end
   end
   ObjectData.FullName=str
   FullNameList[str:lower()]=ObjectData
   if class then
     class=SaveObject(class)
     if class then
       if not class.Instance then class.Instance={}end
       class.Instance[#class.Instance+1]=ObjectData
       ObjectData.Class=class
     end
   end

   totalobjects=totalobjects+1

   if not UObject.super or not UObject.member or not UObject.nextmember or not UObject.Offset
   or not UObject.propsize or not UObject.bitmask or not UObject.Property then
   return ObjectData end

   local super=readPointer(pointer+UObject.super)
   ObjectData.Super= super~=0 and super or nil
   if ObjectData.Super then ObjectData.Super=SaveObject(ObjectData.Super)end
   if ObjectData.Super then
     if not ObjectData.Super.Uper then ObjectData.Super.Uper={}end
     ObjectData.Super.Uper[#ObjectData.Super.Uper+1]=ObjectData
   end

   if string.find(typ,'Property')then
     ObjectData.Offset=readSmallInteger(pointer+UObject.Offset)
     ObjectData.Propsize=readSmallInteger(pointer+UObject.propsize)
     if string.find(typ,'StructProperty') or string.find(typ,'ObjectProperty') then
       ObjectData.Property={SaveObject(readPointer(pointer+UObject.Property))}
       if not ObjectData.Property[1] then ObjectData.Property=nil end
     elseif string.find(typ,'MapProperty') or string.find(typ,'ArrayProperty') then
       ObjectData.Property={SaveObject(readPointer(pointer+UObject.Property)),SaveObject(readPointer(pointer+UObject.Property+size))}
       if not ObjectData.Property[1] then ObjectData.Property=nil end
     elseif string.find(typ,'BoolProperty')then ObjectData.Bit=readBytes(pointer+UObject.bitmask,1) end
   else
     local member=SaveObject(readPointer(pointer+UObject.member))
     if member and (string.find(member.Type,'Function') or string.find(member.Type,'Property')) then
       LastObjectWithMember=ObjectData
       ObjectData.Member={member}
       for i=0,300 do
         member=SaveObject(readPointer(member.Address+UObject.nextmember))
         if not member then break end
         if not string.find(member.Type,'Function') then
           ObjectData.Member[#ObjectData.Member+1]=member
         end
       end
     end
   end

   return ObjectData
end

function isStructExist(name)
  for i=1,#StructList do
    if StructList[i].Name==name then return StructList[i] end
  end
  return nil
end

function SaveAndRemoveStruct()
  StructList={}
  local count=getStructureCount()
  for i=count-1,0,-1 do
    local struct=getStructure(i)
    StructList[i+1]=struct
    struct:removeFromGlobalStructureList()
  end
end

function DeleteStruct(Struct)
  local count=#StructList
  for i=1,count do
    if Struct==StructList[i] then
      Struct:Destroy()
      StructList[i]=nil
    end
    if not StructList[i] and StructList[i+1] then
      StructList[i]=StructList[i+1]
      StructList[i+1]=nil
    end
  end
end

function LoadStruct()
  for i=1,#StructList do
    StructList[i]:addToGlobalStructureList()
  end
end

function ChildStructStart(structname,elementname)
local struct=isStructExist(structname)
if struct then
for i=0,struct.Count-1 do
if struct.Element[i].Name==elementname then return struct.Element[i].ChildStructStart end end
else return nil end
end

function findAddress(name,number,AddressOrAOBString,modulename,stopaddress,Nth,aobscanOnly,gethead,nop)
	local size,address=0x100
    AddressOrAOBString,address=string.lower(AddressOrAOBString):gsub('banana','')
	if(address&gt;0)then
		local f
		if(modulename==0 or modulename==nil or modulename=='')then f=AOBScan(AddressOrAOBString)
		else
            if type(modulename)==type(0) then modulename=string.format('%X',modulename)
            elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
			local ms = createMemScan()
			if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
				stopaddress=getNameFromAddress(getAddress(modulename),true,false)
                if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
				if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
                modulename=getAddress([["]]..stopaddress..[["]])
				stopaddress=modulename+getModuleSize(stopaddress)
                modulename=string.format('%X',modulename)
			end
			ms.firstScan(soExactValue,vtByteArray,rtTruncated,AddressOrAOBString,'',getAddress(modulename),getAddress(stopaddress),'',fsmNotAligned,'',true,false,false,false)
			ms.waitTillDone()
			f = createFoundList(ms)
			f.initialize()
			ms.destroy()
		end
		address={}
		for i=0,f.Count-1 do address[i+1]=f[i]end
		f.destroy()
        if Nth==nil or Nth==0 or Nth=='' then Nth=1 end
        if gethead then
           local addresss=GetAddressSafe(address[Nth])
           if not addresss then addresss=GetAddressSafe(address[Nth-1])end
           if addresss and addresss~=0 then
           for i=0,0x1000 do
               addresss=addresss-1
               if readBytes(addresss,1)==0xCC then break end
               if nop then local ext, opc, byt, add=splitDisassembledString(disassemble(addresss)) if string.find(opc,'nop') then addresss=addresss+getInstructionSize(addresss)-1 break end end
           end
           address[Nth]=addresss+1 end
        end
		if number==nil or number==0 or number=='' then
			if aobscanOnly then return address end
		else
            if(#address==0)then error(name..' aob no result found') end
            if(getAddress(address[Nth])==nil)then error(name..' aob result '..Nth..' doesnt exist') end
            unregisterSymbol(name)
            registerSymbol(name,getAddressSafe(address[Nth]),true)
            if aobscanOnly then return end
		end
		AddressOrAOBString=GetAddressSafe(address[Nth])
	end
    AddressOrAOBString=getAddressSafe(AddressOrAOBString)
	if(AddressOrAOBString==nil)then error(name..' still cant be found')end
	local addr={}
	local i=0
	local j=1
	while(i&lt;size) do
		local ext, opc, byt, add=splitDisassembledString(disassemble(getAddressSafe(AddressOrAOBString)+i))
		if(ext~="")then
			if(opc:find(",")~=nil)then
				opc=opc:sub(opc:find(",")+1,opc:len())
			else
				opc=opc:sub(opc:find(" ")+1,opc:len())
			end
			addr[j]=opc:gsub("%[",""):gsub("]","") j=j+1
		end
        if opc:find('],') then
            opc=opc:sub(opc:find("%[")+1,opc:find("]")-1)
            if tonumber(opc,16) then addr[j]=opc j=j+1 end
        end
		i=i+getInstructionSize(AddressOrAOBString+i)
	end
    --for i=1,#addr do print(addr[i]) end
	if number==nil or number==0 or number=='' then return addr end
	local offset
	if(type(number)==type(''))then
		offset=string.find(number,',')
		if(offset==nil)then number=getAddress(number)
		else offset=getAddress(string.sub(number,offset+1,number:len()))
			number=getAddress(string.sub(number,1,string.find(number,',')-1))
		end
	end
	if offset==nil then offset=0 end
	unregisterSymbol(name)
	registerSymbol(name,getAddressSafe(addr[number])-offset,true)
end

function checkvalue(address,size,value,typ)
  local cvalue,tempvalue,value2=readBytes(address,size,true)

  if type(value)==type('') and string.find(value,'~') then
    value2=tonumber(value:sub(string.find(value,'~')+1,value:len()))
    value=tonumber(value:sub(1,string.find(value,'~')-1))
  end

  if not cvalue then return false end
  if typ==1 then
    for i=1,#cvalue,4 do
      datatable={}
      for m=1,4 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToDword(datatable)
      --print(FNameStringAlgo(tempvalue,true))
      local str=FNameStringAlgo(tempvalue,true)

      if str and string.find(str,value) then return address+i-1 end
    end

  elseif typ==2 then
    for i=1,#cvalue,2 do
      datatable={}
      for m=1,2 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToWord(datatable)
      if tempvalue==value or (value2 and tempvalue&gt;=value and tempvalue&lt;=value2 ) then return address+i-1 end
    end
  elseif typ==4 then
    for i=1,#cvalue,4 do
      datatable={}
      for m=1,4 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToDword(datatable)
      if tempvalue==value or (value2 and tempvalue&gt;=value and tempvalue&lt;=value2 ) then return address+i-1 end
    end
  elseif typ==8 then
    for i=1,#cvalue,4 do
      datatable={}
      for m=1,8 do
        datatable[m]=cvalue[m+i-1]
      end
      tempvalue=byteTableToQword(datatable)
      if tempvalue==value or (value2 and tempvalue&gt;=value and tempvalue&lt;=value2 ) then return address+i-1 end
    end
  end
  return nil
end

function fillstruct4bytes(Struct)
  if not getElementByOffset(Struct,0) then local e=Struct.addElement() e.Offset=0 e.Vartype=vtDword end
  Struct.beginUpdate()
  local count=Struct.Count-1
  local list,k,element1,element2,size,bytesize={},1
  for i=0,count do
    element1=Struct.Element[i]
    element2=Struct.Element[i+1]
    if element2 then
      bytesize=element1.Bytesize
      if bytesize&lt;4 then bytesize=4 end
      size=element2.Offset-element1.Offset-bytesize
      if size&gt;0 then
        if size%4&gt;0 then size=4-size%4+size end
        local start=element1.Offset
        if start%4&gt;0 then start=4-start%4+start
        else start=start+4 end
        size=size/4
        for j=0,size-1 do
          if (start+j*4)&gt;=(element1.Offset+bytesize) then
            list[k]=start+j*4
            k=k+1
          end
        end
      end
    end
  end
  for i,v in ipairs(list) do local e=Struct.addElement() e.Offset=v e.Vartype=vtDword end
  Struct.endUpdate()
end

function UECreateStruct(LocalStruct,ArrayStruct,ObjectData,Struct,Instance,AddedOffset,AddedName)

  if AddedOffset then
    if LocalStruct[ObjectData.FullName] then copyStruct(LocalStruct[ObjectData.FullName],Struct,AddedOffset,AddedName)
    else
      local copy=createStructure(ObjectData.FullName)
      UECreateStruct(LocalStruct,ArrayStruct,ObjectData,copy,Instance)
      LocalStruct[ObjectData.FullName]=copy
      copyStruct(copy,Struct,AddedOffset,AddedName)
    end
    return
  end


  AddedOffset = AddedOffset and AddedOffset or 0
  AddedName = AddedName and AddedName or ''
  local size,MemberData,Propsize,e,f,Name,Offset,Typ=targetIs64Bit() and 8 or 4
  for i=0,10 do
    if ObjectData.Member then
      print(ObjectData.Type..' '..ObjectData.FullName)
      for j=1,#ObjectData.Member do
        MemberData=ObjectData.Member[j]
        if MemberData.Offset then
          Offset=AddedOffset+MemberData.Offset
          Propsize=MemberData.Propsize
          Name=AddedName..MemberData.Name
          Typ=MemberData.Type
          if string.find(ObjectData.Type,'UserDefinedStruct') then Name=Name:sub(1,string.find(Name,'_')-1)end
          if string.find(Typ,'StructProperty') and MemberData.Property and MemberData.Property[1] then
            UECreateStruct(LocalStruct,ArrayStruct,MemberData.Property[1],Struct,Instance,Offset,Name..'.')
            if not getElementByOffset(Struct,Offset) then e=Struct.addElement() e.Offset=Offset e.Name=Name e.Vartype=vtDword end
          else
            e=Struct.addElement()
            e.Offset=Offset
            e.Name=Name
            if string.find(Typ,'BoolProperty') and MemberData.Bit then e.ChildStructStart=MemberData.Bit end

            if Instance and PropName=='RowStruct' then
              local spointer=readPointer(Instance+Offset)
              local sname,sstruct=SaveObject(spointer)
              if sname then
                print(sname.Type..' '..sname.FullName)

                if not ArrayStruct then ArrayStruct={} end
                if ArrayStruct[sname.Name] then sstruct=ArrayStruct[sname.Name]
                else
                  sstruct=createStructure(sname.Name)
                  ArrayStruct[sname.Name]=sstruct
                  UECreateStruct(LocalStruct,ArrayStruct,sname,sstruct,Instance,nil,nil)
                end
                f=Struct.addElement() f.Offset=e.Offset+8-sub f.Name='Table' f.Vartype=vtPointer
                local ssstruct=createStructure('DataTable')
                f.setChildStruct(ssstruct)
                for r=0,10 do
                  f=ssstruct.addElement() f.Offset=r*0x18 f.Name=string.format('[%u] FName',r)  f.Vartype=vtQword
                  f=ssstruct.addElement() f.Offset=r*0x18+8 f.Name=string.format('[%u] Data',r) f.Vartype=vtPointer
                  f.setChildStruct(sstruct)
                end
                fillstruct4bytes(ssstruct)

                f=Struct.addElement() f.Offset=e.Offset+0x10-sub*2 f.Name='Size' f.Vartype=vtDword
              end
            end
            if not ue4type[Typ] then e.Vartype=vtDword
            else e.Vartype=ue4type[Typ] end
            if (string.find(Typ,'ArrayProperty') or string.find(Typ,'MapProperty')) and MemberData.Property then
              f=Struct.addElement() f.Offset=e.Offset+8-sub f.Name=e.Name..'_size' f.Vartype=vtDword
              f=Struct.addElement() f.Offset=e.Offset+0xC-sub f.Name=e.Name..'_sizes' f.Vartype=vtDword
              for m=e.Offset+0xC-sub+4,Propsize-1,4 do
                if not getElementByOffset(Struct,m) then f=Struct.addElement() f.Offset=m f.Name=string.format('%s+%X',e.Name,m) f.Vartype=vtDword end
              end
              local isMap= Typ=='MapProperty'
              if string.find(MemberData.Property[1].Type,'StructProperty') and MemberData.Property[1].Property and MemberData.Property[1].Property[1] then
                Name= MemberData.Property[1].Property[1].Name..'[]'
              else Name=MemberData.Property[1].Name..'[]'end
              if not ArrayStruct then ArrayStruct={} end
              if ArrayStruct[Name] then e.setChildStruct(ArrayStruct[Name])
              else
                local stru=createStructure(Name)
                ArrayStruct[Name]=stru
                e.setChildStruct(stru)
                local ppsize=0
                if isMap then
                  for k=1,#MemberData.Property do
                    ppsize=(MemberData.Property[k].Propsize&lt;4 and 4 or MemberData.Property[k].Propsize)+ppsize
                  end
                  ppsize=ppsize+0x8
                  --print(ppsize)
                end
                for k=1,#MemberData.Property do
                  local psize=isMap and ppsize or MemberData.Property[k].Propsize
                  --print(MemberData.Address)
                  local Offs=isMap and MemberData.Property[k].Offset and MemberData.Property[k].Offset or 0
                  for p=0,10 do
                    Offset=p*psize+Offs
                    Name=string.format('[%u] ',p)
                    Typ=MemberData.Property[k].Type
                    if string.find(MemberData.Property[k].Type,'StructProperty') then
                      UECreateStruct(LocalStruct,ArrayStruct,MemberData.Property[k].Property[1],stru,Instance,Offset,Name)
                    else
                      f=stru.addElement()
                      f.Offset=Offset
                      f.Name=Name..MemberData.Property[k].Name
                      if not ue4type[Typ] then f.Vartype=vtDword
                      else f.Vartype=ue4type[Typ]end
                    end
                  end
                end
                fillstruct4bytes(stru)
              end
            end
          end
        end
      end
    end
    if not ObjectData.Super then break end
    ObjectData=ObjectData.Super
  end

end


function ue4createstruct(FullNameOrAddress,StructName,isGlobal,isfullname,Structu,AddedOffset,AddedName,Instance,name)
  local ObjectData
  if not FullNameOrAddress then return
  elseif type(FullNameOrAddress)==type('')then
    FullNameOrAddress=StaticFindObjectAlgo(FullNameOrAddress)
    ObjectData=SaveObject(FullNameOrAddress)
  elseif type(FullNameOrAddress)==type({})then ObjectData=FullNameOrAddress
  elseif type(FullNameOrAddress)==type(0)then ObjectData=SaveObject(FullNameOrAddress) end
  --print(ObjectData.FullName)
  if not ObjectData then return end

  StructName= StructName and StructName or ObjectData.Name

  Struct=Structu and Structu or createStructure(StructName and StructName or ObjectData.Name)
  local LocalStruct,ArrayStruct,e={},{}
  Struct.beginUpdate()
  UECreateStruct(LocalStruct,ArrayStruct,ObjectData,Struct,Instance,nil,nil)
  Struct.endUpdate()
  if not getElementByOffset(Struct,0) then e=Struct.addElement() e.Offset=0 e.Name='VTable' e.Vartype=vtPointer end
  if not getElementByOffset(Struct,UObject.ObjectId) then e=Struct.addElement() e.Offset=UObject.ObjectId e.Name='ObjectIndex' e.Vartype=vtDword end
  if not getElementByOffset(Struct,UObject.Class) then e=Struct.addElement() e.Offset=UObject.Class e.Name='Class/Type' e.Vartype=vtPointer end
  if not getElementByOffset(Struct,UObject.FNameIndex) then e=Struct.addElement() e.Offset=UObject.FNameIndex e.Name='FNameIndex' e.Vartype=vtDword end
  if not getElementByOffset(Struct,UObject.Outer) then e=Struct.addElement() e.Offset=UObject.Outer e.Name='Outer' e.Vartype=vtPointer end
  if string.find(name,'Function') and UObject.funct then e=Struct.addElement() e.Offset=UObject.funct e.Name='Func' e.Vartype=vtPointer end
--[[
  if not Instance then fillstruct4bytes(Struct)
  else
    if not getElementByOffset(Struct,0) then Struct.autoGuess(Instance, 0, Struct.Element[0].Offset) end
    local count=Struct.Count-1
    local list,k,element1,element2,size,bytesize={},1
    for i=0,count do
      element1=Struct.Element[i]
      element2=Struct.Element[i+1]
      if element2 then
        bytesize=element1.Bytesize
        if bytesize&lt;4 then bytesize=4 end
        size=element2.Offset-element1.Offset-bytesize
        print(element1.Offset+bytesize)
        print(size)
        if size&gt;0 then
          Struct.autoGuess(Instance,element1.Offset+bytesize,size)
        end
      end
    end
  end]]
  fillstruct4bytes(Struct)
  if isGlobal then StructList[#StructList+1]=Struct end
  LoadStruct()
  return Struct

end



function getElementByOffset(struct,offset)
  for i=0,struct.Count-1 do
    if struct.Element[i].Offset==offset then return i end
  end
  return nil
end

function copyStruct(original,copy,AddedOffset,AddedName)
  if not copy then copy=createStructure(original.Name..'_copy')end
  if not AddedOffset then AddedOffset=0 end
  if not AddedName then AddedName='' end
  copy.beginUpdate()
  for i=0,original.Count-1 do
    local e=copy.addElement()
    e.Offset=original.Element[i].Offset+AddedOffset
    if original.Element[i].Name=='' then e.Name=original.Element[i].Name
    else e.Name=AddedName..original.Element[i].Name end
    e.Vartype=original.Element[i].Vartype
    e.ChildStruct=original.Element[i].ChildStruct
    e.ChildStructStart=original.Element[i].ChildStructStart
    e.Bytesize=original.Element[i].Bytesize
  end
  copy.endUpdate()
  return copy
end

function ue_structureDissectOverrideCallback(Struct, Instance)
  --print('banana2')
  local name,fullname,class
  address,name,fullname,class=ue_findRealStartOfObject(Instance)

  if class then
   -- print('banana3')
    --if UEObj and (not enumUEObjIsRunning or enumUEObjIsUpdateOnly) then ue4createstructfast(fullname,nil,nil,nil,Struct) end
    SaveAndRemoveStruct()
    ue4createstruct(class,nil,nil,nil,Struct,nil,nil,Instance,name)
    --LoadStruct()
    if Struct.Count&gt;1 then return true
    else return false end
  end

  --ue_fillstruct(readPointer(Instance+UObject.Class),structure)
  --print('banana4')

  return nil
end

function ue_structureNameLookupCallback(address)
  --print('banana1')
  local name,fullname
  address,name,fullname=ue_findRealStartOfObject(address)
  if name then return name,address end
  return nil
end

function ue_SymbolLookupCallback(symbol)
  --print('banana1')
  if UEMember[symbol:lower()] then return UEMember[symbol:lower()] end
  local str='Function '
  if string.find(symbol,str) then
    symbol=symbol:sub(string.find(symbol,str)+str:len(),symbol:len())
    local pointer=StaticFindObjectAlgo(symbol)
    if pointer then return readPointer(pointer+UObject.funct)end
  end
  return nil
end

function ue_findRealStartOfObject(address)
  local ObjectData
  ObjectData=SaveObject(address)
  if ObjectData then return ObjectData.Address,ObjectData.Class.Name,ObjectData.Class.FullName,ObjectData.Class end

  for i=1,HighestObjectID+10 do
    if ObjectTable[i] and address&gt;=ObjectTable[i].Address and address&lt;ObjectTable[i].Address+0x500 then
      ObjectData=ObjectTable[i]
      return ObjectData.Address,ObjectData.Class.Name,ObjectData.Class.FullName,ObjectData.Class
    end
  end
  return address
end


function findOpcodes(address,opcode,size)
  if not size then size=0x50 end
  address=getAddressSafe(address)
  if not address then return nil end
  local addr={}
  local i=0
  local j=1
  while(i&lt;size) do
    local ext, opc, byt, add=splitDisassembledString(disassemble(address+i))
    if string.find(opc,opcode) then
      addr[j]=address+i
      j=j+1
    end
    i=i+getInstructionSize(address+i)
  end
  return addr
end

function findOpcode(address,opcode,size)
  if not size then size=0x50 end
  address=getAddressSafe(address)
  if not address then return nil end
  local i=0
  while(i&lt;size) do
    local ext, opc, byt, add=splitDisassembledString(disassemble(address+i))
    if string.find(opc,opcode) then
      return address+i
    end
    i=i+getInstructionSize(address+i)
  end
  return nil
end

function findLastCall(address,size)
  if not size then size=0x1000 end
  local result=findOpcode(address,'ret',size)
  if not result then print(address..' cant find ret?') return nil end
  result=result-getAddress(address)
  result=findOpcodes(address,'call ',result)
  local ext, opc, byt, add=splitDisassembledString(disassemble(result[#result]))
  opc=opc:gsub('call ','')
  return opc
end

function followjmp(address,size)
  if not size then size=0x1000 end
  local result=findOpcode(address,'jmp ',size)
  if not result then print(address..' cant find jmp?') return nil end
  local ext, opc, byt, add=splitDisassembledString(disassemble(result))
  opc=opc:gsub('jmp ','')
  return opc
end

function followcall(address,size)
  if not size then size=0x1000 end
  local result=findOpcode(address,'call ',size)
  if not result then print(address..' cant find call?') return nil end
  local ext, opc, byt, add=splitDisassembledString(disassemble(result))
  opc=opc:gsub('call ','')
  return opc
end

--local ext, opc, byt, add=splitDisassembledString(disassemble(findOpcodes('/Script/Astro.PrinterComponent:UpdatePreprinting_exec','call')[1]))
--return opc:sub(string.find(opc,' ')+1,opc:len())

function startstop(modulename,stopaddress)
  if(modulename==0 or modulename==nil or modulename=='')then modulename=0 stopaddress=0x00007fffffffffff end
  if type(modulename)==type(0) then modulename=string.format('%X',modulename)
  elseif type(modulename)==type('') then modulename=[["]]..modulename..[["]]  end
  if(stopaddress==0 or stopaddress==nil or stopaddress=='')then
    stopaddress=getNameFromAddress(getAddress(modulename),true,false)
    if(stopaddress:find("+")~=nil)then stopaddress=stopaddress:sub(0,stopaddress:find("+")-1)end
	if(getModuleSize(stopaddress)==nil)then error('Module '..modulename..' not found') end
    modulename=getAddress([["]]..stopaddress..[["]])
	stopaddress=modulename+getModuleSize(stopaddress)
    modulename=string.format('%X',modulename)
  end
  if type(stopaddress)==type(0) then stopaddress=string.format('%X',stopaddress)end
  return modulename,stopaddress
end

function groupscan(value,modulename,stopaddress)
  local ms = createMemScan()
  modulename,stopaddress=startstop(modulename,stopaddress)
  ms.firstScan(soExactValue,vtGrouped,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function pointerscan(value,modulename,stopaddress,value2)
  local ms = createMemScan()
  modulename,stopaddress=startstop(modulename,stopaddress)
  print(modulename..'~'..stopaddress)
  if value2 then ms.firstScan(soValueBetween,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)
  else ms.firstScan(soExactValue,targetIs64Bit() and vtQword or vtDword,rtTruncated,value,value2,modulename,stopaddress,'',fsmNotAligned,'',false,false,false,false)end
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function stringscan(value,modulename,stopaddress,isUnicode)
  local ms = createMemScan()
  modulename,stopaddress=startstop(modulename,stopaddress)
  ms.firstScan(soExactValue,vtString,rtTruncated,value,'',modulename,stopaddress,'',fsmNotAligned,'',false,false,isUnicode,true)
  ms.waitTillDone()
  local f = createFoundList(ms)
  f.initialize()
  ms.destroy()
  local result={}
  for i=0,f.Count-1 do result[i+1]=f[i] end
  f.destroy()
  return result
end

function StructAddToListSymbol(StructName,StartOffset,StopOffset,BaseAddress,OffsetOnly)
  if not StartOffset then StartOffset=0 end
  if not StopOffset then StopOffset=0xFFFFFF end
  local structCount=getStructureCount()
  local struct
  for i=0,structCount-1 do
    local stru=getStructure(i)
    if stru.Name==StructName then struct=stru break end
  end
  if struct then
    for i=0,struct.Count-1 do
      local e=struct.Element[i]
      if e.Offset&gt;=StartOffset and e.Offset&lt;=StopOffset then
        local rec=getAddressList().createMemoryRecord()
        rec.setDescription(e.Name)
        if OffsetOnly then
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.Offset[0]=e.Offset
          else rec.setAddress(string.format('+%X',e.Offset))end
        else
          if BaseAddress then rec.setAddress(BaseAddress) rec.OffsetCount=1 rec.OffsetText[0]=StructName..'.'..e.Name
          else rec.setAddress(string.format('+%s.%s',StructName,e.Name))end
        end
        rec.Type=e.Vartype
      end
    end
  end
end

function getInsForJump(address,registername,destination,allocsize,SharedMemoryName)
  address = getAddressSafe(address)
  if not address then error('getInsForJump address nil') return end
  if not allocsize then allocsize=4096 end
  destination=getAddressSafe(destination)
  if not destination then
	if not SharedMemoryName then destination = allocateMemory(allocsize,address)
	else destination = allocateSharedMemory(SharedMemoryName,allocsize) end
  end
  local size = (address+5-destination&gt;0x7FFFFFFF) and 14 or 5
  if registername then
	unregisterSymbol(registername)
	registerSymbol(registername,destination,true)
  end
  local opcodes = {}
  local i = 0
  while(i&lt;size) do
    local ext, opc=splitDisassembledString(disassemble(address+i))
    opcodes[#opcodes+1] = opc
    i=i+getInstructionSize(address+i)
  end
  local copy = table.concat(opcodes,'\r\n')
  local readAsTable = true
  local byt = readBytes(address,i,readAsTable)
  for j=1,#byt do byt[j] = ('%02X'):format(byt[j]) end
  local bytes = table.concat(byt, ' ')
  return i,copy,bytes,size,destination
end

function enablescript(name,registername,addressname,script,disable)
    local address=getAddress(addressname)
    if disable then script=(script):format(address,registername,readBytes(registername,1))
    else
        local i,copy,bytes,size =getInsForJump(address,name)
        script=(script):format(registername, registername, name, copy, registername, i, bytes, address)..string.rep('nop\n',i-size)..'returnhere:'
    end
    local success,erro=autoAssembleCheck(script)
    if not success then print('\n'..erro..'\n')local scriptstr=createStringlist()scriptstr.Text=script for j=0,scriptstr.Count-1 do print(string.format('%u\t%s',j+1,scriptstr[j])) end
    if not disable then deAlloc(name)unregisterSymbol(name)end error(name..' autoAssemble failed')end
    autoAssemble(script)
    if disable then deAlloc(name)unregisterSymbol(name)unregisterSymbol(registername)end
end

function cycleFullCompact(sender,force)
  local state = not(compactmenuitem.Caption == 'Compact View Mode')
  if force~=nil then state = not force end
  compactmenuitem.Caption = state and 'Compact View Mode' or 'Full View Mode'
  getMainForm().Splitter1.Visible = state
  getMainForm().Panel4.Visible = state
  getMainForm().Panel5.Visible = state
end

function addCompactMenu()
  if compactmenualreadyexists then return end
  local parent = getMainForm().Menu.Items
  compactmenuitem = createMenuItem(parent)
  parent.add(compactmenuitem)
  compactmenuitem.Caption = 'Compact View Mode'
  compactmenuitem.OnClick = cycleFullCompact
  compactmenualreadyexists = 'yes'
end

addCompactMenu()
--cycleFullCompact(nil,true)

if syntaxcheck then return end

[ENABLE]
if not process or not enumModules()[1] then print('Error: No process selected...') error('process is nil') end
if string.find(process,'MassEffect') then
  isMassEffect=true
  --findAddress('GUObjectArray',1,'4C * * * * * * 49 3B * 0F 84 * * * * 48 89 * * * 48 89banana',process)
  --print('------------------')
  local result2,result=findAddress('FNamePool',0,'C0 CA 45 80 00 00 00 00 00 00 00 00 4E 6F 6E 65 00banana',process,nil,0,true)
  for i=1,#result2 do
    result=pointerscan(getAddress(result2[i]),process)
    for j=1,#result do
      stringoffset=0xC
      unregisterSymbol('FNamePool') registerSymbol('FNamePool',result[j],true)
    end
  end

  else isMassEffect=nil
end
starttime=os.clock()
if not UEMember then UEMember={}end

if not UE4ver then UE4ver=ue4versioncheck() end

ue4config()

if not getAddressSafe('GUObjectArray') and not getAddressSafe('FNamePool')  then

  if targetIs64Bit() then

    local address=findAddress('GUObjectArray',0,'44 8B * * * 48 8D 05 * * * * * * * * * 48 89 71 10banana',process,nil,0,true)[1]
    if not address then address=findAddress('GUObjectArray',0,'40 53 48 83 EC 20 48 8B D9 48 85 D2 74 * 8Bbanana',process,nil,0,true)[1]end
    if not address then address=findAddress('GUObjectArray',0,'4C 8B 05 * * * * 45 3B 88banana',process,nil,0,true)[1]end
    if not address then findAddress('GUObjectArray','1,-0x68','4C 8B 44 24 60 8B 44 24 78 * * * 48 8Dbanana',process)
    else findAddress('GUObjectArray',1,address)end

    if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
      if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
      elseif readInteger('GUObjectArray+14')==0 then UE4ver=9
      else UE4ver=20 end
    end

    if UE4ver&gt;=23 then
      address=findAddress('FNamePool',0,'4C 8D 05 * * * * EB 16 48 8D 0D * * * * E8banana',process,nil,0,true)[1]
      if not address then address=findAddress('FNamePool',0,'48 8D 0D *  *  *  *  E8 *  *  *  * 4C 8B C0 C6banana',process,nil,0,true)[1]end
      if address then findAddress('FNamePool',1,address)
      else error('FNamePool aob not found...')end
    elseif string.find(process,'StateOfDecay2')then
      findAddress('FNamePool',1,'48 8D * * * * * 8B * * 85 * 74 * 8Dbanana',process,nil,1,nil,true,true)
      findAddress('FNamePool2',3,'48 8D * * * * * 8B * * 85 * 74 * 8Dbanana',process,nil,1,nil,true,true)
      FNamePool=getAddress('FNamePool')
      FNamePool2=getAddress('FNamePool2')
    else
      address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[2]
      if not address then address=findAddress('FNamePool',0,'48 83 EC 28 48 8B 05 *  *  *  *  48 85 C0 75 *  B9 *  *  00 00 48 89 5C 24 20 E8banana',process,nil,0,true)[1] end
      if address then findAddress('FNamePool',1,address)
      else findAddress('FNamePool',1,'C3 *  DB 48 89 1D *  *  *  *  *  *  48 8B 5C 24 20banana',process,nil,2)end
    end

  else
    if UE4ver&gt;2 then
      findAddress('GUObjectArray',1,'8B 44 24 04 56 8B F1 85 C0 74 17 8B 40 08banana',process)
      findAddress('FNamePool',1,'33 F6 89 35 * * * * 8B C6 5Ebanana',process,nil,1,nil,true,true)
    else
      findAddress('FNamePool',1,'8B 07 8B 0D * * * * 8B 04 81banana',process)
      findAddress('GUObjectArray',1,'8B 15 * * * * 8B 04 82 85banana',process)
    end
  end

end

if targetIs64Bit() then
  if UE4ver&gt;7 then
    local address=findAddress('GEngine',0,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process,nil,0,true)[1]
    if not address then address=findAddress('GEngine',0,'48 8B 1D * * * * 48 85 DB 74 * 48 8Dbanana',process,nil,0,true)[1]end
    if not address then error('GEngine aob not found...')end
    findAddress('GEngine',1,address)
 --findAddress('GEngine',1,'41 B8 01 00 00 00 * * * 48 8B 0D * * * * E8 * * * * 48 85 C0banana',process)
  end
else
  if UE4ver&gt;2 then
    findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  else
    findAddress('GEngine',1,'56 8B 35 * * * * 85 F6 74banana',process)
  end
end

print('AOBScan done : '..os.clock()-starttime)

ue4parsetable()

FNameStringAlgo(1,true)
FNameStringAlgo(3,true)
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

if not UObject.super or not UObject.member or not UObject.nextmember or not UObject.Offset
or not UObject.propsize or not UObject.bitmask or not UObject.Property or not UObject.funct
or not UObject.enumoffset or  not UObject.enummul or not UObject.enumname or not UObject.enumindex
then if UE4ver&gt;7 then UE4AutoConfig() else UE3AutoConfig() end end

print('Table parsing done : '..os.clock()-starttime)

--findAddress('GWorld',1,'4D 8B 94 24 50 0C 00 00banana',process)

if UE4ver&gt;7 then
  local Classes={'/Script/Engine.GameViewportClient',
  '/Script/Engine.Engine',
  '/Script/Engine.Controller',
  '/Script/Engine.Player',
  '/Script/Engine.GameInstance',
  '/Script/Engine.GameEngine',
  '/Script/Engine.Character',
  '/Script/Engine.CharacterMovementComponent'}
  for i=1,#Classes do
    if not StaticFindObjectAlgo(Classes[i]) then print("Can't find "..Classes[i])end
  end
  registerMemberAlgo()
end
--[[
if UObject.Offset and not UE_member and UObject.funct and not UE_function then
  if ue4parsetablecheck() or #ObjectTable&lt;0x30000 then BasicEnumObject() end
  registerFuncAlgo()
  registerMemberAlgo()
end]]


print('All done : '..os.clock()-starttime..'\n')
if not ue_SymbolLookupCallbackID then
  ue_SymbolLookupCallbackID=registerSymbolLookupCallback(ue_SymbolLookupCallback,slNotSymbol)
end
--registerFuncAlgo()
GetLuaEngine().close()
[DISABLE]
--cycleFullCompact(nil,false)
unregisterSymbolLookupCallback(ue_SymbolLookupCallbackID)
ue_SymbolLookupCallbackID=nil
--[[
unregisterSymbol('GEngine')
unregisterSymbol('GUObjectArray')
unregisterSymbol('FNamePool')]]
</AssemblerScript>
              <CheatEntries>
                <CheatEntry>
                  <ID>26216</ID>
                  <Description>"Enable ue_structureDissectCallback (Experimental)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
if not ue_structureDissectOverrideCallbackID then
  ue_structureDissectOverrideCallbackID=registerStructureDissectOverride(ue_structureDissectOverrideCallback)
end

if not ue_structureNameLookupCallbackID then
  ue_structureNameLookupCallbackID=registerStructureNameLookup(ue_structureNameLookupCallback)
end
--[[
UEObjt=createThread(function()
  while(true)do
    if not UEObj and not enumUEObjIsRunning then enumUEObj(1)
    elseif not enumUEObjIsRunning then enumUEObj(1,1)end
    sleep(30000)
  end
end)
 ]]
[DISABLE]
unregisterStructureDissectOverride(ue_structureDissectOverrideCallbackID)
unregisterStructureNameLookup(ue_structureNameLookupCallbackID)
ue_structureDissectOverrideCallbackID=nil
ue_structureNameLookupCallbackID=nil

--UEObjt:terminate()
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26217</ID>
                  <Description>"Refresh ObjectList"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
BasicEnumObject()

[DISABLE]
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26218</ID>
                  <Description>"Re-register Fields/Members 's Symbols"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
registerMemberAlgo()

[DISABLE]
</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26219</ID>
                  <Description>"UE Object Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

starttime=os.clock()

totalobject=0
local Path = 'C:\\Users\\'..os.getenv('USERNAME')..'\\Desktop\\'
local filename= string.format('[%s] ObjectsDump.txt',process)
local file,err = io.open(Path..filename, 'w')
assert(file,err)
print(Path..filename)
file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
local size,sizes,pointer,datatable,pointers,propname,offset,list,str,strid,name,objid=targetIs64Bit() and 8 or 4,HighestObjectID+10
for i=1,sizes do
  if ObjectTable[i] then
    totalobject=totalobject+1
    str=string.format('%016X',ObjectTable[i].Address)
    strid=string.format('%08u',ObjectTable[i].ObjectId)
    name=ObjectTable[i].Type..' '..ObjectTable[i].FullName
    if ObjectTable[i].Offset then
      strid=string.format('%8X',ObjectTable[i].Offset)
    end
    if ObjectTable[i].Property and #ObjectTable[i].Property==1 then
      name=string.format('%s ~ %s %s',name,ObjectTable[i].Property[1].Type,ObjectTable[i].Property[1].FullName)
    end

    file:write(string.format('[%s] %s %s\n',strid,str,name))

    if ObjectTable[i].Property and #ObjectTable[i].Property==2 then
      for j=1,2 do
        name=string.format('%s %s',ObjectTable[i].Property[j].Type,ObjectTable[i].Property[j].FullName)
        if ObjectTable[i].Property[j].Property and ObjectTable[i].Property[j].Property[1] then
          name=string.format('%s ~ %s %s',name,ObjectTable[i].Property[j].Property[1].Type,ObjectTable[i].Property[j].Property[1].FullName)
        end
        file:write(string.format('[%8X] %016X %s\n',readInteger(ObjectTable[i].Property[j].Address+UObject.Offset),ObjectTable[i].Property[j].Address,name))
      end
    end

    if UObject.enumoffset and UObject.enummul and UObject.enumindex and UObject.enumname then
    if ObjectTable[i].Type=='UserDefinedEnum' or ObjectTable[i].Type=='Enum' then
      list=ObjectTable[i].Address+UObject.enumoffset
      for k=0,readInteger(list+size)-1 do
        pointers=readPointer(list)+k*UObject.enummul
        offset=readBytes(pointers+UObject.enumindex,1)
        if not offset then break end
        if offset==0 then offset=k end
        propname=FNameStringAlgo(pointers+UObject.enumname)
        strid=string.format('%8X',offset)
        str=string.format('%016X',pointers)
        file:write(string.format('[%s] %s %s\n',strid,str,propname))
      end
    end
    end

    if ObjectTable[i].Member and UE4ver&gt;=25 then
      for m=1,#ObjectTable[i].Member do
        if not string.find(ObjectTable[i].Member[m].Type,'Function')then

        totalobject=totalobject+1


        str=string.format('%016X',ObjectTable[i].Member[m].Address)
        strid=string.format('%08u',ObjectTable[i].Member[m].ObjectId)
        name=ObjectTable[i].Member[m].Type..' '..ObjectTable[i].Member[m].FullName
        if ObjectTable[i].Member[m].Offset then
          strid=string.format('%8X',ObjectTable[i].Member[m].Offset)
        end
        if ObjectTable[i].Member[m].Property and #ObjectTable[i].Member[m].Property==1 then
          name=string.format('%s ~ %s %s',name,ObjectTable[i].Member[m].Property[1].Type,ObjectTable[i].Member[m].Property[1].FullName)
        end

        file:write(string.format('[%s] %s %s\n',strid,str,name))

        if ObjectTable[i].Member[m].Property and #ObjectTable[i].Member[m].Property==2 then
        for j=1,2 do
          name=string.format('%s %s',ObjectTable[i].Member[m].Property[j].Type,ObjectTable[i].Member[m].Property[j].FullName)
          if ObjectTable[i].Member[m].Property[j].Property and ObjectTable[i].Member[m].Property[j].Property[1] then
            name=string.format('%s ~ %s %s',name,ObjectTable[i].Member[m].Property[j].Property[1].Type,ObjectTable[i].Member[m].Property[j].Property[1].FullName)
          end
          file:write(string.format('[%8X] %016X %s\n',readInteger(ObjectTable[i].Member[m].Property[j].Address+UObject.Offset),ObjectTable[i].Member[m].Property[j].Address,name))
        end
        end
    end



      end
    end

  end
end
file:close()
print(string.format('\nA Total of %u objects has been dumped in %.3f seconds',totalobject,os.clock()-starttime))

shellExecute(Path..filename)

[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26220</ID>
                  <Description>"UE Name Dumper Algo"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function uenamedump(file,start,stop)
  for i=start,stop do
    local name=FNameStringAlgo(i,true)
    if name and name:len()&lt;200 and name:len()&gt;3 and not string.find(name,'%c')  then
      --print(name)
      local strid=string.format('%08X',i)

      file:write(string.format('[%s] %s\n',strid,name))
      totalname=totalname+1
    end
  end
end


 local size
 if readPointer(FNameString) or string.find(process,'StateOfDecay2')then size=0xFFFFFFFF
 elseif UE4ver&gt;=23 then size=(#FNameDict&lt;&lt;0x10)-1
 elseif UE4ver&gt;2 then size=(#FNameDict&lt;&lt;0xE)-1
 else size=math.floor(#FNameDict[1]/4) end
 local count=0x200
 size=math.floor((size/count)+0.5)

 starttime=os.clock()
 local Path = 'C:\\Users\\'..os.getenv('USERNAME')..'\\Desktop\\'
 local filename= string.format('[%s] NamesDump.txt',process)
 local file,err = io.open(Path..filename, 'w')
 assert(file,err)
 file:write(string.format('Process: %s\nUE version: %.2f\nTimeStamp: %s\n\n',process,UE4ver,os.date()))
 totalname=0
 ue4parsetablecheck()
 local num,start,stop=count,0,0
 for i=0,size do
   start=stop
   stop=stop+num
   createThread(uenamedump(file,start,stop-1))
 end
 file:close()
 print(string.format('\nA Total of %u names had been dumped in %.3f seconds',totalname,os.clock()-starttime))
 print(Path..filename)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26221</ID>
                  <Description>"Construct Console"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
function AAscript(script)
  local success,erro=autoAssembleCheck(script)
  if not success then
    print('\n'..erro..'\n')
    local scriptstr=createStringlist()scriptstr.Text=script
    for j=0,scriptstr.Count-1 do print(string.format('%u\t%s',j+1,scriptstr[j])) end
    error('autoAssemble failed')
  end
  autoAssemble(script)
end

AAscript("aobscanmodule(StaticConstructObject,$process,4C ?? ?? ?? ?? 55 53 56 57 41 54 41 55 41 56 41 57 48 8D ?? ?? ?? ?? ?? ?? 48 81 ?? ?? ?? ?? ?? 48 8B ?? ?? ?? ?? ?? 48 33 ?? 48 89)\nregistersymbol(StaticConstructObject)")
local StaticConstructObject=getAddress('StaticConstructObject')
local Console=executeCodeEx
(
  0,nil,
  getAddress(StaticConstructObject),
  getAddress('[[GEngine]+GameEngine.ConsoleClass]'),
  getAddress('[[GEngine]+GameEngine.GameViewport]'),
  0,0,0,0,0,0,0
)
writePointer('[[GEngine]+GameEngine.GameViewport]+GameViewportClient.ViewportConsole',Console)


[DISABLE]
--"NewObject with empty name can't be used to create default subobjects"


</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26222</ID>
                  <Description>"Get GEngine "</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
--if ue4parsetablecheck() or #ObjectTable&lt;0x30000 then BasicEnumObject() end
local Object=UE4ver&gt;7 and StaticFindObjectAlgo('/Script/Engine.GameEngine') or StaticFindObjectAlgo('Engine.GameEngine')--FindObjectName('GameEngine')
if not Object then error('cant find Class GameEngine')end
Object=ObjectLists[Object]
for i=0,4 do
  if Object.Uper and Object.Uper[1] then Object=Object.Uper[1] else break end
end


for i=1,#Object.Instance do
  if not string.find(Object.Instance[i].Name,'Default') then Object=Object.Instance[i] break end
end


print(string.format('%X : %s %s',Object.Address,Object.Type,Object.FullName))


unregisterSymbol('GEngine')
registerSymbol('GEngine',pointerscan(Object.Address,process)[1],true)



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26223</ID>
                  <Description>"Create Struct"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local str,Address
str=inputQuery('CreateStructure', 'Input FullName of Class or Address of Class', '/Script/Engine.GameEngine')
if str and str~='' then
  Address=getAddressSafe(str)
  if not Address then  Address=StaticFindObjectAlgo(str)end
  if Address then Address=SaveObject(Address)end
  if not Address then error("Can't find "..str..', either invalid Object Address or invalid FullName')
  else
    SaveAndRemoveStruct()
    local Struct=ue4createstruct(Address)
    Struct.addToGlobalStructureList()
    createStructureForm(nil,nil,Struct.Name)
  end
end
 
 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26224</ID>
                  <Description>"Print Fields/Members 's Classes used"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
local AddressList,str,strtable,FullName=getAddressList(),'{',{}
for i=0,AddressList.Count-1 do
  if AddressList[i].Address~='' then
    FullName=AddressList[i].Address:gsub('+','')
    FullName=UEMemberClassFullName[FullName:lower()]
    if FullName and not strtable[FullName] then strtable[FullName]=FullName str=string.format("%s'%s',\n",str,FullName) end
  end
  for j=0,AddressList[i].OffsetCount-1 do
    if AddressList[i].OffsetText[j]~='' then
      FullName=AddressList[i].OffsetText[j]:gsub('+','')
      FullName=UEMemberClassFullName[FullName:lower()]

      if FullName and not strtable[FullName] then strtable[FullName]=FullName str=string.format("%s'%s',\n",str,FullName) end
    end
  end
end

print(str:sub(0,str:len()-2)..'}')

[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26225</ID>
                  <Description>"NoClip &amp; Fly                                            Numpad6 :Toggle, Space :Up, LeftCtrl :Down"</Description>
                  <Options moHideChildren="1" moDeactivateChildrenAsWell="1"/>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end
local str1='[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]'
[ENABLE]

--[[
Enum /Script/Engine.EMovementMode
0:MOVE_None
1:MOVE_Walking
2:MOVE_NavWalking
3:MOVE_Falling
4:MOVE_Swimming
5:MOVE_Flying
6:MOVE_Custom
7:MOVE_MAX

local list=+0x40
for i=0,readInteger(list+8)-1 do
local pointer=readPointer(list)+i*0x10
local enum=readInteger(pointer+8)
local name=FNameString(pointer)
print(enum..':'..name)
end
]]


if not RelativeLocationZoffset then
  local address=getAddress('['..str1..'+Character.CapsuleComponent]')
  local value=readInteger(address+getAddress('ActorComponent.RelativeLocation+Vector.Z'))
  local list=groupscan(string.format('4:%u',value),address,address+0x1000)
  RelativeLocationZoffset={}
  for i=1,#list do
    RelativeLocationZoffset[i]=getAddress(list[i])-address
  end
end

local address=getAddressSafe(str1..'+Actor.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) &amp; ~ getAddress('Actor.bActorEnableCollision.Bit')
writeBytes(address,bActorEnableCollision)
end

updown = createTimer()
updown.Interval = 5
updown.OnTimer = function(t)
  local address=getAddressSafe('['..str1..'+Character.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_SPACE) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])+20)
      end
    end
    if isKeyPressed(VK_LCONTROL) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i], readFloat(address+RelativeLocationZoffset[i])-20)
      end
    end
  end
  local address=getAddressSafe('['..str1..'+Character.CharacterMovement]+MovementComponent.MovementMode')
  if address then
  writeBytes(address,5)
  end
end




[DISABLE]
updown.destroy()

local address=getAddressSafe(str1..'+Actor.bActorEnableCollision')
if address then
local bActorEnableCollision=readBytes(address,1) | getAddress('Actor.bActorEnableCollision.Bit')
writeBytes(address,bActorEnableCollision)
end

local address=getAddressSafe('['..str1..'+Character.CharacterMovement]+MovementComponent.MovementMode')
if address then
writeBytes(address,1)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Toggle Activation</Action>
                      <Keys>
                        <Key>102</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                  </Hotkeys>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26226</ID>
                      <Description>"WASD"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript>{$lua}
if syntaxcheck then return end
[ENABLE]
wasd = createTimer()
wasd.Interval = 5
wasd.OnTimer = function(t)
  local address=getAddressSafe('[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CapsuleComponent]')
  if address then
    if isKeyPressed(VK_S) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)+20)
      end
    end
    if isKeyPressed(VK_W) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-8, readFloat(address+RelativeLocationZoffset[i]-8)-20)
      end
    end
    if isKeyPressed(VK_A) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)+20)
      end
    end
    if isKeyPressed(VK_D) then
      for i=1,#RelativeLocationZoffset do
        writeFloat(address+RelativeLocationZoffset[i]-4, readFloat(address+RelativeLocationZoffset[i]-4)-20)
      end
    end
  end
end

[DISABLE]
wasd.destroy()
</AssemblerScript>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>26227</ID>
                  <Description>"bCanBeDamaged false (Godmode)      Numpad4 :Deactive, Numpad5 :Active"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
if syntaxcheck then return end
local str1='[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Actor.bCanBeDamaged'
[ENABLE]
--CanBeDamaged = createTimer()
--CanBeDamaged.setInterval(1000)
--CanBeDamaged.OnTimer = function()
local address=getAddressSafe(str1)
if address then
local bCanBeDamaged=readBytes(address,1) &amp; ~ getAddress('Actor.bCanBeDamaged.Bit')
writeBytes(address,bCanBeDamaged)
end
--end
 
 
[DISABLE]
--CanBeDamaged.destroy()

local address=getAddressSafe(str1)
if address then
local bCanBeDamaged=readBytes(address,1) | getAddress('Actor.bCanBeDamaged.Bit')
writeBytes(address,bCanBeDamaged)
end
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>101</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>100</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26228</ID>
                  <Description>"Jump Multiplier                                       Numpad0 :Deactive, Numpad1 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
jumpmultiplier=1
if syntaxcheck then return end
local str1='[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]'
local str2=str1..'CharacterMovementComponent.JumpZVelocity'
local str3=str1..'CharacterMovementComponent.MaxAcceleration'
local str4=str1..'CharacterMovementComponent.AirControl'
if not jumpdefault then jumpdefault=readFloat(str2)&lt;100 and 100 or readFloat(str2) end
if not MaxAccelerationdefault then MaxAccelerationdefault=readFloat(str3)end
if not AirControldefault then AirControldefault=readFloat(str4)end
[ENABLE]
jumpmuti=createHotkey(function()jumpmultiplier=jumpmultiplier+0.5 end,VK_NUMPAD1)
jump = createTimer()
jump.setInterval(100)
jump.OnTimer = function()
local address=getAddressSafe(str2)
local address2=getAddressSafe(str3)
local address3=getAddressSafe(str4)
if address then writeFloat(address,jumpdefault*jumpmultiplier)
writeFloat(address2,MaxAccelerationdefault*jumpmultiplier)
writeFloat(address3,AirControldefault*jumpmultiplier)
end
end
[DISABLE]
jump.destroy()
jumpmuti.destroy()
local address=getAddressSafe(str2)
local address2=getAddressSafe(str3)
local address3=getAddressSafe(str4)
if address then writeFloat(address,jumpdefault)
writeFloat(address2,MaxAccelerationdefault)
writeFloat(address3,AirControldefault)
end

</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>97</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>96</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26229</ID>
                  <Description>"MovementSpeed Multiplier                   Numpad2 :Deactive, Numpad3 :Active &amp; Increase"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
speedvarmutiplier=1
if syntaxcheck then return end
local str1={'[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]+CharacterMovementComponent.MaxWalkSpeed'
,'[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]+CharacterMovementComponent.MaxWalkSpeedCrouched'
,'[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]+CharacterMovementComponent.MaxSwimSpeed'
,'[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]+CharacterMovementComponent.MaxFlySpeed'
,'[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]+CharacterMovementComponent.MaxCustomMovementSpeed'
,'[[[[[[[GEngine]+Engine.GameInstance]+GameInstance.LocalPlayers]]+Player.PlayerController]+Actor.Character]+Character.CharacterMovement]+CharacterMovementComponent.MaxAcceleration'
}

if not speedvar then
  speedvar={}
  for i=1,#str1 do
    speedvar[i]=readFloat(str1[i])
  end
end

[ENABLE]
speedvarmuti=createHotkey(function() speedvarmutiplier=speedvarmutiplier+0.5 end,VK_NUMPAD3)
speedv = createTimer()
speedv.setInterval(100)
speedv.OnTimer = function()
  for i=1,#str1 do
    address=getAddressSafe(str1[i])
    if address then writeFloat(address,speedvar[i]*speedvarmutiplier)end
  end
end
[DISABLE]
speedv.destroy()
speedvarmuti.destroy()

for i=1,#str1 do
  address=getAddressSafe(str1[i])
  if address then writeFloat(address,speedvar[i]*speedvarmutiplier)end
end
speedvar=nil
</AssemblerScript>
                  <Hotkeys>
                    <Hotkey>
                      <Action>Activate</Action>
                      <Keys>
                        <Key>99</Key>
                      </Keys>
                      <ID>0</ID>
                    </Hotkey>
                    <Hotkey>
                      <Action>Deactivate</Action>
                      <Keys>
                        <Key>98</Key>
                      </Keys>
                      <ID>1</ID>
                    </Hotkey>
                  </Hotkeys>
                </CheatEntry>
                <CheatEntry>
                  <ID>26230</ID>
                  <Description>"UWorld"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>GameViewportClient.World</Offset>
                    <Offset>Engine.GameViewport</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>26231</ID>
                  <Description>"Player"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <GroupHeader>1</GroupHeader>
                  <Address>GEngine</Address>
                  <Offsets>
                    <Offset>0</Offset>
                    <Offset>Actor.Character</Offset>
                    <Offset>Player.PlayerController</Offset>
                    <Offset>0</Offset>
                    <Offset>GameInstance.LocalPlayers</Offset>
                    <Offset>Engine.GameInstance</Offset>
                  </Offsets>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26232</ID>
                      <Description>"CharacterMovement"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <GroupHeader>1</GroupHeader>
                      <Address>+Character.CharacterMovement</Address>
                      <Offsets>
                        <Offset>0</Offset>
                      </Offsets>
                      <CheatEntries>
                        <CheatEntry>
                          <ID>26233</ID>
                          <Description>"JumpZVelocity"</Description>
                          <ShowAsSigned>0</ShowAsSigned>
                          <VariableType>Float</VariableType>
                          <Address>+CharacterMovementComponent.JumpZVelocity</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26234</ID>
                          <Description>"MaxWalkSpeed"</Description>
                          <ShowAsSigned>0</ShowAsSigned>
                          <VariableType>Float</VariableType>
                          <Address>+CharacterMovementComponent.MaxWalkSpeed</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26235</ID>
                          <Description>"MaxWalkSpeedCrouched"</Description>
                          <ShowAsSigned>0</ShowAsSigned>
                          <VariableType>Float</VariableType>
                          <Address>+CharacterMovementComponent.MaxWalkSpeedCrouched</Address>
                        </CheatEntry>
                        <CheatEntry>
                          <ID>26236</ID>
                          <Description>"MaxAcceleration"</Description>
                          <ShowAsSigned>0</ShowAsSigned>
                          <VariableType>Float</VariableType>
                          <Address>+CharacterMovementComponent.MaxAcceleration</Address>
                        </CheatEntry>
                      </CheatEntries>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>26237</ID>
              <Description>"Tools"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>26238</ID>
                  <Description>"FNamePool scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

print('------------------')
local isUnicode=false
local strlist,result,result2,result3,pointer1,pointer2,pointer3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  result=stringscan('IntProperty',getAddressSafe(strlist[i]),getAddressSafe(strlist[i]..'+50'),isUnicode)
  if #result&gt;0 then
    result=stringscan('None',getAddressSafe(strlist[i]..'-50'),getAddressSafe(strlist[i]),isUnicode)
    print(strlist[i])
    if #result&gt;0 then
      if string.sub(strlist[i],strlist[i]:len()-3,strlist[i]:len()-2)=='00' then
        result=pointerscan(getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00'))
        for j=1,#result do
          pointer1=readPointer(result[j]..(targetIs64Bit() and '+8' or '+4'))
          pointer1=readPointer(pointer1)
          pointer2=readPointer(result[j]..(targetIs64Bit() and '+10' or '+8'))
          pointer2=readPointer(pointer2)
          pointer3=readPointer(result[j]..(targetIs64Bit() and '+18' or '+C'))
          pointer3=readPointer(pointer3)

          if pointer1 and pointer2 and pointer3 then
            print(strlist[i]..'&lt;-'..result[j])
            unregisterSymbol('FNamePool')
            registerSymbol('FNamePool',result[j]..'-10',true)
            if ue4versioncheck()&lt;=2 then UE4ver=23 end

            if string.sub(result[j],result[j]:len()-1,result[j]:len())=='00' then
              result2=pointerscan(getAddressSafe(result[j]))
              for k=1,#result2 do
                print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
                result3=pointerscan(getAddressSafe(result2[k]),getAddress(process),getAddress(process)+getModuleSize(process))
                for l=1,#result3 do
                  print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l])
                  unregisterSymbol('FNamePool')
                  registerSymbol('FNamePool',result3[l],true)
                  if ue4versioncheck()&lt;=2 then UE4ver=22 end
                  goto done
                end
              end
            end
          end
        end
      end
    end
  end
end
::done::
print('done')

[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26239</ID>
                  <Description>"FNamePool scanner V2 (Generic)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

print('------------------')
local isUnicode=false
local strlist,result,result2,result3,pointer1,pointer2,pointer3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  result=stringscan('IntProperty',getAddressSafe(strlist[i]),getAddressSafe(strlist[i]..'+50'),isUnicode)
  if #result&gt;0 then
    result=stringscan('None',getAddressSafe(strlist[i]..'-50'),getAddressSafe(strlist[i]),isUnicode)
    print(strlist[i])
    if #result&gt;0 then
      if string.sub(strlist[i],strlist[i]:len()-3,strlist[i]:len()-2)=='00' then
        result=pointerscan(getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00'),nil,nil,getAddressSafe(string.sub(strlist[i],1,strlist[i]:len()-2)..'00')+0x50)
        for j=1,#result do
          pointer1=readPointer(result[j]..(targetIs64Bit() and '+8' or '+4'))
          pointer1=readPointer(pointer1)
          pointer2=readPointer(result[j]..(targetIs64Bit() and '+10' or '+8'))
          pointer2=readPointer(pointer2)
          pointer3=readPointer(result[j]..(targetIs64Bit() and '+18' or '+C'))
          pointer3=readPointer(pointer3)

          if pointer1 and pointer2 and pointer3 then
            print(strlist[i]..'&lt;-'..result[j])
            unregisterSymbol('FNamePool')
            registerSymbol('FNamePool',result[j]..'-10',true)
            if ue4versioncheck()&lt;=2 then UE4ver=23 end

            --if string.sub(result[j],result[j]:len()-1,result[j]:len())=='00' then
              result2=pointerscan(getAddressSafe(result[j]))
              for k=1,#result2 do
                print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
                if inModule(result2[k]) then UE4ver=ue4versioncheck() unregisterSymbol('FNamePool') registerSymbol('FNamePool',result2[k],true) goto done end
                result3=pointerscan(getAddressSafe(result2[k]),getAddress(process),getAddress(process)+getModuleSize(process))
                for l=1,#result3 do
                  print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k]..'&lt;-'..result3[l])
                  unregisterSymbol('FNamePool')
                  registerSymbol('FNamePool',result3[l],true)
                  if ue4versioncheck()&lt;=2 then UE4ver=22 end
                  goto done
                end
              end
            --end
          end
        end
      end
    end
  end
end
::done::
print('done')

[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26240</ID>
                  <Description>"FNamePool scanner V3 (Unicode)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

print('------------------')
local isUnicode=true
local strlist,result,result2,result3,pointer1,pointer2,pointer3=stringscan('ByteProperty',nil,nil,isUnicode)

for i=1,#strlist do
  print(strlist[i])
  result=pointerscan(getAddress(strlist[i])-0x50,nil,nil,getAddress(strlist[i]))
  for j=1,#result do
    if string.sub(result[j],result[j]:len()-3,result[j]:len()-2)=='00' then
      print(result[j])
      pointer1=readPointer(result[j]..(targetIs64Bit() and '+8' or '+4'))
      pointer1=readPointer(pointer1)
      pointer2=readPointer(result[j]..(targetIs64Bit() and '+10' or '+8'))
      pointer2=readPointer(pointer2)
      pointer3=readPointer(result[j]..(targetIs64Bit() and '+18' or '+C'))
      pointer3=readPointer(pointer3)
      if pointer1 and pointer2 and pointer3 then
         print(strlist[i]..'&lt;-'..result[j])
         result2=pointerscan(getAddressSafe(string.sub(result[j],1,result[j]:len()-2)..'00'))
         for k=1,#result2 do
           print(strlist[i]..'&lt;-'..result[j]..'&lt;-'..result2[k])
           if inModule(result2[k]) then UE4ver=ue4versioncheck() unregisterSymbol('FNamePool') registerSymbol('FNamePool',result2[k],true) goto done end

         end
      end
    end
  end
end
::done::
print('done')
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26241</ID>
                  <Description>"FNamePool scanner V4 (BatmanAk)"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]

print('------------------')
local isUnicode=false
local size= targetIs64Bit() and 8 or 4
local result2,result,result3,result4,pointer1,pointer2,pointer3,tempstringoffset,str,tempfnamepooloffset=stringscan('ByteProperty',nil,nil,isUnicode)
for i=1,#result2 do
--print(result2[i])
  result=pointerscan(getAddress(result2[i]..'-50'),nil,nil,getAddress(result2[i]))

  for j=1,#result do
    tempstringoffset=getAddress(result2[i])-readPointer(getAddress(result[j]))

    for k=size,0x50,4 do
      str=readString(readPointer(getAddress(result[j])+k)+tempstringoffset,0x30,isUnicode)
      if str and str=='IntProperty' then
        stringoffset=tempstringoffset
        print(result2[i]..'&lt;-'..result[j])

        result3=pointerscan(getAddress(result[j]..'-50')-k,nil,nil,getAddress(result[j]))
        for m=1,#result3 do


          pointer1=readPointer(result3[m]..(targetIs64Bit() and '+8' or '+4'))
          pointer1=readPointer(pointer1)
          pointer2=readPointer(result3[m]..(targetIs64Bit() and '+10' or '+8'))
          pointer2=readPointer(pointer2)
          pointer3=readPointer(result3[m]..(targetIs64Bit() and '+18' or '+C'))
          pointer3=readPointer(pointer3)

          if pointer1 and pointer2 and pointer3 then
            print(result2[i]..'&lt;-'..result[j]..'&lt;-'..result3[m])

            --print(result2[i]..'&lt;-'..result[j]..'&lt;-'..result3[m])
            stringoffset2=0xc--((getAddress(result[j])-readPointer(result3[m])+size)/2)-size
          --print(string.format('%X',((getAddress(result[j])-readPointer(result3[m])+size)/2)-size))
            stringmul=k

            result4=pointerscan(getAddress(result3[m])-0x50,process,nil,getAddress(result3[m])+0x50)
            for n=1,#result4 do
              print(result2[i]..'&lt;-'..result[j]..'&lt;-'..result3[m]..'&lt;-'..result4[n])
              unregisterSymbol('FNamePool') registerSymbol('FNamePool',result4[n],true)
            end
          end
        end
      end
    end
  end
end
::done::
print('done')



[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26242</ID>
                  <Description>"UE4 Object scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}

if syntaxcheck then return end

[ENABLE]
--unregisterSymbol('FNamePool')
--registerSymbol('FNamePool','libUE4.so+41DE8A4',true)
--UE4ver=nil
--if not UE4ver then ue4versioncheck()end
--ue4config()
--ue4parsetable()
ue4parsetableFNamePool()

FNameStringAlgo(1,true)
FNameStringAlgo(3,true)
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

Aligned=true
function ue4parsetablecheck()
end


local Object=FindStringFName('Object')
local Class=FindStringFName('Class')
local CoreUObject=FindStringFName('/Script/CoreUObject')
if not UObject then  UObject = {} end
print(Object)
print(Class)
print(CoreUObject)
local size,pointer,pointer2,pointer3=(targetIs64Bit() and 8 or 4)
local result,result2=groupscan('4:'..Object)
print(#result)
for i=1,#result do
  if checkvalue(getAddress(result[i])-0x50,0x50,1,4)then
    for j=0,0x100,size do
      pointer=readPointer(getAddress(result[i])-0x50+j)
      if not pointer then break end
      if checkvalue(pointer,0x50,Class,4) then
        pointer3=pointer
        for k=0,0x100,size do
          local pointer=readPointer(getAddress(result[i])-0x50+k)
          if not pointer then break end
          if checkvalue(pointer,0x50,CoreUObject,4)then

            --print(result[i])
            local value=targetIs64Bit() and readInteger(pointer+4) or readSmallInteger(pointer+2)
            --print(string.format('%X',readInteger(pointer)))

            if targetIs64Bit() then pointer2=checkvalue(getAddress(result[i])-0x50,0x50,value,(size/2))
            else
              for p=0,10 do
                if pointer2 then break end
                pointer2=checkvalue(getAddress(result[i])-0x50,0x50,value-5+p,(size/2))
              end
            end
            if pointer2 then
              pointer2=pointer2-(size/2)
              print(string.format('%X',pointer2))

              if checkvalue(pointer2+size,0x50,1,4)then UObject.ObjectId=checkvalue(pointer2+size,0x50,1,4)-pointer2
              else UObject.ObjectId=checkvalue(pointer2,0x50,1,4)-pointer2 end
              UObject.Class=checkvalue(pointer2+size,0x50,pointer3,size)-pointer2
              UObject.FNameIndex=checkvalue(pointer2+size,0x50,Object,4)-pointer2
              UObject.Outer=checkvalue(pointer2+size,0x50,pointer,size)-pointer2

              local str
              if UE4ver&lt;9 and targetIs64Bit() then
                str=string.format('8:0x%X 8:0x%X',pointer,pointer2)
              elseif UE4ver&lt;9 then
                str=string.format('4:0x%X 4:0x%X',pointer,pointer2)
              elseif targetIs64Bit() then
                str=string.format('8:0x%X 8:* 8:* 8:0x%X',pointer,pointer2)
              else
                str=string.format('4:0x%X 4:* 4:* 4:* 4:0x%X',pointer,pointer2)
              end
              print(str)
              result2=groupscan(str)
              for n=1,#result2 do
                local result3
                if not Aligned or getAddress(result2[n])%size==0 then
                  print(string.format('%X&lt;-%s',pointer2,result2[n]))
                  --result3=pointerscan(getAddress(result2[n]:sub(1,result2[n]:len()-2)..'00'))
                end
                if not result3 or #result3&lt;=0 then result3=pointerscan(getAddress(result2[n]))end
                for o=1,#result3 do
                  local result4
                  if not Aligned or getAddress(result3[o])%size==0 then

                    --if not inModule(result3[o]) then
                      print(string.format('%X&lt;-%s&lt;-%s',pointer2,result2[n],result3[o]))

                    --end

                    if inModule(result3[o]) and (readInteger(result3[o]..'-10+1C')&lt;0x7FFFFF or readInteger(result3[o]..'-10+24')&lt;0x7FFFFF) then
                      unregisterSymbol('GUObjectArray')
                      registerSymbol('GUObjectArray',result3[o]..'-10',true)
                      goto done
                    end

                    result4=pointerscan(getAddress(result3[o]))


                  end
                  if not result4 then result4={}end
                  for q=1,#result4 do
                    if not Aligned or getAddress(result4[q])%size==0 then
                      print(string.format('%X&lt;-%s&lt;-%s&lt;-%s',pointer2,result2[n],result3[o],result4[q]))

                      if inModule(result4[q]) then
                        unregisterSymbol('GUObjectArray')
                        registerSymbol('GUObjectArray',result4[q]..'-10',true)
                        goto done
                      end

                    end
                  end
                end
              end
            end
          end
        end
      end
    end
  end
end
::done::

if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
  if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
  else UE4ver=20 end
end

print('done\n')

ue4parsetable() 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26243</ID>
                  <Description>"UE4 Object scanner V2"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}

if syntaxcheck then return end

[ENABLE]
--unregisterSymbol('FNamePool')
--registerSymbol('FNamePool','libUE4.so+41DE8A4',true)
--UE4ver=nil
--if not UE4ver then ue4versioncheck()end
--ue4config()
--ue4parsetable()
ue4parsetableFNamePool()

FNameStringAlgo(1,true)
FNameStringAlgo(3,true)
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

Aligned=true
function ue4parsetablecheck()
end


local Object=FindStringFName('Object')
local Class=FindStringFName('Class')
local CoreUObject=FindStringFName('/Script/CoreUObject')
if not UObject then  UObject = {} end
print(Object)
print(Class)
print(CoreUObject)
local size,pointer,pointer2,pointer3=(targetIs64Bit() and 8 or 4)
local result,result2=groupscan('4:'..Object)
print(#result)
for i=1,#result do
  if checkvalue(getAddress(result[i])-0x50,0x50,1,4)then
    for j=0,0x100,size do
      pointer=readPointer(getAddress(result[i])-0x50+j)
      if not pointer then break end
      if checkvalue(pointer,0x50,Class,4) then
        pointer3=pointer
        for k=0,0x100,size do
          local pointer=readPointer(getAddress(result[i])-0x50+k)
          if not pointer then break end
          if checkvalue(pointer,0x50,CoreUObject,4)then

            --print(result[i])
            local value=targetIs64Bit() and readInteger(pointer+4) or readSmallInteger(pointer+2)
            --print(string.format('%X',readInteger(pointer)))

            if targetIs64Bit() then pointer2=checkvalue(getAddress(result[i])-0x50,0x50,value,(size/2))
            else
              for p=0,10 do
                if pointer2 then break end
                pointer2=checkvalue(getAddress(result[i])-0x50,0x50,value-5+p,(size/2))
              end
            end
            if pointer2 then
              pointer2=pointer2-(size/2)
              print(string.format('%X',pointer2))

              UObject.ObjectId=checkvalue(pointer2+size,0x50,1,4)-pointer2
              UObject.Class=checkvalue(pointer2+size,0x50,pointer3,size)-pointer2
              UObject.FNameIndex=checkvalue(pointer2+size,0x50,Object,4)-pointer2
              UObject.Outer=checkvalue(pointer2+size,0x50,pointer,size)-pointer2

              local str

              for p=4,0,-1 do
                str=string.format('%u:0x%X',size,pointer)
                for q=1,p do
                  str=str..' 4:*'
                end
                str=str..string.format(' %u:0x%X',size,pointer2)
                UObjectMul=(4*p)+size

                print(str)


                result2=groupscan(str)
                for n=1,#result2 do
                  local result3
                  if result2[n]:sub(result2[n]:len()-1,result2[n]:len())=='00' then
                    print(string.format('%X&lt;-%s',pointer2,result2[n]))
                    result3=pointerscan(getAddress(result2[n]))
                  end
                  if not result3  then result3={}end
                  for o=1,#result3 do
                    local result4
                    if not Aligned or getAddress(result3[o])%size==0 then
                      --if not inModule(result3[o]) then
                        print(string.format('%X&lt;-%s&lt;-%s',pointer2,result2[n],result3[o]))
                      --end
                      if inModule(result3[o]) and (readInteger(result3[o]..'-10+1C')&lt;0x7FFFFF or readInteger(result3[o]..'-10+24')&lt;0x7FFFFF) then
                        unregisterSymbol('GUObjectArray')
                        registerSymbol('GUObjectArray',result3[o]..'-10',true)
                        result4=pointerscan(getAddress(result3[o]..'-10'),process)
                        if result4[1] then
                          print(string.format('%X&lt;-%s&lt;-%s&lt;-%s',pointer2,result2[n],result3[o],result4[1]))
                          unregisterSymbol('GUObjectArray')
                          registerSymbol('GUObjectArray',result4[1],true)
                        end
                        goto done
                      end
                      result4=pointerscan(getAddress(result3[o]))
                    end
                    if not result4 then result4={}end
                    for q=1,#result4 do
                      if not Aligned or getAddress(result4[q])%size==0 then
                        print(string.format('%X&lt;-%s&lt;-%s&lt;-%s',pointer2,result2[n],result3[o],result4[q]))
                        if inModule(result4[q]) then
                          unregisterSymbol('GUObjectArray')
                          registerSymbol('GUObjectArray',result4[q]..'-10',true)

                          goto done
                        end
                      end
                    end
                  end
                end
              end

            end
          end
        end
      end
    end
  end
end
::done::

if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
  if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
  elseif readInteger('GUObjectArray+14')==0 then UE4ver=9
  else UE4ver=20 end
end

print('done\n')

ue4parsetable() 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26244</ID>
                  <Description>"UE4 Auto config"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end

[ENABLE]
if not UObject then UObject = {} end
local size,pointer,pointers=(targetIs64Bit() and 8 or 4)
local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
local GameEngine=StaticFindObjectAlgo('/Script/Engine.GameEngine')
local Engine=StaticFindObjectAlgo('/Script/Engine.Engine')
print(string.format('GameEngine = %X',GameEngine))
print(string.format('Engine = %X\n',Engine))
UObject.super=checkvalue(GameEngine,0x100,Engine,size)-GameEngine
local Name,Typ
for i=GameEngine,GameEngine+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Property ') then pointer=readPointer(i) UObject.member=i-GameEngine break end
end
Typ=Name:sub(1,string.find(Name,' ')-1)

UObject.propsize=checkvalue(pointer,0x100,varsize[ue4type[Typ]],4)-pointer
local classsize=readInteger(UObject.member+size+GameEngine)
UObject.Offset=checkvalue(pointer,0x100,tostring(classsize-0x100)..'~'..tostring(classsize),4)-pointer

for i=pointer,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Property ') then UObject.nextmember=i-pointer break end
end

pointer=readPointer(Engine+UObject.member)
for i=pointer+UObject.nextmember,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Class ') then UObject.Property=i-pointer break end
end

UObject.bitmask=UObject.Property+2

pointer=StaticFindObjectAlgo('/Script/CoreUObject.Object:ExecuteUbergraph')
print(string.format('ExecuteUbergraph = %X\n',pointer))

for i=pointer+UObject.Property,pointer+0x100,size do
  if inModule(readPointer(i)) then UObject.funct=i-pointer break end
end

pointer=StaticFindObjectAlgo('/Script/CoreUObject.EInterpCurveMode')
print(string.format('EInterpCurveMode = %X\n',pointer))
for j=size,0x50,size do
  pointers=readPointer(pointer+UObject.Outer+j)
      --pointers=readPointer(pointers)
  if pointers and checkvalue(pointers,0x50,'CIM_Linear',1) then
    UObject.enumoffset=UObject.Outer+j
    pointer=readPointer(pointer+UObject.enumoffset)
    print(string.format('EInterpCurveMode enums = %X\n',pointer))
    UObject.enumname=checkvalue(pointer,0x50,'CIM_Linear',1)-pointer
    UObject.enumindex=checkvalue(pointer,0x50,1,2) and checkvalue(pointer,0x50,1,2)-checkvalue(pointer,0x50,'CIM_CurveAuto',1) or 4
    for k=UObject.enumname+8,0x50,4 do
      if readInteger(pointer+k)&gt;4 and FNameStringAlgo(readInteger(pointer+k),true) then UObject.enummul=k break end
    end

    break
  end
end

print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
UObject.funct = 0x%X
UObject.enumoffset = 0x%X
UObject.enummul = 0x%X
UObject.enumname = 0x%X
UObject.enumindex = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask,UObject.funct,UObject.enumoffset,
UObject.enummul,UObject.enumname,
UObject.enumindex))
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26245</ID>
                  <Description>"UE3 Object scanner"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}

if syntaxcheck then return end

[ENABLE]
UE4ver=ue4versioncheck()
--unregisterSymbol('FNamePool')
--registerSymbol('FNamePool','libUE4.so+41DE8A4',true)
--UE4ver=nil
--if not UE4ver then ue4versioncheck()end
--ue4config()
--ue4parsetable()
ue4parsetableFNamePool()

FNameStringAlgo(1,true)
FNameStringAlgo(3,true)
if not stringoffset then print('error: stringoffset/ByteProperty not found') error() end

Aligned=true
function ue4parsetablecheck()
end


local Object=FindStringFName('Object',isMassEffect)
if not UObject then  UObject = {} end
print(Object)
local size,pointer,pointer1,pointer2,pointer3=(targetIs64Bit() and 8 or 4)
local result,result2=groupscan('4:'..Object)
print(#result)
for i=1,#result do
  pointer=getAddress(result[i])-0x50
  for j=0,0x200,4 do
    pointer1=checkvalue(readPointer(pointer+j),0x200,'Class',1)
    if pointer1 then
      for k=0,0x200,4 do
        pointer2=checkvalue(readPointer(pointer+k),0x200,'Core',1)
        if pointer2 then
          print(result[i])
          pointer1=pointer1-readPointer(pointer+j)
          pointer2=pointer2-readPointer(pointer+k)
          if pointer1==pointer2 then
            pointer=getAddress(result[i])-pointer1
            print(string.format('%X',pointer))
            for l=1,3 do
              pointer3=checkvalue(pointer+size,0x100,l,4)
              if pointer3 then print(l)
                UObject.ObjectId=pointer3-pointer
                UObject.FNameIndex=pointer1
                UObject.Class=pointer1+j-0x50
                UObject.Outer=pointer1+k-0x50

                result2=pointerscan(pointer)
                for m=1,#result2 do
                  local val=0
                  for o=1,100 do
                    val=o
                    if not readPointer(readPointer(readPointer(getAddress(result2[m])+o*size))) then break end
                  end

                  if val==100 then
                    print(string.format('%X',getAddressSafe(result2[m])-(size*l)))
                    result=pointerscan(getAddressSafe(result2[m])-(size*l),process)
                    unregisterSymbol('GUObjectArray')
                    registerSymbol('GUObjectArray',getAddressSafe(result2[m])-(size*l),true)
                    NOGUObjectsize=true

                    for n=1,#result do
                      print(result2[m]..'&lt;-'..result[n])
                      if inModule(result[n]) and getAddress(result[n])%4==0 then
                        unregisterSymbol('GUObjectArray')
                        registerSymbol('GUObjectArray',result[n],true)
                        NOGUObjectsize=nil
                        goto done
                      end
                    end
                  end
                  if m==#result2 then goto done end
                end
              end
            end
          end
        end
      end
    end
  end
end
::done::
--[[
if ue4versioncheck()&lt;=2 and targetIs64Bit() and UE4ver&lt;23 then
  if readInteger('GUObjectArray+24')==0xFFFFFFFF then UE4ver=18
  elseif readInteger('GUObjectArray+14')==0 then UE4ver=9
  else UE4ver=20 end
end
]]

ue4parsetable()
print('done\n')
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26246</ID>
                  <Description>"UE3 Auto config"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end

[ENABLE]

if not UObject then UObject = {} end
local size,pointer,pointers=(targetIs64Bit() and 8 or 4)
local varsize={[0]=1,[2]=4,[3]=8,[4]=4,[12]=size}
local GameEngine=StaticFindObjectAlgo('Engine.GameEngine')
local Engine=StaticFindObjectAlgo('Engine.Engine')
print(string.format('GameEngine = %X',GameEngine))
print(string.format('Engine = %X\n',Engine))
UObject.super=checkvalue(GameEngine,0x100,Engine,size)-GameEngine
local Name,Typ
for i=GameEngine+UObject.Outer,GameEngine+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and (string.find(Name,'Function ') or string.find(Name,'Property ')) then pointer=readPointer(i) UObject.member=i-GameEngine break end
end

for i=UObject.Outer+size,0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(pointer+i))
  if Name and  (string.find(Name,'Property ') or string.find(Name,'Function ') or string.find(Name,'Struct ')) and not string.find(Name,'Core') then
    Name=GetFullNameSafeAlgo(readPointer(readPointer(pointer+i)+i))
      if Name and  (string.find(Name,'Property ') or string.find(Name,'Function ') or string.find(Name,'Struct ')) and not string.find(Name,'Core') then
        UObject.nextmember=i break
      end
  end
end

for i=0,100 do
  pointer=readPointer(UObject.nextmember+pointer)
  Name=GetFullNameSafeAlgo(pointer)
  --print(Name)
  if Name and string.find(Name,'ObjectProperty ') then break end
end

Typ=Name:sub(1,string.find(Name,' ')-1)
--print(string.format('%X = %s',pointer,GetFullNameSafeAlgo(pointer)))
print(string.format('%s = %X',Name,pointer))
UObject.propsize=checkvalue(pointer+UObject.Outer,0x100,varsize[ue4type[Typ]],2)-pointer
local classsize=readInteger(UObject.member+size+GameEngine)
if classsize==0 then classsize=UObject.Outer+0x200 end
print((classsize-0x200)..' ~ '..(classsize+0x1000))
UObject.Offset=checkvalue(pointer+UObject.propsize,0x50,tostring(classsize-0x200)..'~'..tostring(classsize+0x1000),2)-pointer


--pointer=readPointer(Engine+UObject.member)
for i=pointer+UObject.nextmember,pointer+0x100,size do
  Name=GetFullNameSafeAlgo(readPointer(i))
  if Name and string.find(Name,'Class ') then UObject.Property=i-pointer break end
end

UObject.bitmask=UObject.Property+2

pointer=StaticFindObjectAlgo('Core.Object:FindObject')
print(string.format('FindObject = %X\n',pointer))
for i=pointer+UObject.ObjectId,pointer+0x100,4 do
  if inModule(readPointer(i)) then UObject.funct=i-pointer break end
end

pointer=StaticFindObjectAlgo('Core.Object.EInterpCurveMode')
print(string.format('EInterpCurveMode = %X\n',pointer))
for i=size,0x50,size do
  pointers=readPointer(pointer+UObject.Outer+i)
  pointers=readPointer(pointers)
  if pointers then
    for j=size,0x50,size do
      pointers=readPointer(pointer+UObject.Outer+i+j)
      --pointers=readPointer(pointers)
      if pointers and checkvalue(pointers,0x50,'CIM_Linear',1) then
        UObject.enumoffset=UObject.Outer+i+j
        pointer=readPointer(pointer+UObject.enumoffset)
        UObject.enumname=0--checkvalue(pointer,0x50,FindStringFName('CIM_Linear'),4)-pointer
        UObject.enumindex=4--checkvalue(pointer,0x50,1,4)-checkvalue(pointer,0x50,FindStringFName('CIM_CurveAuto'),4)
        UObject.enummul=8--checkvalue(pointer,0x50,2,4)-checkvalue(pointer,0x50,1,4)
        break
      end
    end
    break
  end
end


print(string.format([[
UObject.ObjectId = 0x%X
UObject.Class = 0x%X
UObject.FNameIndex = 0x%X
UObject.Outer = 0x%X
UObject.super = 0x%X
UObject.member = 0x%X
UObject.nextmember = 0x%X
UObject.propsize = 0x%X
UObject.Offset = 0x%X
UObject.Property = 0x%X
UObject.bitmask = 0x%X
UObject.funct = 0x%X
UObject.enumoffset = 0x%X
UObject.enummul = 0x%X
UObject.enumname = 0x%X
UObject.enumindex = 0x%X
]],UObject.ObjectId,UObject.Class,UObject.FNameIndex,
UObject.Outer,UObject.super,UObject.member,UObject.nextmember,
UObject.propsize,UObject.Offset,UObject.Property,
UObject.bitmask,UObject.funct,UObject.enumoffset,
UObject.enummul,UObject.enumname,
UObject.enumindex))
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26247</ID>
                  <Description>"to Single Line Address"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
function toStr(rec)
  local tec,str,list=rec,'',{}
  while(true)do
    if not tec or not tec.Address then break end
    list[#list+1]=tec
    if tec.Address:sub(1,1)~='+' then break end
    tec=tec.Parent
  end
  for i=#list,1,-1 do
    str=string.format('%s%s',str,list[i].Address)
    for j=list[i].OffsetCount-1,0,-1 do
      str=string.format('[%s]+%s',str,list[i].OffsetText[j])
    end
  end
  return str
end

if syntaxcheck then return end
[ENABLE]

memrec.Child[0].Address=toStr(memrec.Child[0]) memrec.Child[0].OffsetCount=0
 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26248</ID>
                  <Description>"to Structural Address"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
function toStr(rec)
  local tec,str,list=rec,'',{}
  while(true)do
    if not tec or not tec.Address then break end
    list[#list+1]=tec
    if tec.Address:sub(1,1)~='+' then break end
    tec=tec.Parent
  end
  for i=#list,1,-1 do
    str=string.format('%s%s',str,list[i].Address)
    for j=list[i].OffsetCount-1,0,-1 do
      str=string.format('[%s]+%s',str,list[i].OffsetText[j])
    end
  end
  return str
end

function toStructural(rec)
  local str,str2,list=toStr(rec),'',{}
  if str:find(']') then str2=str:sub(1,str:find(']')-1):gsub('%[','')
  else str2=str end
  rec.Address=str2
  while(true)do
    if not str:find(']') then break end
    str=str:sub(str:find(']')+2,str:len())
    if str:find(']') then str2=str:sub(1,str:find(']')-1):gsub('%[','')
    else str2=str end
    list[#list+1]=str2
  end
  rec.OffsetCount=#list
  for i=#list,1,-1 do
    rec.OffsetText[#list-i]=list[i]
  end
end

if syntaxcheck then return end
[ENABLE]

toStructural(memrec.Child[0])
 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26249</ID>
                  <Description>"Auto Assemble script"</Description>
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>{$lua}
function GetFullName(object)
  if not GetFullNameMem then GetFullNameMem=allocateMemory(0x100)end
  executeCodeEx(0, nil, getAddress('GetFullName'), object, GetFullNameMem)
  local str=readPointer(GetFullNameMem)
  if str then str=readString(str,readInteger(GetFullNameMem+0x8)*2,true) end
  return str
end


if syntaxcheck then return end
[ENABLE]


 
 
[DISABLE]

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26250</ID>
                  <Description>"DissectCode (Memory View -&gt; Ctrl+J or (Tools -&gt; Dissect code) )"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>26251</ID>
                      <Description>"Save DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
getDissectCode().saveToFile(path)
--getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>26252</ID>
                      <Description>"Load DissectCode"</Description>
                      <VariableType>Auto Assembler Script</VariableType>
                      <AssemblerScript Async="1">{$lua}
if syntaxcheck then return end
[ENABLE]
local path=string.format('C:\\Users\\%s\\Documents\\My Cheat Tables\\%s_dissectCode',os.getenv('USERNAME'),process:sub(1,string.find(process,'%.')-1))
--getDissectCode().saveToFile(path)
getDissectCode().loadFromFile(path)
 
[DISABLE]

</AssemblerScript>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>28512</ID>
                      <Description>"FazerBlaster (INCREMENTS FROM 6 TO 15 AS A FLOAT)"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                      <Offsets>
                        <Offset>2F0</Offset>
                        <Offset>1F8</Offset>
                        <Offset>758</Offset>
                        <Offset>318</Offset>
                        <Offset>128</Offset>
                      </Offsets>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>27847</ID>
      <Description>"1.04"</Description>
      <Options moHideChildren="1"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>27848</ID>
          <Description>"Counters"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>27849</ID>
              <Description>"Daycare Generators"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+0441C5C8</Address>
              <Offsets>
                <Offset>53C</Offset>
                <Offset>50</Offset>
                <Offset>A8</Offset>
                <Offset>128</Offset>
                <Offset>40</Offset>
                <Offset>98</Offset>
                <Offset>50</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>27850</ID>
              <Description>"Fazerblast Flags"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+03FF7308</Address>
              <Offsets>
                <Offset>290</Offset>
                <Offset>30</Offset>
                <Offset>28</Offset>
                <Offset>3A0</Offset>
                <Offset>2C8</Offset>
                <Offset>8</Offset>
                <Offset>230</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>27851</ID>
              <Description>"Monty Fight Bucket"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
              <Offsets>
                <Offset>158</Offset>
                <Offset>228</Offset>
                <Offset>490</Offset>
                <Offset>98</Offset>
                <Offset>128</Offset>
                <Offset>70</Offset>
                <Offset>98</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>28727</ID>
          <Description>"Ending Stuff"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>28728</ID>
              <Description>"Afton Ending"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28718</ID>
                  <Description>"AftonHealth"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+042DCC28</Address>
                  <Offsets>
                    <Offset>800</Offset>
                    <Offset>0</Offset>
                    <Offset>230</Offset>
                    <Offset>58</Offset>
                    <Offset>190</Offset>
                    <Offset>50</Offset>
                    <Offset>A10</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28731</ID>
                  <Description>"Cutscene"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441C5C8</Address>
                  <Offsets>
                    <Offset>D8</Offset>
                    <Offset>260</Offset>
                    <Offset>118</Offset>
                    <Offset>388</Offset>
                    <Offset>58</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>28729</ID>
              <Description>"Vanny Ending"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28724</ID>
                  <Description>"Button"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>240</Offset>
                    <Offset>2F8</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>A0</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28730</ID>
                  <Description>"Cutscene"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441C5C8</Address>
                  <Offsets>
                    <Offset>D8</Offset>
                    <Offset>2D8</Offset>
                    <Offset>118</Offset>
                    <Offset>388</Offset>
                    <Offset>58</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>28733</ID>
              <Description>"Fire Ending"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28739</ID>
                  <Description>"Button"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>268</Offset>
                    <Offset>3D8</Offset>
                    <Offset>4A0</Offset>
                    <Offset>98</Offset>
                    <Offset>128</Offset>
                    <Offset>2D0</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28737</ID>
                  <Description>"Cutscene"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441C5C8</Address>
                  <Offsets>
                    <Offset>D8</Offset>
                    <Offset>3D8</Offset>
                    <Offset>118</Offset>
                    <Offset>388</Offset>
                    <Offset>58</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>28734</ID>
              <Description>"Car Ending"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28741</ID>
                  <Description>"Button"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>268</Offset>
                    <Offset>3D8</Offset>
                    <Offset>4A8</Offset>
                    <Offset>98</Offset>
                    <Offset>128</Offset>
                    <Offset>2D0</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28736</ID>
                  <Description>"Cutscene"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441C5C8</Address>
                  <Offsets>
                    <Offset>D8</Offset>
                    <Offset>358</Offset>
                    <Offset>118</Offset>
                    <Offset>388</Offset>
                    <Offset>58</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>28735</ID>
              <Description>"Escape Ending"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28742</ID>
                  <Description>"Button"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>268</Offset>
                    <Offset>3D8</Offset>
                    <Offset>4B0</Offset>
                    <Offset>98</Offset>
                    <Offset>128</Offset>
                    <Offset>2D0</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28738</ID>
                  <Description>"Cutscene"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441C5C8</Address>
                  <Offsets>
                    <Offset>D8</Offset>
                    <Offset>398</Offset>
                    <Offset>118</Offset>
                    <Offset>388</Offset>
                    <Offset>58</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>28720</ID>
              <Description>"Princess Quest Ending"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28721</ID>
                  <Description>"Princess Quest 1"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>28701</ID>
                      <Description>"PrincessQuest1X"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+0441C570</Address>
                      <Offsets>
                        <Offset>1D4</Offset>
                        <Offset>138</Offset>
                        <Offset>260</Offset>
                        <Offset>70</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>28703</ID>
                      <Description>"PrincessQuest1Y"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+0441C570</Address>
                      <Offsets>
                        <Offset>1D0</Offset>
                        <Offset>138</Offset>
                        <Offset>260</Offset>
                        <Offset>70</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>28722</ID>
                  <Description>"Princess Quest 2"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>28702</ID>
                      <Description>"PrincessQuest2X"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+0441C570</Address>
                      <Offsets>
                        <Offset>1D4</Offset>
                        <Offset>138</Offset>
                        <Offset>E60</Offset>
                        <Offset>70</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>28704</ID>
                      <Description>"PrincessQuest2Y"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+0441C570</Address>
                      <Offsets>
                        <Offset>1D0</Offset>
                        <Offset>138</Offset>
                        <Offset>E60</Offset>
                        <Offset>70</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>28723</ID>
                  <Description>"Princess Quest 3"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>28714</ID>
                      <Description>"PrincessQuest3X"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+0441C570</Address>
                      <Offsets>
                        <Offset>1D4</Offset>
                        <Offset>138</Offset>
                        <Offset>38</Offset>
                        <Offset>200</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>28715</ID>
                      <Description>"PrincessQuest3Y"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+0441C570</Address>
                      <Offsets>
                        <Offset>1D0</Offset>
                        <Offset>138</Offset>
                        <Offset>38</Offset>
                        <Offset>200</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>28716</ID>
                      <Description>"IsAttacking"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>4 Bytes</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+0441C570</Address>
                      <Offsets>
                        <Offset>3F9</Offset>
                        <Offset>120</Offset>
                        <Offset>38</Offset>
                        <Offset>200</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>28732</ID>
                  <Description>"Cutscene"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441C5C8</Address>
                  <Offsets>
                    <Offset>D8</Offset>
                    <Offset>3D8</Offset>
                    <Offset>118</Offset>
                    <Offset>388</Offset>
                    <Offset>58</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>27860</ID>
          <Description>"Freddy Power"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>27861</ID>
              <Description>"Current Power"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe" + 0441B738</Address>
              <Offsets>
                <Offset>B8</Offset>
                <Offset>38</Offset>
                <Offset>10</Offset>
                <Offset>8</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>27862</ID>
              <Description>"Max Power"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe" + 0441B738</Address>
              <Offsets>
                <Offset>BC</Offset>
                <Offset>38</Offset>
                <Offset>10</Offset>
                <Offset>8</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>27863</ID>
          <Description>"In-game Clock"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>27864</ID>
              <Description>"Hour"</Description>
              <ShowAsSigned>1</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
              <Offsets>
                <Offset>258</Offset>
                <Offset>230</Offset>
                <Offset>328</Offset>
                <Offset>128</Offset>
                <Offset>20</Offset>
                <Offset>8</Offset>
                <Offset>98</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>27865</ID>
              <Description>"Minute"</Description>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
              <Offsets>
                <Offset>25C</Offset>
                <Offset>230</Offset>
                <Offset>328</Offset>
                <Offset>128</Offset>
                <Offset>20</Offset>
                <Offset>8</Offset>
                <Offset>98</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>27866</ID>
          <Description>"Items"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>27867</ID>
              <Description>"Item Count"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe" + 0441B738</Address>
              <Offsets>
                <Offset>138</Offset>
                <Offset>38</Offset>
                <Offset>10</Offset>
                <Offset>8</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>28690</ID>
              <Description>"Item Splash Screen"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Byte</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
              <Offsets>
                <Offset>3C8</Offset>
                <Offset>328</Offset>
                <Offset>128</Offset>
                <Offset>B8</Offset>
                <Offset>128</Offset>
                <Offset>8A0</Offset>
                <Offset>98</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>27905</ID>
              <Description>"Security Badge Count"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe" + 0x0441B738</Address>
              <Offsets>
                <Offset>0xC0</Offset>
                <Offset>0x38</Offset>
                <Offset>0x10</Offset>
                <Offset>0x8</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>28726</ID>
              <Description>"HippoMagnetUsed"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
              <Offsets>
                <Offset>338</Offset>
                <Offset>A0</Offset>
                <Offset>A8</Offset>
                <Offset>128</Offset>
                <Offset>B8</Offset>
                <Offset>98</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>27906</ID>
          <Description>"Pause Timer"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>27907</ID>
              <Description>"Elevators (elev=1, else=0 or ??)"</Description>
              <Options moHideChildren="1"/>
              <ShowAsSigned>0</ShowAsSigned>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>27908</ID>
                  <Description>"Afton Elevator"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>4</Offset>
                    <Offset>2D8</Offset>
                    <Offset>B8</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>890</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>27909</ID>
                  <Description>"Bonnie Bowl"</Description>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>4</Offset>
                    <Offset>2D8</Offset>
                    <Offset>58</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>828</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>27910</ID>
                  <Description>"Fazerblast"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>2E8</Offset>
                    <Offset>50</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>830</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>27911</ID>
                  <Description>"Foyer1"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>4</Offset>
                    <Offset>2D8</Offset>
                    <Offset>B8</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>818</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>27912</ID>
                  <Description>"Foyer2"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>4</Offset>
                    <Offset>2D8</Offset>
                    <Offset>60</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>818</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>27913</ID>
                  <Description>"Kitchen"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>2E8</Offset>
                    <Offset>B8</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>7D0</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>27914</ID>
                  <Description>"Monty Golf"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>4</Offset>
                    <Offset>2D8</Offset>
                    <Offset>68</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>808</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>27915</ID>
                  <Description>"Roxy P&amp;S"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>2E8</Offset>
                    <Offset>288</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>848</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>27916</ID>
                  <Description>"West Arcade"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+0441FCB0</Address>
                  <Offsets>
                    <Offset>4</Offset>
                    <Offset>2D8</Offset>
                    <Offset>B0</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>838</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>27917</ID>
              <Description>"Menu Pause (menu=0, else!=0)"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+0441EB78</Address>
              <Offsets>
                <Offset>B4</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>27918</ID>
              <Description>"Pause Menu (menu=3, else=2)"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe" + 441C584</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>27919</ID>
          <Description>"Positions"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>27920</ID>
              <Description>"Freddy Position"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>27921</ID>
                  <Description>"X"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Float</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe" + 0441C570</Address>
                  <Offsets>
                    <Offset>1D0</Offset>
                    <Offset>138</Offset>
                    <Offset>6B0</Offset>
                    <Offset>E8</Offset>
                    <Offset>318</Offset>
                    <Offset>128</Offset>
                    <Offset>120</Offset>
                    <Offset>10</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>27922</ID>
                  <Description>"Y"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Float</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe" + 0441C570</Address>
                  <Offsets>
                    <Offset>1D4</Offset>
                    <Offset>138</Offset>
                    <Offset>6B0</Offset>
                    <Offset>E8</Offset>
                    <Offset>318</Offset>
                    <Offset>128</Offset>
                    <Offset>120</Offset>
                    <Offset>10</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>27923</ID>
                  <Description>"Z"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Float</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe" + 0441C570</Address>
                  <Offsets>
                    <Offset>1d8</Offset>
                    <Offset>138</Offset>
                    <Offset>6B0</Offset>
                    <Offset>E8</Offset>
                    <Offset>318</Offset>
                    <Offset>128</Offset>
                    <Offset>120</Offset>
                    <Offset>10</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>27924</ID>
              <Description>"Player Position"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>27925</ID>
                  <Description>"X"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Float</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe" + 0441C570</Address>
                  <Offsets>
                    <Offset>1D0</Offset>
                    <Offset>138</Offset>
                    <Offset>318</Offset>
                    <Offset>128</Offset>
                    <Offset>120</Offset>
                    <Offset>10</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>27926</ID>
                  <Description>"Y"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Float</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe" + 0441C570</Address>
                  <Offsets>
                    <Offset>1D4</Offset>
                    <Offset>138</Offset>
                    <Offset>318</Offset>
                    <Offset>128</Offset>
                    <Offset>120</Offset>
                    <Offset>10</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>27927</ID>
                  <Description>"Z"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Float</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe" + 0441C570</Address>
                  <Offsets>
                    <Offset>1D8</Offset>
                    <Offset>138</Offset>
                    <Offset>318</Offset>
                    <Offset>128</Offset>
                    <Offset>120</Offset>
                    <Offset>10</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>28744</ID>
      <Description>"1.05"</Description>
      <Options moHideChildren="1"/>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>28745</ID>
          <Description>"Counters"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>28746</ID>
              <Description>"Daycare Generators"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+441D858</Address>
              <Offsets>
                <Offset>53C</Offset>
                <Offset>50</Offset>
                <Offset>A8</Offset>
                <Offset>128</Offset>
                <Offset>40</Offset>
                <Offset>98</Offset>
                <Offset>50</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>28747</ID>
              <Description>"Fazerblast Flags"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+03FF7308</Address>
              <Offsets>
                <Offset>290</Offset>
                <Offset>30</Offset>
                <Offset>28</Offset>
                <Offset>3A0</Offset>
                <Offset>2C8</Offset>
                <Offset>8</Offset>
                <Offset>230</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>28748</ID>
              <Description>"Monty Fight Bucket (Patched)"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+4420F40</Address>
              <Offsets>
                <Offset>158</Offset>
                <Offset>228</Offset>
                <Offset>490</Offset>
                <Offset>98</Offset>
                <Offset>128</Offset>
                <Offset>70</Offset>
                <Offset>98</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>28749</ID>
          <Description>"Ending Stuff"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>28750</ID>
              <Description>"Afton Ending"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28751</ID>
                  <Description>"AftonHealth"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+441D800</Address>
                  <Offsets>
                    <Offset>800</Offset>
                    <Offset>0</Offset>
                    <Offset>230</Offset>
                    <Offset>28</Offset>
                    <Offset>AE0</Offset>
                    <Offset>8</Offset>
                    <Offset>68</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28752</ID>
                  <Description>"Cutscene (PATCHED)"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+441D858</Address>
                  <Offsets>
                    <Offset>D8</Offset>
                    <Offset>260</Offset>
                    <Offset>118</Offset>
                    <Offset>388+28</Offset>
                    <Offset>58</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>28753</ID>
              <Description>"Vanny Ending (PATCHED)"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28754</ID>
                  <Description>"Button (PATCHED)"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+4420F40</Address>
                  <Offsets>
                    <Offset>240</Offset>
                    <Offset>2F8</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>A0</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28755</ID>
                  <Description>"Cutscene (PATCHED)"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+441D858</Address>
                  <Offsets>
                    <Offset>D8</Offset>
                    <Offset>2D8</Offset>
                    <Offset>118</Offset>
                    <Offset>388+28</Offset>
                    <Offset>58</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>28756</ID>
              <Description>"Fire Ending"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28757</ID>
                  <Description>"Button"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+4420F40</Address>
                  <Offsets>
                    <Offset>268</Offset>
                    <Offset>3D8</Offset>
                    <Offset>4A0</Offset>
                    <Offset>98</Offset>
                    <Offset>128</Offset>
                    <Offset>2D0</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28758</ID>
                  <Description>"Cutscene (PATCHED)"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+441D858</Address>
                  <Offsets>
                    <Offset>D8</Offset>
                    <Offset>3D8</Offset>
                    <Offset>118</Offset>
                    <Offset>388+28</Offset>
                    <Offset>58</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>28759</ID>
              <Description>"Car Ending"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28760</ID>
                  <Description>"Button"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+4420F40</Address>
                  <Offsets>
                    <Offset>268</Offset>
                    <Offset>3D8</Offset>
                    <Offset>4A8</Offset>
                    <Offset>98</Offset>
                    <Offset>128</Offset>
                    <Offset>2D0</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28761</ID>
                  <Description>"Cutscene (PATCHED)"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+441D858</Address>
                  <Offsets>
                    <Offset>D8</Offset>
                    <Offset>358</Offset>
                    <Offset>118</Offset>
                    <Offset>388+28</Offset>
                    <Offset>58</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>28762</ID>
              <Description>"Escape Ending"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28763</ID>
                  <Description>"Button"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+4420F40</Address>
                  <Offsets>
                    <Offset>268</Offset>
                    <Offset>3D8</Offset>
                    <Offset>4B0</Offset>
                    <Offset>98</Offset>
                    <Offset>128</Offset>
                    <Offset>2D0</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28764</ID>
                  <Description>"Cutscene (PATCHED)"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+441D858</Address>
                  <Offsets>
                    <Offset>D8</Offset>
                    <Offset>398</Offset>
                    <Offset>118</Offset>
                    <Offset>388+28</Offset>
                    <Offset>58</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>28765</ID>
              <Description>"Princess Quest Ending (PATCHED)"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28766</ID>
                  <Description>"Princess Quest 1 (PATCHED)"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>28767</ID>
                      <Description>"PrincessQuest1X"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+441D800</Address>
                      <Offsets>
                        <Offset>1D4</Offset>
                        <Offset>138</Offset>
                        <Offset>260</Offset>
                        <Offset>70</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>28768</ID>
                      <Description>"PrincessQuest1Y"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+441D800</Address>
                      <Offsets>
                        <Offset>1D0</Offset>
                        <Offset>138</Offset>
                        <Offset>260</Offset>
                        <Offset>70</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>28769</ID>
                  <Description>"Princess Quest 2 (PATCHED)"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>28770</ID>
                      <Description>"PrincessQuest2X"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+441D800</Address>
                      <Offsets>
                        <Offset>1D4</Offset>
                        <Offset>138</Offset>
                        <Offset>E60</Offset>
                        <Offset>70</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>28771</ID>
                      <Description>"PrincessQuest2Y"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+441D800</Address>
                      <Offsets>
                        <Offset>1D0</Offset>
                        <Offset>138</Offset>
                        <Offset>E60</Offset>
                        <Offset>70</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>28772</ID>
                  <Description>"Princess Quest 3 (PATCHED)"</Description>
                  <Options moHideChildren="1"/>
                  <GroupHeader>1</GroupHeader>
                  <CheatEntries>
                    <CheatEntry>
                      <ID>28773</ID>
                      <Description>"PrincessQuest3X"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+441D800</Address>
                      <Offsets>
                        <Offset>1D4</Offset>
                        <Offset>138</Offset>
                        <Offset>38</Offset>
                        <Offset>200</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>28774</ID>
                      <Description>"PrincessQuest3Y"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>Float</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+441D800</Address>
                      <Offsets>
                        <Offset>1D0</Offset>
                        <Offset>138</Offset>
                        <Offset>38</Offset>
                        <Offset>200</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                    <CheatEntry>
                      <ID>28775</ID>
                      <Description>"IsAttacking"</Description>
                      <ShowAsSigned>0</ShowAsSigned>
                      <VariableType>4 Bytes</VariableType>
                      <Address>"fnaf9-Win64-Shipping.exe"+441D800</Address>
                      <Offsets>
                        <Offset>3F9</Offset>
                        <Offset>120</Offset>
                        <Offset>38</Offset>
                        <Offset>200</Offset>
                        <Offset>200</Offset>
                        <Offset>8</Offset>
                        <Offset>8</Offset>
                      </Offsets>
                    </CheatEntry>
                  </CheatEntries>
                </CheatEntry>
                <CheatEntry>
                  <ID>28776</ID>
                  <Description>"Cutscene (PATCHED)"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe"+441D858</Address>
                  <Offsets>
                    <Offset>D8</Offset>
                    <Offset>3D8</Offset>
                    <Offset>118</Offset>
                    <Offset>388+28</Offset>
                    <Offset>58</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>28777</ID>
          <Description>"Freddy Power (PATCHED)"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>28778</ID>
              <Description>"Current Power"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe" +441C9C8</Address>
              <Offsets>
                <Offset>B8</Offset>
                <Offset>38</Offset>
                <Offset>10</Offset>
                <Offset>8</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>28779</ID>
              <Description>"Max Power"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe" + 441C9C8</Address>
              <Offsets>
                <Offset>BC</Offset>
                <Offset>38</Offset>
                <Offset>10</Offset>
                <Offset>8</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>28780</ID>
          <Description>"In-game Clock"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>28781</ID>
              <Description>"Hour"</Description>
              <ShowAsSigned>1</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+440AD80</Address>
              <Offsets>
                <Offset>258</Offset>
                <Offset>230</Offset>
                <Offset>670</Offset>
                <Offset>30</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>28821</ID>
              <Description>"Minute"</Description>
              <ShowAsSigned>1</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+440AD80</Address>
              <Offsets>
                <Offset>25C</Offset>
                <Offset>230</Offset>
                <Offset>670</Offset>
                <Offset>30</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>28788</ID>
          <Description>"Pause Timer (PATCHED)"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>28811</ID>
              <Description>"Elevators (elev=1, else=0 or ??) (PATCHED)"</Description>
              <Options moHideChildren="1"/>
              <ShowAsSigned>0</ShowAsSigned>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28812</ID>
                  <Description>"Afton Elevator"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>fnaf9-Win64-Shipping.exe+4420F40</Address>
                  <Offsets>
                    <Offset>4</Offset>
                    <Offset>2D8</Offset>
                    <Offset>B8</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>890</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28813</ID>
                  <Description>"Bonnie Bowl"</Description>
                  <VariableType>4 Bytes</VariableType>
                  <Address>fnaf9-Win64-Shipping.exe+4420F40</Address>
                  <Offsets>
                    <Offset>4</Offset>
                    <Offset>2D8</Offset>
                    <Offset>58</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>828</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28814</ID>
                  <Description>"Fazerblast"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>fnaf9-Win64-Shipping.exe+4420F40</Address>
                  <Offsets>
                    <Offset>2E8</Offset>
                    <Offset>50</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>830</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28815</ID>
                  <Description>"Foyer1"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>fnaf9-Win64-Shipping.exe+4420F40</Address>
                  <Offsets>
                    <Offset>4</Offset>
                    <Offset>2D8</Offset>
                    <Offset>B8</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>818</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28816</ID>
                  <Description>"Foyer2"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>fnaf9-Win64-Shipping.exe+4420F40</Address>
                  <Offsets>
                    <Offset>4</Offset>
                    <Offset>2D8</Offset>
                    <Offset>60</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>818</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28817</ID>
                  <Description>"Kitchen"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>fnaf9-Win64-Shipping.exe+4420F40</Address>
                  <Offsets>
                    <Offset>2E8</Offset>
                    <Offset>B8</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>7D0</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28818</ID>
                  <Description>"Monty Golf"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>fnaf9-Win64-Shipping.exe+4420F40</Address>
                  <Offsets>
                    <Offset>4</Offset>
                    <Offset>2D8</Offset>
                    <Offset>68</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>808</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28819</ID>
                  <Description>"Roxy P&amp;S"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>fnaf9-Win64-Shipping.exe+4420F40</Address>
                  <Offsets>
                    <Offset>2E8</Offset>
                    <Offset>288</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>848</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28820</ID>
                  <Description>"West Arcade"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>4 Bytes</VariableType>
                  <Address>fnaf9-Win64-Shipping.exe+4420F40</Address>
                  <Offsets>
                    <Offset>4</Offset>
                    <Offset>2D8</Offset>
                    <Offset>B0</Offset>
                    <Offset>A8</Offset>
                    <Offset>128</Offset>
                    <Offset>838</Offset>
                    <Offset>98</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>28799</ID>
              <Description>"Menu Pause (menu=0, else!=0) (PATCHED)"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+441FE08</Address>
              <Offsets>
                <Offset>B4</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>28800</ID>
              <Description>"Pause Menu (menu=3, else=2) (PATCHED)"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe" + 441D814</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>28802</ID>
          <Description>"Positions"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>28803</ID>
              <Description>"Freddy Position"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28804</ID>
                  <Description>"X"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Float</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe" + 441D800</Address>
                  <Offsets>
                    <Offset>1D0</Offset>
                    <Offset>138</Offset>
                    <Offset>6B0</Offset>
                    <Offset>E8</Offset>
                    <Offset>318</Offset>
                    <Offset>128</Offset>
                    <Offset>120</Offset>
                    <Offset>10</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28805</ID>
                  <Description>"Y"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Float</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe" + 441D800</Address>
                  <Offsets>
                    <Offset>1D4</Offset>
                    <Offset>138</Offset>
                    <Offset>6B0</Offset>
                    <Offset>E8</Offset>
                    <Offset>318</Offset>
                    <Offset>128</Offset>
                    <Offset>120</Offset>
                    <Offset>10</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28806</ID>
                  <Description>"Z"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Float</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe" + 441D800</Address>
                  <Offsets>
                    <Offset>1d8</Offset>
                    <Offset>138</Offset>
                    <Offset>6B0</Offset>
                    <Offset>E8</Offset>
                    <Offset>318</Offset>
                    <Offset>128</Offset>
                    <Offset>120</Offset>
                    <Offset>10</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>28807</ID>
              <Description>"Player Position (PATCHED)"</Description>
              <Options moHideChildren="1"/>
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>28808</ID>
                  <Description>"X"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Float</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe" + 441D800</Address>
                  <Offsets>
                    <Offset>1D0</Offset>
                    <Offset>138</Offset>
                    <Offset>318</Offset>
                    <Offset>128</Offset>
                    <Offset>120</Offset>
                    <Offset>10</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28809</ID>
                  <Description>"Y"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Float</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe" + 441D800</Address>
                  <Offsets>
                    <Offset>1D4</Offset>
                    <Offset>138</Offset>
                    <Offset>318</Offset>
                    <Offset>128</Offset>
                    <Offset>120</Offset>
                    <Offset>10</Offset>
                  </Offsets>
                </CheatEntry>
                <CheatEntry>
                  <ID>28810</ID>
                  <Description>"Z"</Description>
                  <ShowAsSigned>0</ShowAsSigned>
                  <VariableType>Float</VariableType>
                  <Address>"fnaf9-Win64-Shipping.exe" +441D800</Address>
                  <Offsets>
                    <Offset>1D8</Offset>
                    <Offset>138</Offset>
                    <Offset>318</Offset>
                    <Offset>128</Offset>
                    <Offset>120</Offset>
                    <Offset>10</Offset>
                  </Offsets>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>28783</ID>
          <Description>"Items"</Description>
          <Options moHideChildren="1"/>
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>28784</ID>
              <Description>"Item Count (PATCHED)"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe" + 441C9C8</Address>
              <Offsets>
                <Offset>138</Offset>
                <Offset>38</Offset>
                <Offset>10</Offset>
                <Offset>8</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>28785</ID>
              <Description>"Item Splash Screen (PATCHED)"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>Byte</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+4420F40</Address>
              <Offsets>
                <Offset>3C8</Offset>
                <Offset>328</Offset>
                <Offset>128</Offset>
                <Offset>B8</Offset>
                <Offset>128</Offset>
                <Offset>8A0</Offset>
                <Offset>98</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>28786</ID>
              <Description>"Security Badge Count (PATCHED)"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe" + 441C9C8</Address>
              <Offsets>
                <Offset>0xC0</Offset>
                <Offset>0x38</Offset>
                <Offset>0x10</Offset>
                <Offset>0x8</Offset>
              </Offsets>
            </CheatEntry>
            <CheatEntry>
              <ID>28787</ID>
              <Description>"HippoMagnetUsed (PATCHED)"</Description>
              <ShowAsSigned>0</ShowAsSigned>
              <VariableType>4 Bytes</VariableType>
              <Address>"fnaf9-Win64-Shipping.exe"+4420F40</Address>
              <Offsets>
                <Offset>338</Offset>
                <Offset>A0+40</Offset>
                <Offset>A8</Offset>
                <Offset>128</Offset>
                <Offset>B8</Offset>
                <Offset>98</Offset>
              </Offsets>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
  </CheatEntries>
  <CheatCodes>
    <CodeEntry>
      <Description>Change of mov [fnaf9-Win64-Shipping.exe+441FCB0],rcx</Description>
      <AddressString>fnaf9-Win64-Shipping.exe+2205247</AddressString>
      <Before>
        <Byte>88</Byte>
        <Byte>78</Byte>
        <Byte>02</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>48</Byte>
        <Byte>89</Byte>
        <Byte>0D</Byte>
        <Byte>62</Byte>
        <Byte>AA</Byte>
        <Byte>21</Byte>
        <Byte>02</Byte>
      </Actual>
      <After>
        <Byte>65</Byte>
        <Byte>48</Byte>
        <Byte>8B</Byte>
        <Byte>04</Byte>
        <Byte>25</Byte>
      </After>
    </CodeEntry>
    <CodeEntry>
      <Description>Code :mov rcx,[r13+10]</Description>
      <AddressString>fnaf9-Win64-Shipping.exe+25CDE2D</AddressString>
      <Before>
        <Byte>E8</Byte>
        <Byte>53</Byte>
        <Byte>DC</Byte>
        <Byte>FE</Byte>
        <Byte>FD</Byte>
      </Before>
      <Actual>
        <Byte>49</Byte>
        <Byte>8B</Byte>
        <Byte>4D</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>49</Byte>
        <Byte>8B</Byte>
        <Byte>87</Byte>
        <Byte>38</Byte>
        <Byte>01</Byte>
      </After>
    </CodeEntry>
    <CodeEntry>
      <Description>Change of cmp rbp,[rsi+000000D0]</Description>
      <AddressString>fnaf9-Win64-Shipping.exe+22FD10B</AddressString>
      <Before>
        <Byte>15</Byte>
        <Byte>A5</Byte>
        <Byte>97</Byte>
        <Byte>D9</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>48</Byte>
        <Byte>3B</Byte>
        <Byte>AE</Byte>
        <Byte>D0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>CB</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
    <CodeEntry>
      <Description>Change of mov [fnaf9-Win64-Shipping.exe+441FCB0],rcx</Description>
      <AddressString>fnaf9-Win64-Shipping.exe+2205247</AddressString>
      <Before>
        <Byte>88</Byte>
        <Byte>78</Byte>
        <Byte>02</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>48</Byte>
        <Byte>89</Byte>
        <Byte>0D</Byte>
        <Byte>62</Byte>
        <Byte>AA</Byte>
        <Byte>21</Byte>
        <Byte>02</Byte>
      </Actual>
      <After>
        <Byte>65</Byte>
        <Byte>48</Byte>
        <Byte>8B</Byte>
        <Byte>04</Byte>
        <Byte>25</Byte>
      </After>
    </CodeEntry>
    <CodeEntry>
      <Description>Code :mov rcx,[r13+10]</Description>
      <AddressString>fnaf9-Win64-Shipping.exe+25CDE2D</AddressString>
      <Before>
        <Byte>E8</Byte>
        <Byte>53</Byte>
        <Byte>DC</Byte>
        <Byte>FE</Byte>
        <Byte>FD</Byte>
      </Before>
      <Actual>
        <Byte>49</Byte>
        <Byte>8B</Byte>
        <Byte>4D</Byte>
        <Byte>10</Byte>
      </Actual>
      <After>
        <Byte>49</Byte>
        <Byte>8B</Byte>
        <Byte>87</Byte>
        <Byte>38</Byte>
        <Byte>01</Byte>
      </After>
    </CodeEntry>
    <CodeEntry>
      <Description>Change of cmp rbp,[rsi+000000D0]</Description>
      <AddressString>fnaf9-Win64-Shipping.exe+22FD10B</AddressString>
      <Before>
        <Byte>15</Byte>
        <Byte>A5</Byte>
        <Byte>97</Byte>
        <Byte>D9</Byte>
        <Byte>00</Byte>
      </Before>
      <Actual>
        <Byte>48</Byte>
        <Byte>3B</Byte>
        <Byte>AE</Byte>
        <Byte>D0</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </Actual>
      <After>
        <Byte>0F</Byte>
        <Byte>84</Byte>
        <Byte>CB</Byte>
        <Byte>00</Byte>
        <Byte>00</Byte>
      </After>
    </CodeEntry>
  </CheatCodes>
  <UserdefinedSymbols>
    <SymbolEntry>
      <Name>Temp</Name>
      <Address>2D7B7C70000</Address>
    </SymbolEntry>
  </UserdefinedSymbols>
  <Structures StructVersion="2">
    <Structure Name="FazPassUpgradeMachine_C" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
      <Elements>
        <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="VTable" DisplayMethod="unsigned integer"/>
        <Element Offset="12" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000000C" Description="ObjectIndex" DisplayMethod="unsigned integer"/>
        <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="Class/Type" DisplayMethod="unsigned integer"/>
        <Element Offset="24" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000018" Description="FNameIndex" DisplayMethod="unsigned integer"/>
        <Element Offset="28" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000001C" DisplayMethod="unsigned integer"/>
        <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="Outer" DisplayMethod="unsigned integer"/>
        <Element Offset="40" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000028" Description="PrimaryActorTick" DisplayMethod="unsigned integer"/>
        <Element Offset="44" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000002C" DisplayMethod="unsigned integer"/>
        <Element Offset="48" Vartype="Byte" Bytesize="1" OffsetHex="00000030" Description="PrimaryActorTick.TickGroup" DisplayMethod="unsigned integer"/>
        <Element Offset="49" Vartype="Byte" Bytesize="1" OffsetHex="00000031" Description="PrimaryActorTick.EndTickGroup" DisplayMethod="unsigned integer"/>
        <Element Offset="50" Vartype="Byte" Bytesize="1" OffsetHex="00000032" Description="PrimaryActorTick.bAllowTickOnDedicatedServer" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="50" Vartype="Byte" Bytesize="1" OffsetHex="00000032" Description="PrimaryActorTick.bCanEverTick" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="50" Vartype="Byte" Bytesize="1" OffsetHex="00000032" Description="PrimaryActorTick.bTickEvenWhenPaused" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="50" Vartype="Byte" Bytesize="1" OffsetHex="00000032" Description="PrimaryActorTick.bStartWithTickEnabled" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="52" Vartype="Float" Bytesize="4" OffsetHex="00000034" Description="PrimaryActorTick.TickInterval" DisplayMethod="unsigned integer"/>
        <Element Offset="56" Vartype="4 Bytes" Bytesize="4" RLECount="8" OffsetHex="00000038" DisplayMethod="unsigned integer"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bReplicateMovement" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bExchangedRoles" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bHidden" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bAlwaysRelevant" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bTearOff" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bNetTemporary" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bNetStartup" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bOnlyRelevantToOwner" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bAllowTickBeforeBeginPlay" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bReplayRewindable" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bCanBeDamaged" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bAutoDestroyWhenFinished" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bRelevantForLevelBounds" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bNetLoadOnClient" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bNetUseOwnerRelevancy" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bRelevantForNetworkReplays" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bIgnoresOriginShifting" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bEnableAutoLODGeneration" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bFindCameraComponentWhenViewTarget" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bCollideWhenPlacing" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bGenerateOverlapEventsDuringLevelStreaming" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bBlockInput" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bIsEditorOnlyActor" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bActorSeamlessTraveled" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="91" Vartype="Byte" Bytesize="1" OffsetHex="0000005B" Description="bReplicates" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="91" Vartype="Byte" Bytesize="1" OffsetHex="0000005B" Description="bAllowReceiveTickEventOnDedicatedServer" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="91" Vartype="Byte" Bytesize="1" OffsetHex="0000005B" Description="bCanBeInCluster" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="92" Vartype="Byte" Bytesize="1" OffsetHex="0000005C" Description="bActorIsBeingDestroyed" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="92" Vartype="Byte" Bytesize="1" OffsetHex="0000005C" Description="bActorEnableCollision" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="93" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000005D" Description="UpdateOverlapsMethodDuringLevelStreaming" DisplayMethod="unsigned integer"/>
        <Element Offset="94" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000005E" Description="DefaultUpdateOverlapsMethodDuringLevelStreaming" DisplayMethod="unsigned integer"/>
        <Element Offset="95" Vartype="Byte" Bytesize="1" OffsetHex="0000005F" Description="RemoteRole" DisplayMethod="unsigned integer"/>
        <Element Offset="96" Vartype="Float" Bytesize="4" OffsetHex="00000060" Description="ReplicatedMovement.LinearVelocity.X" DisplayMethod="unsigned integer"/>
        <Element Offset="100" Vartype="Float" Bytesize="4" OffsetHex="00000064" Description="ReplicatedMovement.LinearVelocity.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="104" Vartype="Float" Bytesize="4" OffsetHex="00000068" Description="ReplicatedMovement.LinearVelocity.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="108" Vartype="Float" Bytesize="4" OffsetHex="0000006C" Description="ReplicatedMovement.AngularVelocity.X" DisplayMethod="unsigned integer"/>
        <Element Offset="112" Vartype="Float" Bytesize="4" OffsetHex="00000070" Description="ReplicatedMovement.AngularVelocity.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="116" Vartype="Float" Bytesize="4" OffsetHex="00000074" Description="ReplicatedMovement.AngularVelocity.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="120" Vartype="Float" Bytesize="4" OffsetHex="00000078" Description="ReplicatedMovement.Location.X" DisplayMethod="unsigned integer"/>
        <Element Offset="124" Vartype="Float" Bytesize="4" OffsetHex="0000007C" Description="ReplicatedMovement.Location.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="128" Vartype="Float" Bytesize="4" OffsetHex="00000080" Description="ReplicatedMovement.Location.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="132" Vartype="Float" Bytesize="4" OffsetHex="00000084" Description="ReplicatedMovement.Rotation.Pitch" DisplayMethod="unsigned integer"/>
        <Element Offset="136" Vartype="Float" Bytesize="4" OffsetHex="00000088" Description="ReplicatedMovement.Rotation.Yaw" DisplayMethod="unsigned integer"/>
        <Element Offset="140" Vartype="Float" Bytesize="4" OffsetHex="0000008C" Description="ReplicatedMovement.Rotation.Roll" DisplayMethod="unsigned integer"/>
        <Element Offset="144" Vartype="Byte" Bytesize="1" OffsetHex="00000090" Description="ReplicatedMovement.bRepPhysics" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="144" Vartype="Byte" Bytesize="1" OffsetHex="00000090" Description="ReplicatedMovement.bSimulatedPhysicSleep" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="145" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000091" Description="ReplicatedMovement.LocationQuantizationLevel" DisplayMethod="unsigned integer"/>
        <Element Offset="146" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000092" Description="ReplicatedMovement.VelocityQuantizationLevel" DisplayMethod="unsigned integer"/>
        <Element Offset="147" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000093" Description="ReplicatedMovement.RotationQuantizationLevel" DisplayMethod="unsigned integer"/>
        <Element Offset="148" Vartype="Float" Bytesize="4" OffsetHex="00000094" Description="InitialLifeSpan" DisplayMethod="unsigned integer"/>
        <Element Offset="152" Vartype="Float" Bytesize="4" OffsetHex="00000098" Description="CustomTimeDilation" DisplayMethod="unsigned integer"/>
        <Element Offset="156" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="0000009C" DisplayMethod="unsigned integer"/>
        <Element Offset="168" Vartype="Pointer" Bytesize="8" OffsetHex="000000A8" Description="AttachmentReplication.AttachParent" DisplayMethod="unsigned integer"/>
        <Element Offset="176" Vartype="Float" Bytesize="4" OffsetHex="000000B0" Description="AttachmentReplication.LocationOffset.X" DisplayMethod="unsigned integer"/>
        <Element Offset="180" Vartype="Float" Bytesize="4" OffsetHex="000000B4" Description="AttachmentReplication.LocationOffset.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="184" Vartype="Float" Bytesize="4" OffsetHex="000000B8" Description="AttachmentReplication.LocationOffset.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="188" Vartype="Float" Bytesize="4" OffsetHex="000000BC" Description="AttachmentReplication.RelativeScale3D.X" DisplayMethod="unsigned integer"/>
        <Element Offset="192" Vartype="Float" Bytesize="4" OffsetHex="000000C0" Description="AttachmentReplication.RelativeScale3D.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="196" Vartype="Float" Bytesize="4" OffsetHex="000000C4" Description="AttachmentReplication.RelativeScale3D.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="200" Vartype="Float" Bytesize="4" OffsetHex="000000C8" Description="AttachmentReplication.RotationOffset.Pitch" DisplayMethod="unsigned integer"/>
        <Element Offset="204" Vartype="Float" Bytesize="4" OffsetHex="000000CC" Description="AttachmentReplication.RotationOffset.Yaw" DisplayMethod="unsigned integer"/>
        <Element Offset="208" Vartype="Float" Bytesize="4" OffsetHex="000000D0" Description="AttachmentReplication.RotationOffset.Roll" DisplayMethod="unsigned integer"/>
        <Element Offset="212" Vartype="8 Bytes" Bytesize="8" OffsetHex="000000D4" Description="AttachmentReplication.AttachSocket" DisplayMethod="unsigned integer"/>
        <Element Offset="224" Vartype="Pointer" Bytesize="8" OffsetHex="000000E0" Description="AttachmentReplication.AttachComponent" DisplayMethod="unsigned integer"/>
        <Element Offset="232" Vartype="Pointer" Bytesize="8" OffsetHex="000000E8" Description="Owner" DisplayMethod="unsigned integer"/>
        <Element Offset="240" Vartype="8 Bytes" Bytesize="8" OffsetHex="000000F0" Description="NetDriverName" DisplayMethod="unsigned integer"/>
        <Element Offset="248" Vartype="Byte" Bytesize="1" OffsetHex="000000F8" Description="Role" DisplayMethod="unsigned integer"/>
        <Element Offset="249" Vartype="Byte" Bytesize="1" OffsetHex="000000F9" Description="NetDormancy" DisplayMethod="unsigned integer"/>
        <Element Offset="250" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000FA" Description="SpawnCollisionHandlingMethod" DisplayMethod="unsigned integer"/>
        <Element Offset="251" Vartype="Byte" Bytesize="1" OffsetHex="000000FB" Description="AutoReceiveInput" DisplayMethod="unsigned integer"/>
        <Element Offset="252" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000FC" Description="InputPriority" DisplayMethod="unsigned integer"/>
        <Element Offset="256" Vartype="Pointer" Bytesize="8" OffsetHex="00000100" Description="InputComponent" DisplayMethod="unsigned integer"/>
        <Element Offset="264" Vartype="Float" Bytesize="4" OffsetHex="00000108" Description="NetCullDistanceSquared" DisplayMethod="unsigned integer"/>
        <Element Offset="268" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000010C" Description="NetTag" DisplayMethod="unsigned integer"/>
        <Element Offset="272" Vartype="Float" Bytesize="4" OffsetHex="00000110" Description="NetUpdateFrequency" DisplayMethod="unsigned integer"/>
        <Element Offset="276" Vartype="Float" Bytesize="4" OffsetHex="00000114" Description="MinNetUpdateFrequency" DisplayMethod="unsigned integer"/>
        <Element Offset="280" Vartype="Float" Bytesize="4" OffsetHex="00000118" Description="NetPriority" DisplayMethod="unsigned integer"/>
        <Element Offset="284" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000011C" DisplayMethod="unsigned integer"/>
        <Element Offset="288" Vartype="Pointer" Bytesize="8" OffsetHex="00000120" Description="Instigator" DisplayMethod="unsigned integer"/>
        <Element Offset="296" Vartype="Pointer" Bytesize="8" OffsetHex="00000128" Description="Children" DisplayMethod="unsigned integer">
          <Structure Name="Children[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] Children" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="304" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000130" Description="Children_size" DisplayMethod="unsigned integer"/>
        <Element Offset="308" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000134" Description="Children_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="312" Vartype="Pointer" Bytesize="8" OffsetHex="00000138" Description="RootComponent" DisplayMethod="unsigned integer"/>
        <Element Offset="320" Vartype="Pointer" Bytesize="8" OffsetHex="00000140" Description="ControllingMatineeActors" DisplayMethod="unsigned integer">
          <Structure Name="ControllingMatineeActors[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="328" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000148" Description="ControllingMatineeActors_size" DisplayMethod="unsigned integer"/>
        <Element Offset="332" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000014C" Description="ControllingMatineeActors_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="336" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000150" DisplayMethod="unsigned integer"/>
        <Element Offset="344" Vartype="Pointer" Bytesize="8" OffsetHex="00000158" Description="Layers" DisplayMethod="unsigned integer">
          <Structure Name="Layers[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000000" Description="[0] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000008" Description="[1] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000010" Description="[2] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000018" Description="[3] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000020" Description="[4] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000028" Description="[5] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000030" Description="[6] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000038" Description="[7] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000040" Description="[8] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000048" Description="[9] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000050" Description="[10] Layers" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="352" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000160" Description="Layers_size" DisplayMethod="unsigned integer"/>
        <Element Offset="356" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000164" Description="Layers_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="360" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000168" Description="ParentComponent" DisplayMethod="unsigned integer"/>
        <Element Offset="364" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="0000016C" DisplayMethod="unsigned integer"/>
        <Element Offset="376" Vartype="Pointer" Bytesize="8" OffsetHex="00000178" Description="Tags" DisplayMethod="unsigned integer">
          <Structure Name="Tags[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000000" Description="[0] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000008" Description="[1] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000010" Description="[2] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000018" Description="[3] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000020" Description="[4] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000028" Description="[5] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000030" Description="[6] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000038" Description="[7] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000040" Description="[8] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000048" Description="[9] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000050" Description="[10] Tags" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="384" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000180" Description="Tags_size" DisplayMethod="unsigned integer"/>
        <Element Offset="388" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000184" Description="Tags_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="392" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000188" Description="OnTakeAnyDamage" DisplayMethod="unsigned integer"/>
        <Element Offset="393" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000189" Description="OnTakePointDamage" DisplayMethod="unsigned integer"/>
        <Element Offset="394" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000018A" Description="OnTakeRadialDamage" DisplayMethod="unsigned integer"/>
        <Element Offset="395" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000018B" Description="OnActorBeginOverlap" DisplayMethod="unsigned integer"/>
        <Element Offset="396" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000018C" Description="OnActorEndOverlap" DisplayMethod="unsigned integer"/>
        <Element Offset="397" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000018D" Description="OnBeginCursorOver" DisplayMethod="unsigned integer"/>
        <Element Offset="398" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000018E" Description="OnEndCursorOver" DisplayMethod="unsigned integer"/>
        <Element Offset="399" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000018F" Description="OnClicked" DisplayMethod="unsigned integer"/>
        <Element Offset="400" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000190" Description="OnReleased" DisplayMethod="unsigned integer"/>
        <Element Offset="401" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000191" Description="OnInputTouchBegin" DisplayMethod="unsigned integer"/>
        <Element Offset="402" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000192" Description="OnInputTouchEnd" DisplayMethod="unsigned integer"/>
        <Element Offset="403" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000193" Description="OnInputTouchEnter" DisplayMethod="unsigned integer"/>
        <Element Offset="404" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000194" Description="OnInputTouchLeave" DisplayMethod="unsigned integer"/>
        <Element Offset="405" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000195" Description="OnActorHit" DisplayMethod="unsigned integer"/>
        <Element Offset="406" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000196" Description="OnDestroyed" DisplayMethod="unsigned integer"/>
        <Element Offset="407" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000197" Description="OnEndPlay" DisplayMethod="unsigned integer"/>
        <Element Offset="412" Vartype="4 Bytes" Bytesize="4" RLECount="23" OffsetHex="0000019C" DisplayMethod="unsigned integer"/>
        <Element Offset="504" Vartype="Pointer" Bytesize="8" OffsetHex="000001F8" Description="InstanceComponents" DisplayMethod="unsigned integer">
          <Structure Name="InstanceComponents[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] InstanceComponents" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="512" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000200" Description="InstanceComponents_size" DisplayMethod="unsigned integer"/>
        <Element Offset="516" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000204" Description="InstanceComponents_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="520" Vartype="Pointer" Bytesize="8" OffsetHex="00000208" Description="BlueprintCreatedComponents" DisplayMethod="unsigned integer">
          <Structure Name="BlueprintCreatedComponents[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="528" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000210" Description="BlueprintCreatedComponents_size" DisplayMethod="unsigned integer"/>
        <Element Offset="532" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000214" Description="BlueprintCreatedComponents_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="536" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="00000218" DisplayMethod="unsigned integer"/>
        <Element Offset="552" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000228" Description="UberGraphFrame" DisplayMethod="unsigned integer"/>
        <Element Offset="556" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000022C" DisplayMethod="unsigned integer"/>
        <Element Offset="560" Vartype="Pointer" Bytesize="8" OffsetHex="00000230" Description="Play_sfx_upgradeMachine_screen_glitch" DisplayMethod="unsigned integer"/>
        <Element Offset="568" Vartype="Pointer" Bytesize="8" OffsetHex="00000238" Description="MOD_HeadCutout_MrHippo" DisplayMethod="unsigned integer"/>
        <Element Offset="576" Vartype="Pointer" Bytesize="8" OffsetHex="00000240" Description="UpdateMission2" DisplayMethod="unsigned integer"/>
        <Element Offset="584" Vartype="Pointer" Bytesize="8" OffsetHex="00000248" Description="UpdateMission" DisplayMethod="unsigned integer"/>
        <Element Offset="592" Vartype="Pointer" Bytesize="8" OffsetHex="00000250" Description="HasCompPass" DisplayMethod="unsigned integer"/>
        <Element Offset="600" Vartype="Pointer" Bytesize="8" OffsetHex="00000258" Description="MOD_PassCard" DisplayMethod="unsigned integer"/>
        <Element Offset="608" Vartype="Pointer" Bytesize="8" OffsetHex="00000260" Description="TempDisplay" DisplayMethod="unsigned integer"/>
        <Element Offset="616" Vartype="Pointer" Bytesize="8" OffsetHex="00000268" Description="HasUpgradedFazPass" DisplayMethod="unsigned integer"/>
        <Element Offset="624" Vartype="Pointer" Bytesize="8" OffsetHex="00000270" Description="HasMagnet" DisplayMethod="unsigned integer"/>
        <Element Offset="632" Vartype="Pointer" Bytesize="8" OffsetHex="00000278" Description="PlayerInteract" DisplayMethod="unsigned integer"/>
        <Element Offset="640" Vartype="Pointer" Bytesize="8" OffsetHex="00000280" Description="StaticMesh" DisplayMethod="unsigned integer"/>
        <Element Offset="648" Vartype="Pointer" Bytesize="8" OffsetHex="00000288" Description="DefaultSceneRoot" DisplayMethod="unsigned integer"/>
        <Element Offset="656" Vartype="Byte" Bytesize="1" OffsetHex="00000290" Description="interacted" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="657" Vartype="Byte" Bytesize="1" OffsetHex="00000291" Description="Playing" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="664" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000298" Description="LineSkipper" DisplayMethod="unsigned integer"/>
        <Element Offset="668" Vartype="4 Bytes" Bytesize="4" RLECount="9" OffsetHex="0000029C" DisplayMethod="unsigned integer"/>
        <Element Offset="704" Vartype="Byte" Bytesize="1" OffsetHex="000002C0" Description="ComplimentaryPassDone?" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="708" Vartype="4 Bytes" Bytesize="4" OffsetHex="000002C4" DisplayMethod="unsigned integer"/>
        <Element Offset="712" Vartype="Pointer" Bytesize="8" OffsetHex="000002C8" Description="UseCompPassInstruction" DisplayMethod="unsigned integer"/>
        <Element Offset="720" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000002D0" DisplayMethod="unsigned integer"/>
        <Element Offset="736" Vartype="Pointer" Bytesize="8" OffsetHex="000002E0" Description="Player HUD" DisplayMethod="unsigned integer"/>
        <Element Offset="744" Vartype="Pointer" Bytesize="8" OffsetHex="000002E8" Description="UseMachineInstruction" DisplayMethod="unsigned integer"/>
        <Element Offset="752" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000002F0" DisplayMethod="unsigned integer"/>
        <Element Offset="768" Vartype="Pointer" Bytesize="8" OffsetHex="00000300" Description="UseMagnetInstruction" DisplayMethod="unsigned integer"/>
        <Element Offset="776" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000308" DisplayMethod="unsigned integer"/>
        <Element Offset="792" Vartype="Byte" Bytesize="1" OffsetHex="00000318" Description="UseMagnetLineDone?" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="796" Vartype="Float" Bytesize="4" OffsetHex="0000031C" Description="InitialGameTime" DisplayMethod="unsigned integer"/>
        <Element Offset="800" Vartype="Pointer" Bytesize="8" OffsetHex="00000320" Description="HackMachineInstruction" DisplayMethod="unsigned integer"/>
        <Element Offset="808" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000328" DisplayMethod="unsigned integer"/>
        <Element Offset="824" Vartype="Byte" Bytesize="1" OffsetHex="00000338" Description="MagnetDone?" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="828" Vartype="8 Bytes" Bytesize="8" OffsetHex="0000033C" Description="CompPassCollectedState" DisplayMethod="unsigned integer"/>
      </Elements>
    </Structure>
    <Structure Name="PlayerPawn_C" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
      <Elements>
        <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="VTable" DisplayMethod="unsigned integer"/>
        <Element Offset="12" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000000C" Description="ObjectIndex" DisplayMethod="unsigned integer"/>
        <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="Class/Type" DisplayMethod="unsigned integer"/>
        <Element Offset="24" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000018" Description="FNameIndex" DisplayMethod="unsigned integer"/>
        <Element Offset="28" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000001C" DisplayMethod="unsigned integer"/>
        <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="Outer" DisplayMethod="unsigned integer"/>
        <Element Offset="40" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000028" Description="PrimaryActorTick" DisplayMethod="unsigned integer"/>
        <Element Offset="44" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000002C" DisplayMethod="unsigned integer"/>
        <Element Offset="48" Vartype="Byte" Bytesize="1" OffsetHex="00000030" Description="PrimaryActorTick.TickGroup" DisplayMethod="unsigned integer"/>
        <Element Offset="49" Vartype="Byte" Bytesize="1" OffsetHex="00000031" Description="PrimaryActorTick.EndTickGroup" DisplayMethod="unsigned integer"/>
        <Element Offset="50" Vartype="Byte" Bytesize="1" OffsetHex="00000032" Description="PrimaryActorTick.bStartWithTickEnabled" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="50" Vartype="Byte" Bytesize="1" OffsetHex="00000032" Description="PrimaryActorTick.bTickEvenWhenPaused" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="50" Vartype="Byte" Bytesize="1" OffsetHex="00000032" Description="PrimaryActorTick.bCanEverTick" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="50" Vartype="Byte" Bytesize="1" OffsetHex="00000032" Description="PrimaryActorTick.bAllowTickOnDedicatedServer" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="52" Vartype="Float" Bytesize="4" OffsetHex="00000034" Description="PrimaryActorTick.TickInterval" DisplayMethod="unsigned integer"/>
        <Element Offset="56" Vartype="4 Bytes" Bytesize="4" RLECount="8" OffsetHex="00000038" DisplayMethod="unsigned integer"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bHidden" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bReplicateMovement" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bExchangedRoles" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bTearOff" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bAlwaysRelevant" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bNetTemporary" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bNetStartup" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="88" Vartype="Byte" Bytesize="1" OffsetHex="00000058" Description="bOnlyRelevantToOwner" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bReplayRewindable" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bAllowTickBeforeBeginPlay" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bRelevantForNetworkReplays" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bNetUseOwnerRelevancy" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bRelevantForLevelBounds" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bNetLoadOnClient" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bAutoDestroyWhenFinished" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="89" Vartype="Byte" Bytesize="1" OffsetHex="00000059" Description="bCanBeDamaged" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bIsEditorOnlyActor" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bActorSeamlessTraveled" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bIgnoresOriginShifting" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bEnableAutoLODGeneration" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bFindCameraComponentWhenViewTarget" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bCollideWhenPlacing" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bBlockInput" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="90" Vartype="Byte" Bytesize="1" OffsetHex="0000005A" Description="bGenerateOverlapEventsDuringLevelStreaming" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="91" Vartype="Byte" Bytesize="1" OffsetHex="0000005B" Description="bAllowReceiveTickEventOnDedicatedServer" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="91" Vartype="Byte" Bytesize="1" OffsetHex="0000005B" Description="bReplicates" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="91" Vartype="Byte" Bytesize="1" OffsetHex="0000005B" Description="bCanBeInCluster" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="92" Vartype="Byte" Bytesize="1" OffsetHex="0000005C" Description="bActorIsBeingDestroyed" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="92" Vartype="Byte" Bytesize="1" OffsetHex="0000005C" Description="bActorEnableCollision" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="93" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000005D" Description="UpdateOverlapsMethodDuringLevelStreaming" DisplayMethod="unsigned integer"/>
        <Element Offset="94" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000005E" Description="DefaultUpdateOverlapsMethodDuringLevelStreaming" DisplayMethod="unsigned integer"/>
        <Element Offset="95" Vartype="Byte" Bytesize="1" OffsetHex="0000005F" Description="RemoteRole" DisplayMethod="unsigned integer"/>
        <Element Offset="96" Vartype="Float" Bytesize="4" OffsetHex="00000060" Description="ReplicatedMovement.LinearVelocity.X" DisplayMethod="unsigned integer"/>
        <Element Offset="100" Vartype="Float" Bytesize="4" OffsetHex="00000064" Description="ReplicatedMovement.LinearVelocity.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="104" Vartype="Float" Bytesize="4" OffsetHex="00000068" Description="ReplicatedMovement.LinearVelocity.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="108" Vartype="Float" Bytesize="4" OffsetHex="0000006C" Description="ReplicatedMovement.AngularVelocity.X" DisplayMethod="unsigned integer"/>
        <Element Offset="112" Vartype="Float" Bytesize="4" OffsetHex="00000070" Description="ReplicatedMovement.AngularVelocity.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="116" Vartype="Float" Bytesize="4" OffsetHex="00000074" Description="ReplicatedMovement.AngularVelocity.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="120" Vartype="Float" Bytesize="4" OffsetHex="00000078" Description="ReplicatedMovement.Location.X" DisplayMethod="unsigned integer"/>
        <Element Offset="124" Vartype="Float" Bytesize="4" OffsetHex="0000007C" Description="ReplicatedMovement.Location.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="128" Vartype="Float" Bytesize="4" OffsetHex="00000080" Description="ReplicatedMovement.Location.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="132" Vartype="Float" Bytesize="4" OffsetHex="00000084" Description="ReplicatedMovement.Rotation.Pitch" DisplayMethod="unsigned integer"/>
        <Element Offset="136" Vartype="Float" Bytesize="4" OffsetHex="00000088" Description="ReplicatedMovement.Rotation.Yaw" DisplayMethod="unsigned integer"/>
        <Element Offset="140" Vartype="Float" Bytesize="4" OffsetHex="0000008C" Description="ReplicatedMovement.Rotation.Roll" DisplayMethod="unsigned integer"/>
        <Element Offset="144" Vartype="Byte" Bytesize="1" OffsetHex="00000090" Description="ReplicatedMovement.bRepPhysics" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="144" Vartype="Byte" Bytesize="1" OffsetHex="00000090" Description="ReplicatedMovement.bSimulatedPhysicSleep" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="145" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000091" Description="ReplicatedMovement.LocationQuantizationLevel" DisplayMethod="unsigned integer"/>
        <Element Offset="146" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000092" Description="ReplicatedMovement.VelocityQuantizationLevel" DisplayMethod="unsigned integer"/>
        <Element Offset="147" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000093" Description="ReplicatedMovement.RotationQuantizationLevel" DisplayMethod="unsigned integer"/>
        <Element Offset="148" Vartype="Float" Bytesize="4" OffsetHex="00000094" Description="InitialLifeSpan" DisplayMethod="unsigned integer"/>
        <Element Offset="152" Vartype="Float" Bytesize="4" OffsetHex="00000098" Description="CustomTimeDilation" DisplayMethod="unsigned integer"/>
        <Element Offset="156" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="0000009C" DisplayMethod="unsigned integer"/>
        <Element Offset="168" Vartype="Pointer" Bytesize="8" OffsetHex="000000A8" Description="AttachmentReplication.AttachParent" DisplayMethod="unsigned integer"/>
        <Element Offset="176" Vartype="Float" Bytesize="4" OffsetHex="000000B0" Description="AttachmentReplication.LocationOffset.X" DisplayMethod="unsigned integer"/>
        <Element Offset="180" Vartype="Float" Bytesize="4" OffsetHex="000000B4" Description="AttachmentReplication.LocationOffset.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="184" Vartype="Float" Bytesize="4" OffsetHex="000000B8" Description="AttachmentReplication.LocationOffset.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="188" Vartype="Float" Bytesize="4" OffsetHex="000000BC" Description="AttachmentReplication.RelativeScale3D.X" DisplayMethod="unsigned integer"/>
        <Element Offset="192" Vartype="Float" Bytesize="4" OffsetHex="000000C0" Description="AttachmentReplication.RelativeScale3D.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="196" Vartype="Float" Bytesize="4" OffsetHex="000000C4" Description="AttachmentReplication.RelativeScale3D.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="200" Vartype="Float" Bytesize="4" OffsetHex="000000C8" Description="AttachmentReplication.RotationOffset.Pitch" DisplayMethod="unsigned integer"/>
        <Element Offset="204" Vartype="Float" Bytesize="4" OffsetHex="000000CC" Description="AttachmentReplication.RotationOffset.Yaw" DisplayMethod="unsigned integer"/>
        <Element Offset="208" Vartype="Float" Bytesize="4" OffsetHex="000000D0" Description="AttachmentReplication.RotationOffset.Roll" DisplayMethod="unsigned integer"/>
        <Element Offset="212" Vartype="8 Bytes" Bytesize="8" OffsetHex="000000D4" Description="AttachmentReplication.AttachSocket" DisplayMethod="unsigned integer"/>
        <Element Offset="224" Vartype="Pointer" Bytesize="8" OffsetHex="000000E0" Description="AttachmentReplication.AttachComponent" DisplayMethod="unsigned integer"/>
        <Element Offset="232" Vartype="Pointer" Bytesize="8" OffsetHex="000000E8" Description="Owner" DisplayMethod="unsigned integer"/>
        <Element Offset="240" Vartype="8 Bytes" Bytesize="8" OffsetHex="000000F0" Description="NetDriverName" DisplayMethod="unsigned integer"/>
        <Element Offset="248" Vartype="Byte" Bytesize="1" OffsetHex="000000F8" Description="Role" DisplayMethod="unsigned integer"/>
        <Element Offset="249" Vartype="Byte" Bytesize="1" OffsetHex="000000F9" Description="NetDormancy" DisplayMethod="unsigned integer"/>
        <Element Offset="250" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000FA" Description="SpawnCollisionHandlingMethod" DisplayMethod="unsigned integer"/>
        <Element Offset="251" Vartype="Byte" Bytesize="1" OffsetHex="000000FB" Description="AutoReceiveInput" DisplayMethod="unsigned integer"/>
        <Element Offset="252" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000FC" Description="InputPriority" DisplayMethod="unsigned integer"/>
        <Element Offset="256" Vartype="Pointer" Bytesize="8" OffsetHex="00000100" Description="InputComponent" DisplayMethod="unsigned integer"/>
        <Element Offset="264" Vartype="Float" Bytesize="4" OffsetHex="00000108" Description="NetCullDistanceSquared" DisplayMethod="unsigned integer"/>
        <Element Offset="268" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000010C" Description="NetTag" DisplayMethod="unsigned integer"/>
        <Element Offset="272" Vartype="Float" Bytesize="4" OffsetHex="00000110" Description="NetUpdateFrequency" DisplayMethod="unsigned integer"/>
        <Element Offset="276" Vartype="Float" Bytesize="4" OffsetHex="00000114" Description="MinNetUpdateFrequency" DisplayMethod="unsigned integer"/>
        <Element Offset="280" Vartype="Float" Bytesize="4" OffsetHex="00000118" Description="NetPriority" DisplayMethod="unsigned integer"/>
        <Element Offset="284" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000011C" DisplayMethod="unsigned integer"/>
        <Element Offset="288" Vartype="Pointer" Bytesize="8" OffsetHex="00000120" Description="Instigator" DisplayMethod="unsigned integer"/>
        <Element Offset="296" Vartype="Pointer" Bytesize="8" OffsetHex="00000128" Description="Children" DisplayMethod="unsigned integer">
          <Structure Name="Children[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] Children" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] Children" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="304" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000130" Description="Children_size" DisplayMethod="unsigned integer"/>
        <Element Offset="308" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000134" Description="Children_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="312" Vartype="Pointer" Bytesize="8" OffsetHex="00000138" Description="RootComponent" DisplayMethod="unsigned integer"/>
        <Element Offset="320" Vartype="Pointer" Bytesize="8" OffsetHex="00000140" Description="ControllingMatineeActors" DisplayMethod="unsigned integer">
          <Structure Name="ControllingMatineeActors[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] ControllingMatineeActors" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="328" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000148" Description="ControllingMatineeActors_size" DisplayMethod="unsigned integer"/>
        <Element Offset="332" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000014C" Description="ControllingMatineeActors_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="336" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000150" DisplayMethod="unsigned integer"/>
        <Element Offset="344" Vartype="Pointer" Bytesize="8" OffsetHex="00000158" Description="Layers" DisplayMethod="unsigned integer">
          <Structure Name="Layers[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000000" Description="[0] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000008" Description="[1] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000010" Description="[2] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000018" Description="[3] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000020" Description="[4] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000028" Description="[5] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000030" Description="[6] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000038" Description="[7] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000040" Description="[8] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000048" Description="[9] Layers" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000050" Description="[10] Layers" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="352" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000160" Description="Layers_size" DisplayMethod="unsigned integer"/>
        <Element Offset="356" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000164" Description="Layers_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="360" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000168" Description="ParentComponent" DisplayMethod="unsigned integer"/>
        <Element Offset="364" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="0000016C" DisplayMethod="unsigned integer"/>
        <Element Offset="376" Vartype="Pointer" Bytesize="8" OffsetHex="00000178" Description="Tags" DisplayMethod="unsigned integer">
          <Structure Name="Tags[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000000" Description="[0] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000008" Description="[1] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000010" Description="[2] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000018" Description="[3] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000020" Description="[4] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000028" Description="[5] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000030" Description="[6] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000038" Description="[7] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000040" Description="[8] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000048" Description="[9] Tags" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000050" Description="[10] Tags" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="384" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000180" Description="Tags_size" DisplayMethod="unsigned integer"/>
        <Element Offset="388" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000184" Description="Tags_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="392" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000188" Description="OnTakeAnyDamage" DisplayMethod="unsigned integer"/>
        <Element Offset="393" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000189" Description="OnTakePointDamage" DisplayMethod="unsigned integer"/>
        <Element Offset="394" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000018A" Description="OnTakeRadialDamage" DisplayMethod="unsigned integer"/>
        <Element Offset="395" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000018B" Description="OnActorBeginOverlap" DisplayMethod="unsigned integer"/>
        <Element Offset="396" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000018C" Description="OnActorEndOverlap" DisplayMethod="unsigned integer"/>
        <Element Offset="397" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000018D" Description="OnBeginCursorOver" DisplayMethod="unsigned integer"/>
        <Element Offset="398" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000018E" Description="OnEndCursorOver" DisplayMethod="unsigned integer"/>
        <Element Offset="399" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000018F" Description="OnClicked" DisplayMethod="unsigned integer"/>
        <Element Offset="400" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000190" Description="OnReleased" DisplayMethod="unsigned integer"/>
        <Element Offset="401" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000191" Description="OnInputTouchBegin" DisplayMethod="unsigned integer"/>
        <Element Offset="402" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000192" Description="OnInputTouchEnd" DisplayMethod="unsigned integer"/>
        <Element Offset="403" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000193" Description="OnInputTouchEnter" DisplayMethod="unsigned integer"/>
        <Element Offset="404" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000194" Description="OnInputTouchLeave" DisplayMethod="unsigned integer"/>
        <Element Offset="405" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000195" Description="OnActorHit" DisplayMethod="unsigned integer"/>
        <Element Offset="406" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000196" Description="OnDestroyed" DisplayMethod="unsigned integer"/>
        <Element Offset="407" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000197" Description="OnEndPlay" DisplayMethod="unsigned integer"/>
        <Element Offset="412" Vartype="4 Bytes" Bytesize="4" RLECount="23" OffsetHex="0000019C" DisplayMethod="unsigned integer"/>
        <Element Offset="504" Vartype="Pointer" Bytesize="8" OffsetHex="000001F8" Description="InstanceComponents" DisplayMethod="unsigned integer">
          <Structure Name="InstanceComponents[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] InstanceComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] InstanceComponents" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="512" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000200" Description="InstanceComponents_size" DisplayMethod="unsigned integer"/>
        <Element Offset="516" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000204" Description="InstanceComponents_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="520" Vartype="Pointer" Bytesize="8" OffsetHex="00000208" Description="BlueprintCreatedComponents" DisplayMethod="unsigned integer">
          <Structure Name="BlueprintCreatedComponents[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] BlueprintCreatedComponents" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="528" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000210" Description="BlueprintCreatedComponents_size" DisplayMethod="unsigned integer"/>
        <Element Offset="532" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000214" Description="BlueprintCreatedComponents_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="536" Vartype="4 Bytes" Bytesize="4" RLECount="6" OffsetHex="00000218" DisplayMethod="unsigned integer"/>
        <Element Offset="560" Vartype="Byte" Bytesize="1" OffsetHex="00000230" Description="bUseControllerRotationRoll" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="560" Vartype="Byte" Bytesize="1" OffsetHex="00000230" Description="bCanAffectNavigationGeneration" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="560" Vartype="Byte" Bytesize="1" OffsetHex="00000230" Description="bUseControllerRotationYaw" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="560" Vartype="Byte" Bytesize="1" OffsetHex="00000230" Description="bUseControllerRotationPitch" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="564" Vartype="Float" Bytesize="4" OffsetHex="00000234" Description="BaseEyeHeight" DisplayMethod="unsigned integer"/>
        <Element Offset="568" Vartype="Byte" Bytesize="1" OffsetHex="00000238" Description="AutoPossessPlayer" DisplayMethod="unsigned integer"/>
        <Element Offset="569" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000239" Description="AutoPossessAI" DisplayMethod="unsigned integer"/>
        <Element Offset="570" Vartype="Byte" Bytesize="1" OffsetHex="0000023A" Description="RemoteViewPitch" DisplayMethod="unsigned integer"/>
        <Element Offset="576" Vartype="Pointer" Bytesize="8" OffsetHex="00000240" Description="AIControllerClass" DisplayMethod="unsigned integer"/>
        <Element Offset="584" Vartype="Pointer" Bytesize="8" OffsetHex="00000248" Description="PlayerState" DisplayMethod="unsigned integer"/>
        <Element Offset="592" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000250" DisplayMethod="unsigned integer"/>
        <Element Offset="600" Vartype="Pointer" Bytesize="8" OffsetHex="00000258" Description="LastHitBy" DisplayMethod="unsigned integer"/>
        <Element Offset="608" Vartype="Pointer" Bytesize="8" OffsetHex="00000260" Description="Controller" DisplayMethod="unsigned integer"/>
        <Element Offset="620" Vartype="Float" Bytesize="4" OffsetHex="0000026C" Description="ControlInputVector.X" DisplayMethod="unsigned integer"/>
        <Element Offset="624" Vartype="Float" Bytesize="4" OffsetHex="00000270" Description="ControlInputVector.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="628" Vartype="Float" Bytesize="4" OffsetHex="00000274" Description="ControlInputVector.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="632" Vartype="Float" Bytesize="4" OffsetHex="00000278" Description="LastControlInputVector.X" DisplayMethod="unsigned integer"/>
        <Element Offset="636" Vartype="Float" Bytesize="4" OffsetHex="0000027C" Description="LastControlInputVector.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="640" Vartype="Float" Bytesize="4" OffsetHex="00000280" Description="LastControlInputVector.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="644" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000284" DisplayMethod="unsigned integer"/>
        <Element Offset="648" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000288" Description="UberGraphFrame" DisplayMethod="unsigned integer"/>
        <Element Offset="652" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000028C" DisplayMethod="unsigned integer"/>
        <Element Offset="656" Vartype="Pointer" Bytesize="8" OffsetHex="00000290" Description="Play_sfx_minigame_pqA2_sword_swing" DisplayMethod="unsigned integer"/>
        <Element Offset="664" Vartype="Pointer" Bytesize="8" OffsetHex="00000298" Description="Play_CAS_PlayerDeath" DisplayMethod="unsigned integer"/>
        <Element Offset="672" Vartype="Pointer" Bytesize="8" OffsetHex="000002A0" Description="Play_CAS_PlayerDamage" DisplayMethod="unsigned integer"/>
        <Element Offset="680" Vartype="Pointer" Bytesize="8" OffsetHex="000002A8" Description="Play_CAS_Get_SmallItem" DisplayMethod="unsigned integer"/>
        <Element Offset="688" Vartype="Pointer" Bytesize="8" OffsetHex="000002B0" Description="Play_CAS_FootStep_Stone" DisplayMethod="unsigned integer"/>
        <Element Offset="696" Vartype="Pointer" Bytesize="8" OffsetHex="000002B8" Description="Hitbox_EnemyChild_Basic" DisplayMethod="unsigned integer"/>
        <Element Offset="704" Vartype="Pointer" Bytesize="8" OffsetHex="000002C0" Description="StandingCollision" DisplayMethod="unsigned integer"/>
        <Element Offset="712" Vartype="Pointer" Bytesize="8" OffsetHex="000002C8" Description="CameraBoom" DisplayMethod="unsigned integer"/>
        <Element Offset="720" Vartype="Pointer" Bytesize="8" OffsetHex="000002D0" Description="AttackParentShadow" DisplayMethod="unsigned integer"/>
        <Element Offset="728" Vartype="Pointer" Bytesize="8" OffsetHex="000002D8" Description="AttackCollisionShadow" DisplayMethod="unsigned integer"/>
        <Element Offset="736" Vartype="Pointer" Bytesize="8" OffsetHex="000002E0" Description="ShadowFlipbook" DisplayMethod="unsigned integer"/>
        <Element Offset="744" Vartype="Pointer" Bytesize="8" OffsetHex="000002E8" Description="LightsRoot" DisplayMethod="unsigned integer"/>
        <Element Offset="752" Vartype="Pointer" Bytesize="8" OffsetHex="000002F0" Description="AmbientSpot" DisplayMethod="unsigned integer"/>
        <Element Offset="760" Vartype="Pointer" Bytesize="8" OffsetHex="000002F8" Description="CAS_Glitches_Loop" DisplayMethod="unsigned integer"/>
        <Element Offset="768" Vartype="Pointer" Bytesize="8" OffsetHex="00000300" Description="Audio" DisplayMethod="unsigned integer"/>
        <Element Offset="776" Vartype="Pointer" Bytesize="8" OffsetHex="00000308" Description="EnemyBat" DisplayMethod="unsigned integer"/>
        <Element Offset="784" Vartype="Pointer" Bytesize="8" OffsetHex="00000310" Description="LanternSprite" DisplayMethod="unsigned integer"/>
        <Element Offset="792" Vartype="Pointer" Bytesize="8" OffsetHex="00000318" Description="LanternRoot" DisplayMethod="unsigned integer"/>
        <Element Offset="800" Vartype="Pointer" Bytesize="8" OffsetHex="00000320" Description="BodyCapsule" DisplayMethod="unsigned integer"/>
        <Element Offset="808" Vartype="Pointer" Bytesize="8" OffsetHex="00000328" Description="RootBox" DisplayMethod="unsigned integer"/>
        <Element Offset="816" Vartype="Pointer" Bytesize="8" OffsetHex="00000330" Description="CharacterFlipbook" DisplayMethod="unsigned integer"/>
        <Element Offset="824" Vartype="Pointer" Bytesize="8" OffsetHex="00000338" Description="AttackParent" DisplayMethod="unsigned integer"/>
        <Element Offset="832" Vartype="Pointer" Bytesize="8" OffsetHex="00000340" Description="InteractCollision" DisplayMethod="unsigned integer"/>
        <Element Offset="840" Vartype="Pointer" Bytesize="8" OffsetHex="00000348" Description="EnemyTarget" DisplayMethod="unsigned integer"/>
        <Element Offset="848" Vartype="Pointer" Bytesize="8" OffsetHex="00000350" Description="AttackCollision" DisplayMethod="unsigned integer"/>
        <Element Offset="856" Vartype="Pointer" Bytesize="8" OffsetHex="00000358" Description="NarrowSpot" DisplayMethod="unsigned integer"/>
        <Element Offset="864" Vartype="Pointer" Bytesize="8" OffsetHex="00000360" Description="WideSpot" DisplayMethod="unsigned integer"/>
        <Element Offset="872" Vartype="Pointer" Bytesize="8" OffsetHex="00000368" Description="CameraComponent" DisplayMethod="unsigned integer"/>
        <Element Offset="880" Vartype="Float" Bytesize="4" OffsetHex="00000370" Description="BossGlitchTimeline_NewTrack_0_5A788EAC4DFD28A1A470D1BB4BB7016A" DisplayMethod="unsigned integer"/>
        <Element Offset="884" Vartype="Byte" Bytesize="1" OffsetHex="00000374" Description="BossGlitchTimeline__Direction_5A788EAC4DFD28A1A470D1BB4BB7016A" DisplayMethod="unsigned integer"/>
        <Element Offset="888" Vartype="Pointer" Bytesize="8" OffsetHex="00000378" Description="BossGlitchTimeline" DisplayMethod="unsigned integer"/>
        <Element Offset="896" Vartype="Float" Bytesize="4" OffsetHex="00000380" Description="Timeline_0_NewTrack_2_AAF529FC4C7CF0DC34A5AA928353EF87" DisplayMethod="unsigned integer"/>
        <Element Offset="900" Vartype="Float" Bytesize="4" OffsetHex="00000384" Description="Timeline_0_NewTrack_1_AAF529FC4C7CF0DC34A5AA928353EF87" DisplayMethod="unsigned integer"/>
        <Element Offset="904" Vartype="Float" Bytesize="4" OffsetHex="00000388" Description="Timeline_0_NewTrack_0_AAF529FC4C7CF0DC34A5AA928353EF87" DisplayMethod="unsigned integer"/>
        <Element Offset="908" Vartype="Byte" Bytesize="1" OffsetHex="0000038C" Description="Timeline_0__Direction_AAF529FC4C7CF0DC34A5AA928353EF87" DisplayMethod="unsigned integer"/>
        <Element Offset="912" Vartype="Pointer" Bytesize="8" OffsetHex="00000390" Description="Timeline_0" DisplayMethod="unsigned integer"/>
        <Element Offset="920" Vartype="Float" Bytesize="4" OffsetHex="00000398" Description="Timeline_2_LightInten_46428263481E0A2BE000738740B61948" DisplayMethod="unsigned integer"/>
        <Element Offset="924" Vartype="Float" Bytesize="4" OffsetHex="0000039C" Description="Timeline_2_NewTrack_0_46428263481E0A2BE000738740B61948" DisplayMethod="unsigned integer"/>
        <Element Offset="928" Vartype="Byte" Bytesize="1" OffsetHex="000003A0" Description="Timeline_2__Direction_46428263481E0A2BE000738740B61948" DisplayMethod="unsigned integer"/>
        <Element Offset="932" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003A4" DisplayMethod="unsigned integer"/>
        <Element Offset="936" Vartype="Pointer" Bytesize="8" OffsetHex="000003A8" Description="Timeline_2" DisplayMethod="unsigned integer"/>
        <Element Offset="944" Vartype="Float" Bytesize="4" OffsetHex="000003B0" Description="LanternSwing_NewTrack_0_4C79C7D34DD76DE24D9AF399CD284E62" DisplayMethod="unsigned integer"/>
        <Element Offset="948" Vartype="Byte" Bytesize="1" OffsetHex="000003B4" Description="LanternSwing__Direction_4C79C7D34DD76DE24D9AF399CD284E62" DisplayMethod="unsigned integer"/>
        <Element Offset="952" Vartype="Pointer" Bytesize="8" OffsetHex="000003B8" Description="LanternSwing" DisplayMethod="unsigned integer"/>
        <Element Offset="960" Vartype="Float" Bytesize="4" OffsetHex="000003C0" Description="Timeline_1_LightInten_B499DF744F28D585794EB99E307512AE" DisplayMethod="unsigned integer"/>
        <Element Offset="964" Vartype="Float" Bytesize="4" OffsetHex="000003C4" Description="Timeline_1_NewTrack_0_B499DF744F28D585794EB99E307512AE" DisplayMethod="unsigned integer"/>
        <Element Offset="968" Vartype="Byte" Bytesize="1" OffsetHex="000003C8" Description="Timeline_1__Direction_B499DF744F28D585794EB99E307512AE" DisplayMethod="unsigned integer"/>
        <Element Offset="972" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003CC" DisplayMethod="unsigned integer"/>
        <Element Offset="976" Vartype="Pointer" Bytesize="8" OffsetHex="000003D0" Description="Timeline_1" DisplayMethod="unsigned integer"/>
        <Element Offset="984" Vartype="Float" Bytesize="4" OffsetHex="000003D8" Description="DamagedBlink_NewTrack_0_541B2B9E45E403FB2729ABB5251CE5DC" DisplayMethod="unsigned integer"/>
        <Element Offset="988" Vartype="Byte" Bytesize="1" OffsetHex="000003DC" Description="DamagedBlink__Direction_541B2B9E45E403FB2729ABB5251CE5DC" DisplayMethod="unsigned integer"/>
        <Element Offset="992" Vartype="Pointer" Bytesize="8" OffsetHex="000003E0" Description="DamagedBlink" DisplayMethod="unsigned integer"/>
        <Element Offset="1000" Vartype="Float" Bytesize="4" OffsetHex="000003E8" Description="MovementSpeed" DisplayMethod="unsigned integer"/>
        <Element Offset="1004" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003EC" Description="PlayerMaxHP" DisplayMethod="unsigned integer"/>
        <Element Offset="1008" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003F0" Description="PlayerHP" DisplayMethod="unsigned integer"/>
        <Element Offset="1012" Vartype="Float" Bytesize="4" OffsetHex="000003F4" Description="deltaTime" DisplayMethod="unsigned integer"/>
        <Element Offset="1016" Vartype="Byte" Bytesize="1" OffsetHex="000003F8" Description="CanAttack" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1017" Vartype="Byte" Bytesize="1" OffsetHex="000003F9" Description="IsAttacking" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1018" Vartype="Byte" Bytesize="1" OffsetHex="000003FA" Description="CanBeDamaged" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1024" Vartype="Pointer" Bytesize="8" OffsetHex="00000400" Description="PlayerUI" DisplayMethod="unsigned integer"/>
        <Element Offset="1032" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000408" Description="WeaponType" DisplayMethod="unsigned integer"/>
        <Element Offset="1036" Vartype="Byte" Bytesize="1" OffsetHex="0000040C" Description="CanMove" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1040" Vartype="Float" Bytesize="4" OffsetHex="00000410" Description="TeleportDestinationLocation.X" DisplayMethod="unsigned integer"/>
        <Element Offset="1044" Vartype="Float" Bytesize="4" OffsetHex="00000414" Description="TeleportDestinationLocation.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="1048" Vartype="Float" Bytesize="4" OffsetHex="00000418" Description="TeleportDestinationLocation.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="1052" Vartype="Byte" Bytesize="1" OffsetHex="0000041C" Description="UsingStairs" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1053" Vartype="Byte" Bytesize="1" OffsetHex="0000041D" Description="HasBossKey" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1056" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000420" Description="NumberOfSmallKeys" DisplayMethod="unsigned integer"/>
        <Element Offset="1060" Vartype="Float" Bytesize="4" OffsetHex="00000424" Description="BaseMovementSpeed" DisplayMethod="unsigned integer"/>
        <Element Offset="1064" Vartype="Float" Bytesize="4" OffsetHex="00000428" Description="SpotOuterConeAngle" DisplayMethod="unsigned integer"/>
        <Element Offset="1068" Vartype="Float" Bytesize="4" OffsetHex="0000042C" Description="LightsRootTargetY" DisplayMethod="unsigned integer"/>
        <Element Offset="1072" Vartype="Float" Bytesize="4" OffsetHex="00000430" Description="LightsInterpSpeed" DisplayMethod="unsigned integer"/>
        <Element Offset="1076" Vartype="Float" Bytesize="4" OffsetHex="00000434" Description="WideIntensityDefault" DisplayMethod="unsigned integer"/>
        <Element Offset="1080" Vartype="Float" Bytesize="4" OffsetHex="00000438" Description="NarrowIntensityDefault" DisplayMethod="unsigned integer"/>
        <Element Offset="1084" Vartype="Float" Bytesize="4" OffsetHex="0000043C" Description="LightEquippedIntensityMult" DisplayMethod="unsigned integer"/>
        <Element Offset="1088" Vartype="Byte" Bytesize="1" OffsetHex="00000440" Description="UsingDoor" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1089" Vartype="Byte" Bytesize="1" OffsetHex="00000441" Description="HasLantern" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1092" Vartype="Float" Bytesize="4" OffsetHex="00000444" Description="MoveX" DisplayMethod="unsigned integer"/>
        <Element Offset="1096" Vartype="Float" Bytesize="4" OffsetHex="00000448" Description="MoveY" DisplayMethod="unsigned integer"/>
        <Element Offset="1100" Vartype="Float" Bytesize="4" OffsetHex="0000044C" Description="LanternSwingValue" DisplayMethod="unsigned integer"/>
        <Element Offset="1104" Vartype="Float" Bytesize="4" OffsetHex="00000450" Description="LanternSwingAmount" DisplayMethod="unsigned integer"/>
        <Element Offset="1108" Vartype="Float" Bytesize="4" OffsetHex="00000454" Description="LanternSwingTarget" DisplayMethod="unsigned integer"/>
        <Element Offset="1112" Vartype="Float" Bytesize="4" OffsetHex="00000458" Description="LanternSwingMult" DisplayMethod="unsigned integer"/>
        <Element Offset="1116" Vartype="Float" Bytesize="4" OffsetHex="0000045C" Description="LanternSwingInterpSpeed" DisplayMethod="unsigned integer"/>
        <Element Offset="1120" Vartype="Float" Bytesize="4" OffsetHex="00000460" Description="StairsInterpLocation.X" DisplayMethod="unsigned integer"/>
        <Element Offset="1124" Vartype="Float" Bytesize="4" OffsetHex="00000464" Description="StairsInterpLocation.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="1128" Vartype="Float" Bytesize="4" OffsetHex="00000468" Description="StairsInterpLocation.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="1132" Vartype="Byte" Bytesize="1" OffsetHex="0000046C" Description="Direction" DisplayMethod="unsigned integer"/>
        <Element Offset="1133" Vartype="Byte" Bytesize="1" OffsetHex="0000046D" Description="IsIdle" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1136" Vartype="Float" Bytesize="4" OffsetHex="00000470" Description="FootstepTrackingValue" DisplayMethod="unsigned integer"/>
        <Element Offset="1140" Vartype="Float" Bytesize="4" OffsetHex="00000474" Description="FootstepDistance" DisplayMethod="unsigned integer"/>
        <Element Offset="1144" Vartype="Byte" Bytesize="1" OffsetHex="00000478" Description="HasSword" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1148" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000047C" DisplayMethod="unsigned integer"/>
        <Element Offset="1152" Vartype="Pointer" Bytesize="8" OffsetHex="00000480" Description="GlitchMaterial" DisplayMethod="unsigned integer"/>
        <Element Offset="1160" Vartype="Byte" Bytesize="1" OffsetHex="00000488" Description="IsDead" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1161" Vartype="Byte" Bytesize="1" OffsetHex="00000489" Description="NewVar_0" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1162" Vartype="Byte" Bytesize="1" OffsetHex="0000048A" Description="HasShadow" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1164" Vartype="Float" Bytesize="4" OffsetHex="0000048C" Description="ShadowOffset.X" DisplayMethod="unsigned integer"/>
        <Element Offset="1168" Vartype="Float" Bytesize="4" OffsetHex="00000490" Description="ShadowOffset.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="1172" Vartype="Float" Bytesize="4" OffsetHex="00000494" Description="ShadowOffset.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="1176" Vartype="Float" Bytesize="4" OffsetHex="00000498" Description="CameraBoomTarget.X" DisplayMethod="unsigned integer"/>
        <Element Offset="1180" Vartype="Float" Bytesize="4" OffsetHex="0000049C" Description="CameraBoomTarget.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="1184" Vartype="Float" Bytesize="4" OffsetHex="000004A0" Description="CameraBoomTarget.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="1188" Vartype="Byte" Bytesize="1" OffsetHex="000004A4" Description="CameraPinned" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1192" Vartype="Float" Bytesize="4" OffsetHex="000004A8" Description="UnpinCameraLag" DisplayMethod="unsigned integer"/>
        <Element Offset="1196" Vartype="Float" Bytesize="4" OffsetHex="000004AC" Description="PinnedCameraLag" DisplayMethod="unsigned integer"/>
        <Element Offset="1200" Vartype="Byte" Bytesize="1" OffsetHex="000004B0" Description="CameraPinnedBlending" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1204" Vartype="4 Bytes" Bytesize="4" OffsetHex="000004B4" DisplayMethod="unsigned integer"/>
        <Element Offset="1208" Vartype="Pointer" Bytesize="8" OffsetHex="000004B8" Description="AttackingBat" DisplayMethod="unsigned integer"/>
        <Element Offset="1216" Vartype="4 Bytes" Bytesize="4" OffsetHex="000004C0" Description="LeavingRoom" DisplayMethod="unsigned integer"/>
        <Element Offset="1220" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000004C4" DisplayMethod="unsigned integer"/>
        <Element Offset="1232" Vartype="Byte" Bytesize="1" OffsetHex="000004D0" Description="HasGlitchPlush" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1233" Vartype="Byte" Bytesize="1" OffsetHex="000004D1" Description="HasGlitchMask" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1240" Vartype="4 Bytes" Bytesize="4" OffsetHex="000004D8" Description="PickedUpGlitchItem" DisplayMethod="unsigned integer"/>
      </Elements>
    </Structure>
    <Structure Name="BoxComponent" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
      <Elements>
        <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="VTable" DisplayMethod="unsigned integer"/>
        <Element Offset="12" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000000C" Description="ObjectIndex" DisplayMethod="unsigned integer"/>
        <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="Class/Type" DisplayMethod="unsigned integer"/>
        <Element Offset="24" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000018" Description="FNameIndex" DisplayMethod="unsigned integer"/>
        <Element Offset="28" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000001C" DisplayMethod="unsigned integer"/>
        <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="Outer" DisplayMethod="unsigned integer"/>
        <Element Offset="40" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000028" DisplayMethod="unsigned integer"/>
        <Element Offset="48" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000030" Description="PrimaryComponentTick" DisplayMethod="unsigned integer"/>
        <Element Offset="52" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000034" DisplayMethod="unsigned integer"/>
        <Element Offset="56" Vartype="Byte" Bytesize="1" OffsetHex="00000038" Description="PrimaryComponentTick.TickGroup" DisplayMethod="unsigned integer"/>
        <Element Offset="57" Vartype="Byte" Bytesize="1" OffsetHex="00000039" Description="PrimaryComponentTick.EndTickGroup" DisplayMethod="unsigned integer"/>
        <Element Offset="58" Vartype="Byte" Bytesize="1" OffsetHex="0000003A" Description="PrimaryComponentTick.bAllowTickOnDedicatedServer" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="58" Vartype="Byte" Bytesize="1" OffsetHex="0000003A" Description="PrimaryComponentTick.bCanEverTick" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="58" Vartype="Byte" Bytesize="1" OffsetHex="0000003A" Description="PrimaryComponentTick.bTickEvenWhenPaused" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="58" Vartype="Byte" Bytesize="1" OffsetHex="0000003A" Description="PrimaryComponentTick.bStartWithTickEnabled" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="60" Vartype="Float" Bytesize="4" OffsetHex="0000003C" Description="PrimaryComponentTick.TickInterval" DisplayMethod="unsigned integer"/>
        <Element Offset="64" Vartype="4 Bytes" Bytesize="4" RLECount="8" OffsetHex="00000040" DisplayMethod="unsigned integer"/>
        <Element Offset="96" Vartype="Pointer" Bytesize="8" OffsetHex="00000060" Description="ComponentTags" DisplayMethod="unsigned integer">
          <Structure Name="ComponentTags[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000000" Description="[0] ComponentTags" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000008" Description="[1] ComponentTags" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000010" Description="[2] ComponentTags" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000018" Description="[3] ComponentTags" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000020" Description="[4] ComponentTags" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000028" Description="[5] ComponentTags" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000030" Description="[6] ComponentTags" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000038" Description="[7] ComponentTags" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000040" Description="[8] ComponentTags" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000048" Description="[9] ComponentTags" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000050" Description="[10] ComponentTags" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="104" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000068" Description="ComponentTags_size" DisplayMethod="unsigned integer"/>
        <Element Offset="108" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000006C" Description="ComponentTags_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="112" Vartype="Pointer" Bytesize="8" OffsetHex="00000070" Description="AssetUserData" DisplayMethod="unsigned integer">
          <Structure Name="AssetUserData[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] AssetUserData" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] AssetUserData" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] AssetUserData" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] AssetUserData" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] AssetUserData" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] AssetUserData" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] AssetUserData" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] AssetUserData" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] AssetUserData" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] AssetUserData" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] AssetUserData" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="120" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000078" Description="AssetUserData_size" DisplayMethod="unsigned integer"/>
        <Element Offset="124" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000007C" Description="AssetUserData_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="128" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000080" DisplayMethod="unsigned integer"/>
        <Element Offset="132" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000084" Description="UCSSerializationIndex" DisplayMethod="unsigned integer"/>
        <Element Offset="136" Vartype="Byte" Bytesize="1" OffsetHex="00000088" Description="bNetAddressable" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="136" Vartype="Byte" Bytesize="1" OffsetHex="00000088" Description="bReplicates" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="137" Vartype="Byte" Bytesize="1" OffsetHex="00000089" Description="bAutoActivate" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="138" Vartype="Byte" Bytesize="1" OffsetHex="0000008A" Description="bEditableWhenInherited" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="138" Vartype="Byte" Bytesize="1" OffsetHex="0000008A" Description="bCanEverAffectNavigation" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="138" Vartype="Byte" Bytesize="1" OffsetHex="0000008A" Description="bIsActive" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="138" Vartype="Byte" Bytesize="1" OffsetHex="0000008A" Description="bIsEditorOnly" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="140" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000008C" Description="CreationMethod" DisplayMethod="unsigned integer"/>
        <Element Offset="141" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000008D" Description="OnComponentActivated" DisplayMethod="unsigned integer"/>
        <Element Offset="142" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000008E" Description="OnComponentDeactivated" DisplayMethod="unsigned integer"/>
        <Element Offset="144" Vartype="Pointer" Bytesize="8" OffsetHex="00000090" Description="UCSModifiedProperties" DisplayMethod="unsigned integer">
          <Structure Name="SimpleMemberReference[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] MemberParent" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000008" Description="[0] MemberName" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000010" Description="[0] MemberGuid.A" DisplayMethod="unsigned integer"/>
              <Element Offset="20" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000014" Description="[0] MemberGuid.B" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000018" Description="[0] MemberGuid.C" DisplayMethod="unsigned integer"/>
              <Element Offset="28" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000001C" Description="[0] MemberGuid.D" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[1] MemberParent" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000028" Description="[1] MemberName" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000030" Description="[1] MemberGuid.A" DisplayMethod="unsigned integer"/>
              <Element Offset="52" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000034" Description="[1] MemberGuid.B" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000038" Description="[1] MemberGuid.C" DisplayMethod="unsigned integer"/>
              <Element Offset="60" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000003C" Description="[1] MemberGuid.D" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[2] MemberParent" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000048" Description="[2] MemberName" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000050" Description="[2] MemberGuid.A" DisplayMethod="unsigned integer"/>
              <Element Offset="84" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000054" Description="[2] MemberGuid.B" DisplayMethod="unsigned integer"/>
              <Element Offset="88" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000058" Description="[2] MemberGuid.C" DisplayMethod="unsigned integer"/>
              <Element Offset="92" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000005C" Description="[2] MemberGuid.D" DisplayMethod="unsigned integer"/>
              <Element Offset="96" Vartype="Pointer" Bytesize="8" OffsetHex="00000060" Description="[3] MemberParent" DisplayMethod="unsigned integer"/>
              <Element Offset="104" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000068" Description="[3] MemberName" DisplayMethod="unsigned integer"/>
              <Element Offset="112" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000070" Description="[3] MemberGuid.A" DisplayMethod="unsigned integer"/>
              <Element Offset="116" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000074" Description="[3] MemberGuid.B" DisplayMethod="unsigned integer"/>
              <Element Offset="120" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000078" Description="[3] MemberGuid.C" DisplayMethod="unsigned integer"/>
              <Element Offset="124" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000007C" Description="[3] MemberGuid.D" DisplayMethod="unsigned integer"/>
              <Element Offset="128" Vartype="Pointer" Bytesize="8" OffsetHex="00000080" Description="[4] MemberParent" DisplayMethod="unsigned integer"/>
              <Element Offset="136" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000088" Description="[4] MemberName" DisplayMethod="unsigned integer"/>
              <Element Offset="144" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000090" Description="[4] MemberGuid.A" DisplayMethod="unsigned integer"/>
              <Element Offset="148" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000094" Description="[4] MemberGuid.B" DisplayMethod="unsigned integer"/>
              <Element Offset="152" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000098" Description="[4] MemberGuid.C" DisplayMethod="unsigned integer"/>
              <Element Offset="156" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000009C" Description="[4] MemberGuid.D" DisplayMethod="unsigned integer"/>
              <Element Offset="160" Vartype="Pointer" Bytesize="8" OffsetHex="000000A0" Description="[5] MemberParent" DisplayMethod="unsigned integer"/>
              <Element Offset="168" Vartype="8 Bytes" Bytesize="8" OffsetHex="000000A8" Description="[5] MemberName" DisplayMethod="unsigned integer"/>
              <Element Offset="176" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000B0" Description="[5] MemberGuid.A" DisplayMethod="unsigned integer"/>
              <Element Offset="180" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000B4" Description="[5] MemberGuid.B" DisplayMethod="unsigned integer"/>
              <Element Offset="184" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000B8" Description="[5] MemberGuid.C" DisplayMethod="unsigned integer"/>
              <Element Offset="188" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000BC" Description="[5] MemberGuid.D" DisplayMethod="unsigned integer"/>
              <Element Offset="192" Vartype="Pointer" Bytesize="8" OffsetHex="000000C0" Description="[6] MemberParent" DisplayMethod="unsigned integer"/>
              <Element Offset="200" Vartype="8 Bytes" Bytesize="8" OffsetHex="000000C8" Description="[6] MemberName" DisplayMethod="unsigned integer"/>
              <Element Offset="208" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000D0" Description="[6] MemberGuid.A" DisplayMethod="unsigned integer"/>
              <Element Offset="212" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000D4" Description="[6] MemberGuid.B" DisplayMethod="unsigned integer"/>
              <Element Offset="216" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000D8" Description="[6] MemberGuid.C" DisplayMethod="unsigned integer"/>
              <Element Offset="220" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000DC" Description="[6] MemberGuid.D" DisplayMethod="unsigned integer"/>
              <Element Offset="224" Vartype="Pointer" Bytesize="8" OffsetHex="000000E0" Description="[7] MemberParent" DisplayMethod="unsigned integer"/>
              <Element Offset="232" Vartype="8 Bytes" Bytesize="8" OffsetHex="000000E8" Description="[7] MemberName" DisplayMethod="unsigned integer"/>
              <Element Offset="240" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000F0" Description="[7] MemberGuid.A" DisplayMethod="unsigned integer"/>
              <Element Offset="244" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000F4" Description="[7] MemberGuid.B" DisplayMethod="unsigned integer"/>
              <Element Offset="248" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000F8" Description="[7] MemberGuid.C" DisplayMethod="unsigned integer"/>
              <Element Offset="252" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000FC" Description="[7] MemberGuid.D" DisplayMethod="unsigned integer"/>
              <Element Offset="256" Vartype="Pointer" Bytesize="8" OffsetHex="00000100" Description="[8] MemberParent" DisplayMethod="unsigned integer"/>
              <Element Offset="264" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000108" Description="[8] MemberName" DisplayMethod="unsigned integer"/>
              <Element Offset="272" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000110" Description="[8] MemberGuid.A" DisplayMethod="unsigned integer"/>
              <Element Offset="276" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000114" Description="[8] MemberGuid.B" DisplayMethod="unsigned integer"/>
              <Element Offset="280" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000118" Description="[8] MemberGuid.C" DisplayMethod="unsigned integer"/>
              <Element Offset="284" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000011C" Description="[8] MemberGuid.D" DisplayMethod="unsigned integer"/>
              <Element Offset="288" Vartype="Pointer" Bytesize="8" OffsetHex="00000120" Description="[9] MemberParent" DisplayMethod="unsigned integer"/>
              <Element Offset="296" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000128" Description="[9] MemberName" DisplayMethod="unsigned integer"/>
              <Element Offset="304" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000130" Description="[9] MemberGuid.A" DisplayMethod="unsigned integer"/>
              <Element Offset="308" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000134" Description="[9] MemberGuid.B" DisplayMethod="unsigned integer"/>
              <Element Offset="312" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000138" Description="[9] MemberGuid.C" DisplayMethod="unsigned integer"/>
              <Element Offset="316" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000013C" Description="[9] MemberGuid.D" DisplayMethod="unsigned integer"/>
              <Element Offset="320" Vartype="Pointer" Bytesize="8" OffsetHex="00000140" Description="[10] MemberParent" DisplayMethod="unsigned integer"/>
              <Element Offset="328" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000148" Description="[10] MemberName" DisplayMethod="unsigned integer"/>
              <Element Offset="336" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000150" Description="[10] MemberGuid.A" DisplayMethod="unsigned integer"/>
              <Element Offset="340" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000154" Description="[10] MemberGuid.B" DisplayMethod="unsigned integer"/>
              <Element Offset="344" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000158" Description="[10] MemberGuid.C" DisplayMethod="unsigned integer"/>
              <Element Offset="348" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000015C" Description="[10] MemberGuid.D" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="152" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000098" Description="UCSModifiedProperties_size" DisplayMethod="unsigned integer"/>
        <Element Offset="156" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000009C" Description="UCSModifiedProperties_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="160" Vartype="4 Bytes" Bytesize="4" RLECount="6" OffsetHex="000000A0" DisplayMethod="unsigned integer"/>
        <Element Offset="184" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000B8" Description="PhysicsVolume" DisplayMethod="unsigned integer"/>
        <Element Offset="188" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000BC" DisplayMethod="unsigned integer"/>
        <Element Offset="192" Vartype="Pointer" Bytesize="8" OffsetHex="000000C0" Description="AttachParent" DisplayMethod="unsigned integer"/>
        <Element Offset="200" Vartype="8 Bytes" Bytesize="8" OffsetHex="000000C8" Description="AttachSocketName" DisplayMethod="unsigned integer"/>
        <Element Offset="208" Vartype="Pointer" Bytesize="8" OffsetHex="000000D0" Description="AttachChildren" DisplayMethod="unsigned integer">
          <Structure Name="AttachChildren[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] AttachChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] AttachChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] AttachChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] AttachChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] AttachChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] AttachChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] AttachChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] AttachChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] AttachChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] AttachChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] AttachChildren" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="216" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000D8" Description="AttachChildren_size" DisplayMethod="unsigned integer"/>
        <Element Offset="220" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000DC" Description="AttachChildren_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="224" Vartype="Pointer" Bytesize="8" OffsetHex="000000E0" Description="ClientAttachedChildren" DisplayMethod="unsigned integer">
          <Structure Name="ClientAttachedChildren[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] ClientAttachedChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] ClientAttachedChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] ClientAttachedChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] ClientAttachedChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] ClientAttachedChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] ClientAttachedChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] ClientAttachedChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] ClientAttachedChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] ClientAttachedChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] ClientAttachedChildren" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] ClientAttachedChildren" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="232" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000E8" Description="ClientAttachedChildren_size" DisplayMethod="unsigned integer"/>
        <Element Offset="236" Vartype="4 Bytes" Bytesize="4" OffsetHex="000000EC" Description="ClientAttachedChildren_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="240" Vartype="4 Bytes" Bytesize="4" RLECount="11" OffsetHex="000000F0" DisplayMethod="unsigned integer"/>
        <Element Offset="284" Vartype="Float" Bytesize="4" OffsetHex="0000011C" Description="RelativeLocation.X" DisplayMethod="unsigned integer"/>
        <Element Offset="288" Vartype="Float" Bytesize="4" OffsetHex="00000120" Description="RelativeLocation.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="292" Vartype="Float" Bytesize="4" OffsetHex="00000124" Description="RelativeLocation.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="296" Vartype="Float" Bytesize="4" OffsetHex="00000128" Description="RelativeRotation.Pitch" DisplayMethod="unsigned integer"/>
        <Element Offset="300" Vartype="Float" Bytesize="4" OffsetHex="0000012C" Description="RelativeRotation.Yaw" DisplayMethod="unsigned integer"/>
        <Element Offset="304" Vartype="Float" Bytesize="4" OffsetHex="00000130" Description="RelativeRotation.Roll" DisplayMethod="unsigned integer"/>
        <Element Offset="308" Vartype="Float" Bytesize="4" OffsetHex="00000134" Description="RelativeScale3D.X" DisplayMethod="unsigned integer"/>
        <Element Offset="312" Vartype="Float" Bytesize="4" OffsetHex="00000138" Description="RelativeScale3D.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="316" Vartype="Float" Bytesize="4" OffsetHex="0000013C" Description="RelativeScale3D.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="320" Vartype="Float" Bytesize="4" OffsetHex="00000140" Description="ComponentVelocity.X" DisplayMethod="unsigned integer"/>
        <Element Offset="324" Vartype="Float" Bytesize="4" OffsetHex="00000144" Description="ComponentVelocity.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="328" Vartype="Float" Bytesize="4" OffsetHex="00000148" Description="ComponentVelocity.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="332" Vartype="Byte" Bytesize="1" OffsetHex="0000014C" Description="bComponentToWorldUpdated" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="332" Vartype="Byte" Bytesize="1" OffsetHex="0000014C" Description="bVisible" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="332" Vartype="Byte" Bytesize="1" OffsetHex="0000014C" Description="bAbsoluteScale" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="332" Vartype="Byte" Bytesize="1" OffsetHex="0000014C" Description="bShouldSnapLocationWhenAttached" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="332" Vartype="Byte" Bytesize="1" OffsetHex="0000014C" Description="bAbsoluteLocation" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="332" Vartype="Byte" Bytesize="1" OffsetHex="0000014C" Description="bAbsoluteRotation" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="332" Vartype="Byte" Bytesize="1" OffsetHex="0000014C" Description="bShouldBeAttached" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="333" Vartype="Byte" Bytesize="1" OffsetHex="0000014D" Description="bBoundsChangeTriggersStreamingDataRebuild" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="333" Vartype="Byte" Bytesize="1" OffsetHex="0000014D" Description="bHiddenInGame" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="333" Vartype="Byte" Bytesize="1" OffsetHex="0000014D" Description="bShouldUpdatePhysicsVolume" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="333" Vartype="Byte" Bytesize="1" OffsetHex="0000014D" Description="bShouldSnapRotationWhenAttached" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="333" Vartype="Byte" Bytesize="1" OffsetHex="0000014D" Description="bUseAttachParentBound" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="335" Vartype="Byte" Bytesize="1" OffsetHex="0000014F" Description="Mobility" DisplayMethod="unsigned integer"/>
        <Element Offset="336" Vartype="Byte" Bytesize="1" OffsetHex="00000150" Description="DetailMode" DisplayMethod="unsigned integer"/>
        <Element Offset="337" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000151" Description="PhysicsVolumeChangedDelegate" DisplayMethod="unsigned integer"/>
        <Element Offset="344" Vartype="4 Bytes" Bytesize="4" RLECount="30" OffsetHex="00000158" DisplayMethod="unsigned integer"/>
        <Element Offset="464" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="000001D0" DisplayMethod="signed integer"/>
        <Element Offset="472" Vartype="4 Bytes" Bytesize="4" RLECount="8" OffsetHex="000001D8" DisplayMethod="unsigned integer"/>
        <Element Offset="504" Vartype="Float" Bytesize="4" OffsetHex="000001F8" Description="MinDrawDistance" DisplayMethod="unsigned integer"/>
        <Element Offset="508" Vartype="Float" Bytesize="4" OffsetHex="000001FC" Description="LDMaxDrawDistance" DisplayMethod="unsigned integer"/>
        <Element Offset="512" Vartype="Float" Bytesize="4" OffsetHex="00000200" Description="CachedMaxDrawDistance" DisplayMethod="unsigned integer"/>
        <Element Offset="516" Vartype="Byte" Bytesize="1" OffsetHex="00000204" Description="DepthPriorityGroup" DisplayMethod="unsigned integer"/>
        <Element Offset="517" Vartype="Byte" Bytesize="1" OffsetHex="00000205" Description="ViewOwnerDepthPriorityGroup" DisplayMethod="unsigned integer"/>
        <Element Offset="518" Vartype="Byte" Bytesize="1" OffsetHex="00000206" Description="IndirectLightingCacheQuality" DisplayMethod="unsigned integer"/>
        <Element Offset="519" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000207" Description="LightmapType" DisplayMethod="unsigned integer"/>
        <Element Offset="520" Vartype="Byte" Bytesize="1" OffsetHex="00000208" Description="bBatchImpostersAsInstances" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="520" Vartype="Byte" Bytesize="1" OffsetHex="00000208" Description="bAlwaysCreatePhysicsState" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="520" Vartype="Byte" Bytesize="1" OffsetHex="00000208" Description="bNeverDistanceCull" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="520" Vartype="Byte" Bytesize="1" OffsetHex="00000208" Description="bUseMaxLODAsImposter" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="521" Vartype="Byte" Bytesize="1" OffsetHex="00000209" Description="bTraceComplexOnMove" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="521" Vartype="Byte" Bytesize="1" OffsetHex="00000209" Description="bMultiBodyOverlap" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="521" Vartype="Byte" Bytesize="1" OffsetHex="00000209" Description="bGenerateOverlapEvents" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="521" Vartype="Byte" Bytesize="1" OffsetHex="00000209" Description="bReturnMaterialOnMove" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="521" Vartype="Byte" Bytesize="1" OffsetHex="00000209" Description="bUseViewOwnerDepthPriorityGroup" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="521" Vartype="Byte" Bytesize="1" OffsetHex="00000209" Description="bVisibleInReflectionCaptures" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="521" Vartype="Byte" Bytesize="1" OffsetHex="00000209" Description="bHasMotionBlurVelocityMeshes" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="521" Vartype="Byte" Bytesize="1" OffsetHex="00000209" Description="bAllowCullDistanceVolume" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="522" Vartype="Byte" Bytesize="1" OffsetHex="0000020A" Description="bOnlyOwnerSee" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="522" Vartype="Byte" Bytesize="1" OffsetHex="0000020A" Description="bOwnerNoSee" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="522" Vartype="Byte" Bytesize="1" OffsetHex="0000020A" Description="bUseAsOccluder" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="522" Vartype="Byte" Bytesize="1" OffsetHex="0000020A" Description="bTreatAsBackgroundForOcclusion" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="522" Vartype="Byte" Bytesize="1" OffsetHex="0000020A" Description="bReceivesDecals" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="522" Vartype="Byte" Bytesize="1" OffsetHex="0000020A" Description="bVisibleInRayTracing" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="522" Vartype="Byte" Bytesize="1" OffsetHex="0000020A" Description="bRenderInMainPass" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="522" Vartype="Byte" Bytesize="1" OffsetHex="0000020A" Description="bRenderInDepthPass" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="523" Vartype="Byte" Bytesize="1" OffsetHex="0000020B" Description="bAffectDistanceFieldLighting" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="523" Vartype="Byte" Bytesize="1" OffsetHex="0000020B" Description="bCastDynamicShadow" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="523" Vartype="Byte" Bytesize="1" OffsetHex="0000020B" Description="CastShadow" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="523" Vartype="Byte" Bytesize="1" OffsetHex="0000020B" Description="bAffectDynamicIndirectLighting" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="523" Vartype="Byte" Bytesize="1" OffsetHex="0000020B" Description="bCastStaticShadow" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="523" Vartype="Byte" Bytesize="1" OffsetHex="0000020B" Description="bSelectable" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="523" Vartype="Byte" Bytesize="1" OffsetHex="0000020B" Description="bForceMipStreaming" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="523" Vartype="Byte" Bytesize="1" OffsetHex="0000020B" Description="bHasPerInstanceHitProxies" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="524" Vartype="Byte" Bytesize="1" OffsetHex="0000020C" Description="bCastFarShadow" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="524" Vartype="Byte" Bytesize="1" OffsetHex="0000020C" Description="bCastInsetShadow" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="524" Vartype="Byte" Bytesize="1" OffsetHex="0000020C" Description="bCastVolumetricTranslucentShadow" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="524" Vartype="Byte" Bytesize="1" OffsetHex="0000020C" Description="bSelfShadowOnly" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="524" Vartype="Byte" Bytesize="1" OffsetHex="0000020C" Description="bCastCinematicShadow" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="524" Vartype="Byte" Bytesize="1" OffsetHex="0000020C" Description="bLightAsIfStatic" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="524" Vartype="Byte" Bytesize="1" OffsetHex="0000020C" Description="bCastShadowAsTwoSided" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="524" Vartype="Byte" Bytesize="1" OffsetHex="0000020C" Description="bCastHiddenShadow" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="525" Vartype="Byte" Bytesize="1" OffsetHex="0000020D" Description="bReplicatePhysicsToAutonomousProxy" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="525" Vartype="Byte" Bytesize="1" OffsetHex="0000020D" Description="bLightAttachmentsAsGroup" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="525" Vartype="Byte" Bytesize="1" OffsetHex="0000020D" Description="bExcludeFromLightAttachmentGroup" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="525" Vartype="Byte" Bytesize="1" OffsetHex="0000020D" Description="bReceiveMobileCSMShadows" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="525" Vartype="Byte" Bytesize="1" OffsetHex="0000020D" Description="bIgnoreRadialForce" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="525" Vartype="Byte" Bytesize="1" OffsetHex="0000020D" Description="bApplyImpulseOnDamage" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="525" Vartype="Byte" Bytesize="1" OffsetHex="0000020D" Description="bSingleSampleShadowFromStationaryLights" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="525" Vartype="Byte" Bytesize="1" OffsetHex="0000020D" Description="bIgnoreRadialImpulse" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="526" Vartype="Byte" Bytesize="1" OffsetHex="0000020E" Description="bRenderCustomDepth" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="526" Vartype="Byte" Bytesize="1" OffsetHex="0000020E" Description="AlwaysLoadOnServer" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="526" Vartype="Byte" Bytesize="1" OffsetHex="0000020E" Description="bFillCollisionUnderneathForNavmesh" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="526" Vartype="Byte" Bytesize="1" OffsetHex="0000020E" Description="AlwaysLoadOnClient" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="526" Vartype="Byte" Bytesize="1" OffsetHex="0000020E" Description="bUseEditorCompositing" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="527" Vartype="Byte" Bytesize="1" OffsetHex="0000020F" Description="bHasCustomNavigableGeometry" DisplayMethod="unsigned integer"/>
        <Element Offset="529" Vartype="Byte" Bytesize="1" OffsetHex="00000211" Description="CanCharacterStepUpOn" DisplayMethod="unsigned integer"/>
        <Element Offset="530" Vartype="Byte" Bytesize="1" OffsetHex="00000212" Description="LightingChannels.bChannel0" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="530" Vartype="Byte" Bytesize="1" OffsetHex="00000212" Description="LightingChannels.bChannel1" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="530" Vartype="Byte" Bytesize="1" OffsetHex="00000212" Description="LightingChannels.bChannel2" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="531" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000213" Description="CustomDepthStencilWriteMask" DisplayMethod="unsigned integer"/>
        <Element Offset="532" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000214" Description="CustomDepthStencilValue" DisplayMethod="unsigned integer"/>
        <Element Offset="536" Vartype="Pointer" Bytesize="8" OffsetHex="00000218" Description="CustomPrimitiveData.Data" DisplayMethod="unsigned integer">
          <Structure Name="Data[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Float" Bytesize="4" OffsetHex="00000000" Description="[0] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="4" Vartype="Float" Bytesize="4" OffsetHex="00000004" Description="[1] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Float" Bytesize="4" OffsetHex="00000008" Description="[2] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="12" Vartype="Float" Bytesize="4" OffsetHex="0000000C" Description="[3] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Float" Bytesize="4" OffsetHex="00000010" Description="[4] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="20" Vartype="Float" Bytesize="4" OffsetHex="00000014" Description="[5] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Float" Bytesize="4" OffsetHex="00000018" Description="[6] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="28" Vartype="Float" Bytesize="4" OffsetHex="0000001C" Description="[7] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Float" Bytesize="4" OffsetHex="00000020" Description="[8] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="36" Vartype="Float" Bytesize="4" OffsetHex="00000024" Description="[9] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Float" Bytesize="4" OffsetHex="00000028" Description="[10] Data" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="544" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000220" Description="CustomPrimitiveData.Data_size" DisplayMethod="unsigned integer"/>
        <Element Offset="548" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000224" Description="CustomPrimitiveData.Data_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="552" Vartype="Pointer" Bytesize="8" OffsetHex="00000228" Description="CustomPrimitiveDataInternal.Data" DisplayMethod="unsigned integer">
          <Structure Name="Data[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Float" Bytesize="4" OffsetHex="00000000" Description="[0] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="4" Vartype="Float" Bytesize="4" OffsetHex="00000004" Description="[1] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Float" Bytesize="4" OffsetHex="00000008" Description="[2] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="12" Vartype="Float" Bytesize="4" OffsetHex="0000000C" Description="[3] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Float" Bytesize="4" OffsetHex="00000010" Description="[4] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="20" Vartype="Float" Bytesize="4" OffsetHex="00000014" Description="[5] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Float" Bytesize="4" OffsetHex="00000018" Description="[6] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="28" Vartype="Float" Bytesize="4" OffsetHex="0000001C" Description="[7] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Float" Bytesize="4" OffsetHex="00000020" Description="[8] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="36" Vartype="Float" Bytesize="4" OffsetHex="00000024" Description="[9] Data" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Float" Bytesize="4" OffsetHex="00000028" Description="[10] Data" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="560" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000230" Description="CustomPrimitiveDataInternal.Data_size" DisplayMethod="unsigned integer"/>
        <Element Offset="564" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000234" Description="CustomPrimitiveDataInternal.Data_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="568" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000238" DisplayMethod="unsigned integer"/>
        <Element Offset="576" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000240" Description="TranslucencySortPriority" DisplayMethod="unsigned integer"/>
        <Element Offset="580" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000244" Description="VisibilityId" DisplayMethod="unsigned integer"/>
        <Element Offset="584" Vartype="Pointer" Bytesize="8" OffsetHex="00000248" Description="RuntimeVirtualTextures" DisplayMethod="unsigned integer">
          <Structure Name="RuntimeVirtualTextures[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] RuntimeVirtualTextures" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] RuntimeVirtualTextures" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] RuntimeVirtualTextures" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] RuntimeVirtualTextures" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] RuntimeVirtualTextures" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] RuntimeVirtualTextures" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] RuntimeVirtualTextures" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] RuntimeVirtualTextures" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] RuntimeVirtualTextures" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] RuntimeVirtualTextures" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] RuntimeVirtualTextures" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="592" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000250" Description="RuntimeVirtualTextures_size" DisplayMethod="unsigned integer"/>
        <Element Offset="596" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000254" Description="RuntimeVirtualTextures_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="600" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000258" Description="VirtualTextureLodBias" DisplayMethod="unsigned integer"/>
        <Element Offset="601" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000259" Description="VirtualTextureCullMips" DisplayMethod="unsigned integer"/>
        <Element Offset="602" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000025A" Description="VirtualTextureMinCoverage" DisplayMethod="unsigned integer"/>
        <Element Offset="603" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000025B" Description="VirtualTextureRenderPassType" DisplayMethod="unsigned integer"/>
        <Element Offset="608" Vartype="Float" Bytesize="4" OffsetHex="00000260" Description="LpvBiasMultiplier" DisplayMethod="unsigned integer"/>
        <Element Offset="612" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000264" DisplayMethod="unsigned integer"/>
        <Element Offset="620" Vartype="Float" Bytesize="4" OffsetHex="0000026C" Description="BoundsScale" DisplayMethod="unsigned integer"/>
        <Element Offset="624" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="00000270" DisplayMethod="unsigned integer"/>
        <Element Offset="640" Vartype="Pointer" Bytesize="8" OffsetHex="00000280" Description="MoveIgnoreActors" DisplayMethod="unsigned integer">
          <Structure Name="MoveIgnoreActors[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] MoveIgnoreActors" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] MoveIgnoreActors" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] MoveIgnoreActors" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] MoveIgnoreActors" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] MoveIgnoreActors" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] MoveIgnoreActors" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] MoveIgnoreActors" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] MoveIgnoreActors" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] MoveIgnoreActors" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] MoveIgnoreActors" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] MoveIgnoreActors" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="648" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000288" Description="MoveIgnoreActors_size" DisplayMethod="unsigned integer"/>
        <Element Offset="652" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000028C" Description="MoveIgnoreActors_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="656" Vartype="Pointer" Bytesize="8" OffsetHex="00000290" Description="MoveIgnoreComponents" DisplayMethod="unsigned integer">
          <Structure Name="MoveIgnoreComponents[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="Pointer" Bytesize="8" OffsetHex="00000000" Description="[0] MoveIgnoreComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Pointer" Bytesize="8" OffsetHex="00000008" Description="[1] MoveIgnoreComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="16" Vartype="Pointer" Bytesize="8" OffsetHex="00000010" Description="[2] MoveIgnoreComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="Pointer" Bytesize="8" OffsetHex="00000018" Description="[3] MoveIgnoreComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Pointer" Bytesize="8" OffsetHex="00000020" Description="[4] MoveIgnoreComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="40" Vartype="Pointer" Bytesize="8" OffsetHex="00000028" Description="[5] MoveIgnoreComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="Pointer" Bytesize="8" OffsetHex="00000030" Description="[6] MoveIgnoreComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Pointer" Bytesize="8" OffsetHex="00000038" Description="[7] MoveIgnoreComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="64" Vartype="Pointer" Bytesize="8" OffsetHex="00000040" Description="[8] MoveIgnoreComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="Pointer" Bytesize="8" OffsetHex="00000048" Description="[9] MoveIgnoreComponents" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Pointer" Bytesize="8" OffsetHex="00000050" Description="[10] MoveIgnoreComponents" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="664" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000298" Description="MoveIgnoreComponents_size" DisplayMethod="unsigned integer"/>
        <Element Offset="668" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000029C" Description="MoveIgnoreComponents_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="672" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="000002A0" DisplayMethod="unsigned integer"/>
        <Element Offset="688" Vartype="4 Bytes" Bytesize="4" OffsetHex="000002B0" Description="BodyInstance" DisplayMethod="unsigned integer"/>
        <Element Offset="692" Vartype="4 Bytes" Bytesize="4" OffsetHex="000002B4" DisplayMethod="unsigned integer"/>
        <Element Offset="694" Vartype="Byte" Bytesize="1" OffsetHex="000002B6" Description="BodyInstance.ObjectType" DisplayMethod="unsigned integer"/>
        <Element Offset="696" Vartype="Byte" Bytesize="1" OffsetHex="000002B8" Description="BodyInstance.CollisionEnabled" DisplayMethod="unsigned integer"/>
        <Element Offset="698" Vartype="4 Bytes" Bytesize="4" OffsetHex="000002BA" Description="BodyInstance.SleepFamily" DisplayMethod="unsigned integer"/>
        <Element Offset="699" Vartype="Byte" Bytesize="1" OffsetHex="000002BB" Description="BodyInstance.DOFMode" DisplayMethod="unsigned integer"/>
        <Element Offset="700" Vartype="Byte" Bytesize="1" OffsetHex="000002BC" Description="BodyInstance.bUseCCD" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="700" Vartype="Byte" Bytesize="1" OffsetHex="000002BC" Description="BodyInstance.bIgnoreAnalyticCollisions" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="700" Vartype="Byte" Bytesize="1" OffsetHex="000002BC" Description="BodyInstance.bNotifyRigidBodyCollision" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="700" Vartype="Byte" Bytesize="1" OffsetHex="000002BC" Description="BodyInstance.bEnableGravity" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="700" Vartype="Byte" Bytesize="1" OffsetHex="000002BC" Description="BodyInstance.bAutoWeld" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="700" Vartype="Byte" Bytesize="1" OffsetHex="000002BC" Description="BodyInstance.bOverrideMass" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="700" Vartype="Byte" Bytesize="1" OffsetHex="000002BC" Description="BodyInstance.bSimulatePhysics" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="701" Vartype="Byte" Bytesize="1" OffsetHex="000002BD" Description="BodyInstance.bLockZTranslation" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="701" Vartype="Byte" Bytesize="1" OffsetHex="000002BD" Description="BodyInstance.bStartAwake" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="701" Vartype="Byte" Bytesize="1" OffsetHex="000002BD" Description="BodyInstance.bLockXTranslation" DisplayMethod="unsigned integer" ChildStructStart="32"/>
        <Element Offset="701" Vartype="Byte" Bytesize="1" OffsetHex="000002BD" Description="BodyInstance.bLockTranslation" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="701" Vartype="Byte" Bytesize="1" OffsetHex="000002BD" Description="BodyInstance.bLockRotation" DisplayMethod="unsigned integer" ChildStructStart="16"/>
        <Element Offset="701" Vartype="Byte" Bytesize="1" OffsetHex="000002BD" Description="BodyInstance.bLockYTranslation" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="701" Vartype="Byte" Bytesize="1" OffsetHex="000002BD" Description="BodyInstance.bGenerateWakeEvents" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="701" Vartype="Byte" Bytesize="1" OffsetHex="000002BD" Description="BodyInstance.bUpdateMassWhenScaleChanges" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="702" Vartype="Byte" Bytesize="1" OffsetHex="000002BE" Description="BodyInstance.bLockYRotation" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="702" Vartype="Byte" Bytesize="1" OffsetHex="000002BE" Description="BodyInstance.bOverrideMaxAngularVelocity" DisplayMethod="unsigned integer" ChildStructStart="8"/>
        <Element Offset="702" Vartype="Byte" Bytesize="1" OffsetHex="000002BE" Description="BodyInstance.bLockXRotation" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="702" Vartype="Byte" Bytesize="1" OffsetHex="000002BE" Description="BodyInstance.bOverrideMaxDepenetrationVelocity" DisplayMethod="unsigned integer" ChildStructStart="64"/>
        <Element Offset="702" Vartype="Byte" Bytesize="1" OffsetHex="000002BE" Description="BodyInstance.bLockZRotation" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="702" Vartype="Byte" Bytesize="1" OffsetHex="000002BE" Description="BodyInstance.bOverrideWalkableSlopeOnInstance" DisplayMethod="unsigned integer" ChildStructStart="128"/>
        <Element Offset="703" Vartype="Byte" Bytesize="1" OffsetHex="000002BF" Description="BodyInstance.bInterpolateWhenSubStepping" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="708" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000002C4" DisplayMethod="unsigned integer"/>
        <Element Offset="716" Vartype="8 Bytes" Bytesize="8" OffsetHex="000002CC" Description="BodyInstance.CollisionProfileName" DisplayMethod="unsigned integer"/>
        <Element Offset="724" Vartype="Byte" Bytesize="1" OffsetHex="000002D4" Description="BodyInstance.PositionSolverIterationCount" DisplayMethod="unsigned integer"/>
        <Element Offset="725" Vartype="Byte" Bytesize="1" OffsetHex="000002D5" Description="BodyInstance.VelocitySolverIterationCount" DisplayMethod="unsigned integer"/>
        <Element Offset="728" Vartype="Byte" Bytesize="1" OffsetHex="000002D8" Description="BodyInstance.CollisionResponses.ResponseToChannels.WorldStatic" DisplayMethod="unsigned integer"/>
        <Element Offset="729" Vartype="Byte" Bytesize="1" OffsetHex="000002D9" Description="BodyInstance.CollisionResponses.ResponseToChannels.WorldDynamic" DisplayMethod="unsigned integer"/>
        <Element Offset="730" Vartype="Byte" Bytesize="1" OffsetHex="000002DA" Description="BodyInstance.CollisionResponses.ResponseToChannels.Pawn" DisplayMethod="unsigned integer"/>
        <Element Offset="731" Vartype="Byte" Bytesize="1" OffsetHex="000002DB" Description="BodyInstance.CollisionResponses.ResponseToChannels.Visibility" DisplayMethod="unsigned integer"/>
        <Element Offset="732" Vartype="Byte" Bytesize="1" OffsetHex="000002DC" Description="BodyInstance.CollisionResponses.ResponseToChannels.Camera" DisplayMethod="unsigned integer"/>
        <Element Offset="733" Vartype="Byte" Bytesize="1" OffsetHex="000002DD" Description="BodyInstance.CollisionResponses.ResponseToChannels.PhysicsBody" DisplayMethod="unsigned integer"/>
        <Element Offset="734" Vartype="Byte" Bytesize="1" OffsetHex="000002DE" Description="BodyInstance.CollisionResponses.ResponseToChannels.Vehicle" DisplayMethod="unsigned integer"/>
        <Element Offset="735" Vartype="Byte" Bytesize="1" OffsetHex="000002DF" Description="BodyInstance.CollisionResponses.ResponseToChannels.Destructible" DisplayMethod="unsigned integer"/>
        <Element Offset="736" Vartype="Byte" Bytesize="1" OffsetHex="000002E0" Description="BodyInstance.CollisionResponses.ResponseToChannels.EngineTraceChannel1" DisplayMethod="unsigned integer"/>
        <Element Offset="737" Vartype="Byte" Bytesize="1" OffsetHex="000002E1" Description="BodyInstance.CollisionResponses.ResponseToChannels.EngineTraceChannel2" DisplayMethod="unsigned integer"/>
        <Element Offset="738" Vartype="Byte" Bytesize="1" OffsetHex="000002E2" Description="BodyInstance.CollisionResponses.ResponseToChannels.EngineTraceChannel3" DisplayMethod="unsigned integer"/>
        <Element Offset="739" Vartype="Byte" Bytesize="1" OffsetHex="000002E3" Description="BodyInstance.CollisionResponses.ResponseToChannels.EngineTraceChannel4" DisplayMethod="unsigned integer"/>
        <Element Offset="740" Vartype="Byte" Bytesize="1" OffsetHex="000002E4" Description="BodyInstance.CollisionResponses.ResponseToChannels.EngineTraceChannel5" DisplayMethod="unsigned integer"/>
        <Element Offset="741" Vartype="Byte" Bytesize="1" OffsetHex="000002E5" Description="BodyInstance.CollisionResponses.ResponseToChannels.EngineTraceChannel6" DisplayMethod="unsigned integer"/>
        <Element Offset="742" Vartype="Byte" Bytesize="1" OffsetHex="000002E6" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel1" DisplayMethod="unsigned integer"/>
        <Element Offset="743" Vartype="Byte" Bytesize="1" OffsetHex="000002E7" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel2" DisplayMethod="unsigned integer"/>
        <Element Offset="744" Vartype="Byte" Bytesize="1" OffsetHex="000002E8" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel3" DisplayMethod="unsigned integer"/>
        <Element Offset="745" Vartype="Byte" Bytesize="1" OffsetHex="000002E9" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel4" DisplayMethod="unsigned integer"/>
        <Element Offset="746" Vartype="Byte" Bytesize="1" OffsetHex="000002EA" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel5" DisplayMethod="unsigned integer"/>
        <Element Offset="747" Vartype="Byte" Bytesize="1" OffsetHex="000002EB" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel6" DisplayMethod="unsigned integer"/>
        <Element Offset="748" Vartype="Byte" Bytesize="1" OffsetHex="000002EC" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel7" DisplayMethod="unsigned integer"/>
        <Element Offset="749" Vartype="Byte" Bytesize="1" OffsetHex="000002ED" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel8" DisplayMethod="unsigned integer"/>
        <Element Offset="750" Vartype="Byte" Bytesize="1" OffsetHex="000002EE" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel9" DisplayMethod="unsigned integer"/>
        <Element Offset="751" Vartype="Byte" Bytesize="1" OffsetHex="000002EF" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel10" DisplayMethod="unsigned integer"/>
        <Element Offset="752" Vartype="Byte" Bytesize="1" OffsetHex="000002F0" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel11" DisplayMethod="unsigned integer"/>
        <Element Offset="753" Vartype="Byte" Bytesize="1" OffsetHex="000002F1" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel12" DisplayMethod="unsigned integer"/>
        <Element Offset="754" Vartype="Byte" Bytesize="1" OffsetHex="000002F2" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel13" DisplayMethod="unsigned integer"/>
        <Element Offset="755" Vartype="Byte" Bytesize="1" OffsetHex="000002F3" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel14" DisplayMethod="unsigned integer"/>
        <Element Offset="756" Vartype="Byte" Bytesize="1" OffsetHex="000002F4" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel15" DisplayMethod="unsigned integer"/>
        <Element Offset="757" Vartype="Byte" Bytesize="1" OffsetHex="000002F5" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel16" DisplayMethod="unsigned integer"/>
        <Element Offset="758" Vartype="Byte" Bytesize="1" OffsetHex="000002F6" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel17" DisplayMethod="unsigned integer"/>
        <Element Offset="759" Vartype="Byte" Bytesize="1" OffsetHex="000002F7" Description="BodyInstance.CollisionResponses.ResponseToChannels.GameTraceChannel18" DisplayMethod="unsigned integer"/>
        <Element Offset="760" Vartype="Pointer" Bytesize="8" OffsetHex="000002F8" Description="BodyInstance.CollisionResponses.ResponseArray" DisplayMethod="unsigned integer">
          <Structure Name="ResponseChannel[]" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
            <Elements>
              <Element Offset="0" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000000" Description="[0] Channel" DisplayMethod="unsigned integer"/>
              <Element Offset="8" Vartype="Byte" Bytesize="1" OffsetHex="00000008" Description="[0] Response" DisplayMethod="unsigned integer"/>
              <Element Offset="12" Vartype="8 Bytes" Bytesize="8" OffsetHex="0000000C" Description="[1] Channel" DisplayMethod="unsigned integer"/>
              <Element Offset="20" Vartype="Byte" Bytesize="1" OffsetHex="00000014" Description="[1] Response" DisplayMethod="unsigned integer"/>
              <Element Offset="24" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000018" Description="[2] Channel" DisplayMethod="unsigned integer"/>
              <Element Offset="32" Vartype="Byte" Bytesize="1" OffsetHex="00000020" Description="[2] Response" DisplayMethod="unsigned integer"/>
              <Element Offset="36" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000024" Description="[3] Channel" DisplayMethod="unsigned integer"/>
              <Element Offset="44" Vartype="Byte" Bytesize="1" OffsetHex="0000002C" Description="[3] Response" DisplayMethod="unsigned integer"/>
              <Element Offset="48" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000030" Description="[4] Channel" DisplayMethod="unsigned integer"/>
              <Element Offset="56" Vartype="Byte" Bytesize="1" OffsetHex="00000038" Description="[4] Response" DisplayMethod="unsigned integer"/>
              <Element Offset="60" Vartype="8 Bytes" Bytesize="8" OffsetHex="0000003C" Description="[5] Channel" DisplayMethod="unsigned integer"/>
              <Element Offset="68" Vartype="Byte" Bytesize="1" OffsetHex="00000044" Description="[5] Response" DisplayMethod="unsigned integer"/>
              <Element Offset="72" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000048" Description="[6] Channel" DisplayMethod="unsigned integer"/>
              <Element Offset="80" Vartype="Byte" Bytesize="1" OffsetHex="00000050" Description="[6] Response" DisplayMethod="unsigned integer"/>
              <Element Offset="84" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000054" Description="[7] Channel" DisplayMethod="unsigned integer"/>
              <Element Offset="92" Vartype="Byte" Bytesize="1" OffsetHex="0000005C" Description="[7] Response" DisplayMethod="unsigned integer"/>
              <Element Offset="96" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000060" Description="[8] Channel" DisplayMethod="unsigned integer"/>
              <Element Offset="104" Vartype="Byte" Bytesize="1" OffsetHex="00000068" Description="[8] Response" DisplayMethod="unsigned integer"/>
              <Element Offset="108" Vartype="8 Bytes" Bytesize="8" OffsetHex="0000006C" Description="[9] Channel" DisplayMethod="unsigned integer"/>
              <Element Offset="116" Vartype="Byte" Bytesize="1" OffsetHex="00000074" Description="[9] Response" DisplayMethod="unsigned integer"/>
              <Element Offset="120" Vartype="8 Bytes" Bytesize="8" OffsetHex="00000078" Description="[10] Channel" DisplayMethod="unsigned integer"/>
              <Element Offset="128" Vartype="Byte" Bytesize="1" OffsetHex="00000080" Description="[10] Response" DisplayMethod="unsigned integer"/>
            </Elements>
          </Structure>
        </Element>
        <Element Offset="768" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000300" Description="BodyInstance.CollisionResponses.ResponseArray_size" DisplayMethod="unsigned integer"/>
        <Element Offset="772" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000304" Description="BodyInstance.CollisionResponses.ResponseArray_sizes" DisplayMethod="unsigned integer"/>
        <Element Offset="776" Vartype="Float" Bytesize="4" OffsetHex="00000308" Description="BodyInstance.MaxDepenetrationVelocity" DisplayMethod="unsigned integer"/>
        <Element Offset="780" Vartype="Float" Bytesize="4" OffsetHex="0000030C" Description="BodyInstance.MassInKgOverride" DisplayMethod="unsigned integer"/>
        <Element Offset="784" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000310" DisplayMethod="unsigned integer"/>
        <Element Offset="792" Vartype="Float" Bytesize="4" OffsetHex="00000318" Description="BodyInstance.LinearDamping" DisplayMethod="unsigned integer"/>
        <Element Offset="796" Vartype="Float" Bytesize="4" OffsetHex="0000031C" Description="BodyInstance.AngularDamping" DisplayMethod="unsigned integer"/>
        <Element Offset="800" Vartype="Float" Bytesize="4" OffsetHex="00000320" Description="BodyInstance.CustomDOFPlaneNormal.X" DisplayMethod="unsigned integer"/>
        <Element Offset="804" Vartype="Float" Bytesize="4" OffsetHex="00000324" Description="BodyInstance.CustomDOFPlaneNormal.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="808" Vartype="Float" Bytesize="4" OffsetHex="00000328" Description="BodyInstance.CustomDOFPlaneNormal.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="812" Vartype="Float" Bytesize="4" OffsetHex="0000032C" Description="BodyInstance.COMNudge.X" DisplayMethod="unsigned integer"/>
        <Element Offset="816" Vartype="Float" Bytesize="4" OffsetHex="00000330" Description="BodyInstance.COMNudge.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="820" Vartype="Float" Bytesize="4" OffsetHex="00000334" Description="BodyInstance.COMNudge.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="824" Vartype="Float" Bytesize="4" OffsetHex="00000338" Description="BodyInstance.MassScale" DisplayMethod="unsigned integer"/>
        <Element Offset="828" Vartype="Float" Bytesize="4" OffsetHex="0000033C" Description="BodyInstance.InertiaTensorScale.X" DisplayMethod="unsigned integer"/>
        <Element Offset="832" Vartype="Float" Bytesize="4" OffsetHex="00000340" Description="BodyInstance.InertiaTensorScale.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="836" Vartype="Float" Bytesize="4" OffsetHex="00000344" Description="BodyInstance.InertiaTensorScale.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="840" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="00000348" DisplayMethod="unsigned integer"/>
        <Element Offset="856" Vartype="Byte" Bytesize="1" OffsetHex="00000358" Description="BodyInstance.WalkableSlopeOverride.WalkableSlopeBehavior" DisplayMethod="unsigned integer"/>
        <Element Offset="860" Vartype="Float" Bytesize="4" OffsetHex="0000035C" Description="BodyInstance.WalkableSlopeOverride.WalkableSlopeAngle" DisplayMethod="unsigned integer"/>
        <Element Offset="864" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000360" DisplayMethod="unsigned integer"/>
        <Element Offset="872" Vartype="Pointer" Bytesize="8" OffsetHex="00000368" Description="BodyInstance.PhysMaterialOverride" DisplayMethod="unsigned integer"/>
        <Element Offset="880" Vartype="Float" Bytesize="4" OffsetHex="00000370" Description="BodyInstance.MaxAngularVelocity" DisplayMethod="unsigned integer"/>
        <Element Offset="884" Vartype="Float" Bytesize="4" OffsetHex="00000374" Description="BodyInstance.CustomSleepThresholdMultiplier" DisplayMethod="unsigned integer"/>
        <Element Offset="888" Vartype="Float" Bytesize="4" OffsetHex="00000378" Description="BodyInstance.StabilizationThresholdMultiplier" DisplayMethod="unsigned integer"/>
        <Element Offset="892" Vartype="Float" Bytesize="4" OffsetHex="0000037C" Description="BodyInstance.PhysicsBlendWeight" DisplayMethod="unsigned integer"/>
        <Element Offset="896" Vartype="4 Bytes" Bytesize="4" RLECount="16" OffsetHex="00000380" DisplayMethod="unsigned integer"/>
        <Element Offset="960" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003C0" Description="OnComponentHit" DisplayMethod="unsigned integer"/>
        <Element Offset="961" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003C1" Description="OnComponentBeginOverlap" DisplayMethod="unsigned integer"/>
        <Element Offset="962" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003C2" Description="OnComponentEndOverlap" DisplayMethod="unsigned integer"/>
        <Element Offset="963" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003C3" Description="OnComponentWake" DisplayMethod="unsigned integer"/>
        <Element Offset="964" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003C4" Description="OnComponentSleep" DisplayMethod="unsigned integer"/>
        <Element Offset="966" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003C6" Description="OnBeginCursorOver" DisplayMethod="unsigned integer"/>
        <Element Offset="967" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003C7" Description="OnEndCursorOver" DisplayMethod="unsigned integer"/>
        <Element Offset="968" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003C8" Description="OnClicked" DisplayMethod="unsigned integer"/>
        <Element Offset="969" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003C9" Description="OnReleased" DisplayMethod="unsigned integer"/>
        <Element Offset="970" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003CA" Description="OnInputTouchBegin" DisplayMethod="unsigned integer"/>
        <Element Offset="971" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003CB" Description="OnInputTouchEnd" DisplayMethod="unsigned integer"/>
        <Element Offset="972" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003CC" Description="OnInputTouchEnter" DisplayMethod="unsigned integer"/>
        <Element Offset="973" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003CD" Description="OnInputTouchLeave" DisplayMethod="unsigned integer"/>
        <Element Offset="980" Vartype="4 Bytes" Bytesize="4" RLECount="5" OffsetHex="000003D4" DisplayMethod="unsigned integer"/>
        <Element Offset="1000" Vartype="Pointer" Bytesize="8" OffsetHex="000003E8" Description="LODParentPrimitive" DisplayMethod="unsigned integer"/>
        <Element Offset="1008" Vartype="Pointer" Bytesize="8" OffsetHex="000003F0" Description="ShapeBodySetup" DisplayMethod="unsigned integer"/>
        <Element Offset="1016" Vartype="Pointer" Bytesize="8" OffsetHex="000003F8" Description="AreaClass" DisplayMethod="unsigned integer"/>
        <Element Offset="1024" Vartype="Byte" Bytesize="1" OffsetHex="00000400" Description="ShapeColor.B" DisplayMethod="unsigned integer"/>
        <Element Offset="1025" Vartype="Byte" Bytesize="1" OffsetHex="00000401" Description="ShapeColor.G" DisplayMethod="unsigned integer"/>
        <Element Offset="1026" Vartype="Byte" Bytesize="1" OffsetHex="00000402" Description="ShapeColor.R" DisplayMethod="unsigned integer"/>
        <Element Offset="1027" Vartype="Byte" Bytesize="1" OffsetHex="00000403" Description="ShapeColor.A" DisplayMethod="unsigned integer"/>
        <Element Offset="1028" Vartype="Byte" Bytesize="1" OffsetHex="00000404" Description="bDrawOnlyIfSelected" DisplayMethod="unsigned integer" ChildStructStart="1"/>
        <Element Offset="1028" Vartype="Byte" Bytesize="1" OffsetHex="00000404" Description="bShouldCollideWhenPlacing" DisplayMethod="unsigned integer" ChildStructStart="2"/>
        <Element Offset="1028" Vartype="Byte" Bytesize="1" OffsetHex="00000404" Description="bDynamicObstacle" DisplayMethod="unsigned integer" ChildStructStart="4"/>
        <Element Offset="1032" Vartype="Float" Bytesize="4" OffsetHex="00000408" Description="BoxExtent.X" DisplayMethod="unsigned integer"/>
        <Element Offset="1036" Vartype="Float" Bytesize="4" OffsetHex="0000040C" Description="BoxExtent.Y" DisplayMethod="unsigned integer"/>
        <Element Offset="1040" Vartype="Float" Bytesize="4" OffsetHex="00000410" Description="BoxExtent.Z" DisplayMethod="unsigned integer"/>
        <Element Offset="1044" Vartype="Float" Bytesize="4" OffsetHex="00000414" Description="LineThickness" DisplayMethod="unsigned integer"/>
      </Elements>
    </Structure>
    <Structure Name="unnamed structure" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
      <Elements>
        <Element Offset="0" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000000" DisplayMethod="hexadecimal"/>
        <Element Offset="4" Vartype="4 Bytes" Bytesize="4" RLECount="44" OffsetHex="00000004" DisplayMethod="unsigned integer"/>
        <Element Offset="180" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000000B4" DisplayMethod="hexadecimal"/>
        <Element Offset="192" Vartype="4 Bytes" Bytesize="4" RLECount="6" OffsetHex="000000C0" DisplayMethod="unsigned integer"/>
        <Element Offset="216" Vartype="Pointer" Bytesize="8" OffsetHex="000000D8" DisplayMethod="unsigned integer"/>
        <Element Offset="224" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000000E0" DisplayMethod="unsigned integer"/>
        <Element Offset="228" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000000E4" DisplayMethod="unsigned integer"/>
        <Element Offset="240" Vartype="Pointer" Bytesize="8" OffsetHex="000000F0" DisplayMethod="unsigned integer"/>
        <Element Offset="248" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000000F8" DisplayMethod="unsigned integer"/>
        <Element Offset="252" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000000FC" DisplayMethod="unsigned integer"/>
        <Element Offset="264" Vartype="Pointer" Bytesize="8" OffsetHex="00000108" DisplayMethod="unsigned integer"/>
        <Element Offset="272" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000110" DisplayMethod="unsigned integer"/>
        <Element Offset="276" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000114" DisplayMethod="unsigned integer"/>
        <Element Offset="288" Vartype="Pointer" Bytesize="8" OffsetHex="00000120" DisplayMethod="unsigned integer"/>
        <Element Offset="296" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000128" DisplayMethod="unsigned integer"/>
        <Element Offset="300" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="0000012C" DisplayMethod="unsigned integer"/>
        <Element Offset="316" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="0000013C" DisplayMethod="hexadecimal"/>
        <Element Offset="328" Vartype="4 Bytes" Bytesize="4" RLECount="50" OffsetHex="00000148" DisplayMethod="unsigned integer"/>
        <Element Offset="528" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000210" DisplayMethod="hexadecimal"/>
        <Element Offset="540" Vartype="4 Bytes" Bytesize="4" RLECount="11" OffsetHex="0000021C" DisplayMethod="unsigned integer"/>
        <Element Offset="584" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000248" DisplayMethod="unsigned integer"/>
        <Element Offset="600" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000258" DisplayMethod="unsigned integer"/>
        <Element Offset="608" Vartype="Byte" Bytesize="1" RLECount="2" OffsetHex="00000260" DisplayMethod="unsigned integer"/>
        <Element Offset="610" Vartype="2 Bytes" Bytesize="2" OffsetHex="00000262" DisplayMethod="unsigned integer"/>
        <Element Offset="612" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000264" DisplayMethod="unsigned integer"/>
        <Element Offset="616" Vartype="Byte" Bytesize="1" RLECount="2" OffsetHex="00000268" DisplayMethod="unsigned integer"/>
        <Element Offset="618" Vartype="2 Bytes" Bytesize="2" OffsetHex="0000026A" DisplayMethod="unsigned integer"/>
        <Element Offset="620" Vartype="4 Bytes" Bytesize="4" RLECount="9" OffsetHex="0000026C" DisplayMethod="unsigned integer"/>
        <Element Offset="656" Vartype="Pointer" Bytesize="8" OffsetHex="00000290" DisplayMethod="unsigned integer"/>
        <Element Offset="664" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000298" DisplayMethod="unsigned integer"/>
        <Element Offset="668" Vartype="4 Bytes" Bytesize="4" RLECount="13" OffsetHex="0000029C" DisplayMethod="unsigned integer"/>
        <Element Offset="720" Vartype="Pointer" Bytesize="8" OffsetHex="000002D0" DisplayMethod="unsigned integer"/>
        <Element Offset="728" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000002D8" DisplayMethod="unsigned integer"/>
        <Element Offset="732" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000002DC" DisplayMethod="unsigned integer"/>
        <Element Offset="744" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000002E8" DisplayMethod="unsigned integer"/>
        <Element Offset="760" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000002F8" DisplayMethod="unsigned integer"/>
        <Element Offset="768" Vartype="Pointer" Bytesize="8" OffsetHex="00000300" DisplayMethod="unsigned integer"/>
        <Element Offset="776" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000308" DisplayMethod="unsigned integer"/>
        <Element Offset="784" Vartype="Pointer" Bytesize="8" OffsetHex="00000310" DisplayMethod="unsigned integer"/>
        <Element Offset="792" Vartype="4 Bytes" Bytesize="4" RLECount="12" OffsetHex="00000318" DisplayMethod="unsigned integer"/>
        <Element Offset="840" Vartype="Pointer" Bytesize="8" OffsetHex="00000348" DisplayMethod="unsigned integer"/>
        <Element Offset="848" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000350" DisplayMethod="unsigned integer"/>
        <Element Offset="852" Vartype="4 Bytes" Bytesize="4" RLECount="11" OffsetHex="00000354" DisplayMethod="unsigned integer"/>
        <Element Offset="896" Vartype="Pointer" Bytesize="8" OffsetHex="00000380" DisplayMethod="unsigned integer"/>
        <Element Offset="904" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000388" DisplayMethod="unsigned integer"/>
        <Element Offset="908" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="0000038C" DisplayMethod="unsigned integer"/>
        <Element Offset="920" Vartype="Pointer" Bytesize="8" OffsetHex="00000398" DisplayMethod="unsigned integer"/>
        <Element Offset="928" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000003A0" DisplayMethod="unsigned integer"/>
        <Element Offset="932" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000003A4" DisplayMethod="unsigned integer"/>
        <Element Offset="944" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000003B0" DisplayMethod="unsigned integer"/>
        <Element Offset="960" Vartype="4 Bytes" Bytesize="4" RLECount="5" OffsetHex="000003C0" DisplayMethod="unsigned integer"/>
        <Element Offset="980" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000003D4" DisplayMethod="hexadecimal"/>
        <Element Offset="992" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000003E0" DisplayMethod="unsigned integer"/>
        <Element Offset="1000" Vartype="4 Bytes" Bytesize="4" OffsetHex="000003E8" DisplayMethod="hexadecimal"/>
        <Element Offset="1004" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="000003EC" DisplayMethod="unsigned integer"/>
        <Element Offset="1032" Vartype="Pointer" Bytesize="8" OffsetHex="00000408" DisplayMethod="unsigned integer"/>
        <Element Offset="1040" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000410" DisplayMethod="unsigned integer"/>
        <Element Offset="1044" Vartype="4 Bytes" Bytesize="4" RLECount="5" OffsetHex="00000414" DisplayMethod="unsigned integer"/>
        <Element Offset="1064" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000428" DisplayMethod="unsigned integer"/>
        <Element Offset="1068" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000042C" DisplayMethod="hexadecimal"/>
        <Element Offset="1072" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000430" DisplayMethod="unsigned integer"/>
        <Element Offset="1080" Vartype="Pointer" Bytesize="8" OffsetHex="00000438" DisplayMethod="unsigned integer"/>
        <Element Offset="1088" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000440" DisplayMethod="unsigned integer"/>
        <Element Offset="1092" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="00000444" DisplayMethod="unsigned integer"/>
        <Element Offset="1120" Vartype="Pointer" Bytesize="8" OffsetHex="00000460" DisplayMethod="unsigned integer"/>
        <Element Offset="1128" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000468" DisplayMethod="unsigned integer"/>
        <Element Offset="1132" Vartype="4 Bytes" Bytesize="4" RLECount="17" OffsetHex="0000046C" DisplayMethod="unsigned integer"/>
        <Element Offset="1200" Vartype="Pointer" Bytesize="8" OffsetHex="000004B0" DisplayMethod="unsigned integer"/>
        <Element Offset="1208" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000004B8" DisplayMethod="unsigned integer"/>
        <Element Offset="1212" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="000004BC" DisplayMethod="unsigned integer"/>
        <Element Offset="1240" Vartype="Pointer" Bytesize="8" OffsetHex="000004D8" DisplayMethod="unsigned integer"/>
        <Element Offset="1248" Vartype="4 Bytes" Bytesize="4" RLECount="14" OffsetHex="000004E0" DisplayMethod="unsigned integer"/>
        <Element Offset="1304" Vartype="Pointer" Bytesize="8" OffsetHex="00000518" DisplayMethod="unsigned integer"/>
        <Element Offset="1312" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000520" DisplayMethod="unsigned integer"/>
        <Element Offset="1316" Vartype="4 Bytes" Bytesize="4" RLECount="13" OffsetHex="00000524" DisplayMethod="unsigned integer"/>
        <Element Offset="1368" Vartype="Pointer" Bytesize="8" OffsetHex="00000558" DisplayMethod="unsigned integer"/>
        <Element Offset="1376" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000560" DisplayMethod="unsigned integer"/>
        <Element Offset="1380" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="00000564" DisplayMethod="unsigned integer"/>
        <Element Offset="1408" Vartype="Pointer" Bytesize="8" OffsetHex="00000580" DisplayMethod="unsigned integer"/>
        <Element Offset="1416" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000588" DisplayMethod="unsigned integer"/>
        <Element Offset="1420" Vartype="4 Bytes" Bytesize="4" RLECount="13" OffsetHex="0000058C" DisplayMethod="unsigned integer"/>
        <Element Offset="1472" Vartype="Pointer" Bytesize="8" OffsetHex="000005C0" DisplayMethod="unsigned integer"/>
        <Element Offset="1480" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000005C8" DisplayMethod="unsigned integer"/>
        <Element Offset="1484" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="000005CC" DisplayMethod="unsigned integer"/>
        <Element Offset="1512" Vartype="Pointer" Bytesize="8" OffsetHex="000005E8" DisplayMethod="unsigned integer"/>
        <Element Offset="1520" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000005F0" DisplayMethod="unsigned integer"/>
        <Element Offset="1524" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="000005F4" DisplayMethod="unsigned integer"/>
        <Element Offset="1552" Vartype="Pointer" Bytesize="8" OffsetHex="00000610" DisplayMethod="unsigned integer"/>
        <Element Offset="1560" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000618" DisplayMethod="unsigned integer"/>
        <Element Offset="1564" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="0000061C" DisplayMethod="unsigned integer"/>
        <Element Offset="1576" Vartype="Pointer" Bytesize="8" OffsetHex="00000628" DisplayMethod="unsigned integer"/>
        <Element Offset="1584" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000630" DisplayMethod="unsigned integer"/>
        <Element Offset="1588" Vartype="4 Bytes" Bytesize="4" RLECount="11" OffsetHex="00000634" DisplayMethod="unsigned integer"/>
        <Element Offset="1632" Vartype="Pointer" Bytesize="8" OffsetHex="00000660" DisplayMethod="unsigned integer"/>
        <Element Offset="1640" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000668" DisplayMethod="unsigned integer"/>
        <Element Offset="1644" Vartype="4 Bytes" Bytesize="4" RLECount="13" OffsetHex="0000066C" DisplayMethod="unsigned integer"/>
        <Element Offset="1696" Vartype="Pointer" Bytesize="8" OffsetHex="000006A0" DisplayMethod="unsigned integer"/>
        <Element Offset="1704" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000006A8" DisplayMethod="unsigned integer"/>
        <Element Offset="1708" Vartype="4 Bytes" Bytesize="4" RLECount="13" OffsetHex="000006AC" DisplayMethod="unsigned integer"/>
        <Element Offset="1760" Vartype="Pointer" Bytesize="8" OffsetHex="000006E0" DisplayMethod="unsigned integer"/>
        <Element Offset="1768" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000006E8" DisplayMethod="unsigned integer"/>
        <Element Offset="1772" Vartype="4 Bytes" Bytesize="4" RLECount="71" OffsetHex="000006EC" DisplayMethod="unsigned integer"/>
        <Element Offset="2056" Vartype="Pointer" Bytesize="8" OffsetHex="00000808" DisplayMethod="unsigned integer"/>
        <Element Offset="2064" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000810" DisplayMethod="unsigned integer"/>
        <Element Offset="2068" Vartype="4 Bytes" Bytesize="4" RLECount="19" OffsetHex="00000814" DisplayMethod="unsigned integer"/>
        <Element Offset="2144" Vartype="Pointer" Bytesize="8" OffsetHex="00000860" DisplayMethod="unsigned integer"/>
        <Element Offset="2152" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000868" DisplayMethod="unsigned integer"/>
        <Element Offset="2156" Vartype="4 Bytes" Bytesize="4" RLECount="15" OffsetHex="0000086C" DisplayMethod="unsigned integer"/>
        <Element Offset="2216" Vartype="Pointer" Bytesize="8" OffsetHex="000008A8" DisplayMethod="unsigned integer"/>
        <Element Offset="2224" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000008B0" DisplayMethod="unsigned integer"/>
        <Element Offset="2228" Vartype="4 Bytes" Bytesize="4" RLECount="33" OffsetHex="000008B4" DisplayMethod="unsigned integer"/>
        <Element Offset="2360" Vartype="Pointer" Bytesize="8" OffsetHex="00000938" DisplayMethod="unsigned integer"/>
        <Element Offset="2368" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000940" DisplayMethod="unsigned integer"/>
        <Element Offset="2372" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000944" DisplayMethod="unsigned integer"/>
        <Element Offset="2384" Vartype="Pointer" Bytesize="8" OffsetHex="00000950" DisplayMethod="unsigned integer"/>
        <Element Offset="2392" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000958" DisplayMethod="unsigned integer"/>
        <Element Offset="2396" Vartype="4 Bytes" Bytesize="4" RLECount="31" OffsetHex="0000095C" DisplayMethod="unsigned integer"/>
        <Element Offset="2520" Vartype="Pointer" Bytesize="8" OffsetHex="000009D8" DisplayMethod="unsigned integer"/>
        <Element Offset="2528" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000009E0" DisplayMethod="unsigned integer"/>
        <Element Offset="2532" Vartype="4 Bytes" Bytesize="4" RLECount="25" OffsetHex="000009E4" DisplayMethod="unsigned integer"/>
        <Element Offset="2632" Vartype="Pointer" Bytesize="8" OffsetHex="00000A48" DisplayMethod="unsigned integer"/>
        <Element Offset="2640" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000A50" DisplayMethod="unsigned integer"/>
        <Element Offset="2644" Vartype="4 Bytes" Bytesize="4" RLECount="5" OffsetHex="00000A54" DisplayMethod="unsigned integer"/>
        <Element Offset="2664" Vartype="Pointer" Bytesize="8" OffsetHex="00000A68" DisplayMethod="unsigned integer"/>
        <Element Offset="2672" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000A70" DisplayMethod="unsigned integer"/>
        <Element Offset="2676" Vartype="4 Bytes" Bytesize="4" RLECount="5" OffsetHex="00000A74" DisplayMethod="unsigned integer"/>
        <Element Offset="2696" Vartype="Pointer" Bytesize="8" OffsetHex="00000A88" DisplayMethod="unsigned integer"/>
        <Element Offset="2704" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000A90" DisplayMethod="unsigned integer"/>
        <Element Offset="2708" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000A94" DisplayMethod="unsigned integer"/>
        <Element Offset="2720" Vartype="Pointer" Bytesize="8" OffsetHex="00000AA0" DisplayMethod="unsigned integer"/>
        <Element Offset="2728" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000AA8" DisplayMethod="unsigned integer"/>
        <Element Offset="2732" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000AAC" DisplayMethod="unsigned integer"/>
        <Element Offset="2744" Vartype="Pointer" Bytesize="8" OffsetHex="00000AB8" DisplayMethod="unsigned integer"/>
        <Element Offset="2752" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000AC0" DisplayMethod="unsigned integer"/>
        <Element Offset="2756" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000AC4" DisplayMethod="unsigned integer"/>
        <Element Offset="2768" Vartype="Pointer" Bytesize="8" OffsetHex="00000AD0" DisplayMethod="unsigned integer"/>
        <Element Offset="2776" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000AD8" DisplayMethod="unsigned integer"/>
        <Element Offset="2780" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000ADC" DisplayMethod="unsigned integer"/>
        <Element Offset="2792" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000AE8" DisplayMethod="unsigned integer"/>
        <Element Offset="2808" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000AF8" DisplayMethod="unsigned integer"/>
        <Element Offset="2812" Vartype="4 Bytes" Bytesize="4" RLECount="9" OffsetHex="00000AFC" DisplayMethod="unsigned integer"/>
        <Element Offset="2848" Vartype="Pointer" Bytesize="8" OffsetHex="00000B20" DisplayMethod="unsigned integer"/>
        <Element Offset="2856" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000B28" DisplayMethod="unsigned integer"/>
        <Element Offset="2860" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000B2C" DisplayMethod="unsigned integer"/>
        <Element Offset="2872" Vartype="Pointer" Bytesize="8" OffsetHex="00000B38" DisplayMethod="unsigned integer"/>
        <Element Offset="2880" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000B40" DisplayMethod="unsigned integer"/>
        <Element Offset="2884" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="00000B44" DisplayMethod="unsigned integer"/>
        <Element Offset="2912" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000B60" DisplayMethod="hexadecimal"/>
        <Element Offset="2924" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="00000B6C" DisplayMethod="unsigned integer"/>
        <Element Offset="2952" Vartype="Pointer" Bytesize="8" OffsetHex="00000B88" DisplayMethod="unsigned integer"/>
        <Element Offset="2960" Vartype="4 Bytes" Bytesize="4" RLECount="6" OffsetHex="00000B90" DisplayMethod="unsigned integer"/>
        <Element Offset="2984" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000BA8" DisplayMethod="unsigned integer"/>
        <Element Offset="3000" Vartype="4 Bytes" Bytesize="4" RLECount="18" OffsetHex="00000BB8" DisplayMethod="unsigned integer"/>
        <Element Offset="3072" Vartype="Pointer" Bytesize="8" OffsetHex="00000C00" DisplayMethod="unsigned integer"/>
        <Element Offset="3080" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000C08" DisplayMethod="unsigned integer"/>
        <Element Offset="3084" Vartype="4 Bytes" Bytesize="4" RLECount="13" OffsetHex="00000C0C" DisplayMethod="unsigned integer"/>
        <Element Offset="3136" Vartype="Pointer" Bytesize="8" OffsetHex="00000C40" DisplayMethod="unsigned integer"/>
        <Element Offset="3144" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000C48" DisplayMethod="unsigned integer"/>
        <Element Offset="3148" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="00000C4C" DisplayMethod="unsigned integer"/>
        <Element Offset="3176" Vartype="Pointer" Bytesize="8" OffsetHex="00000C68" DisplayMethod="unsigned integer"/>
        <Element Offset="3184" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000C70" DisplayMethod="unsigned integer"/>
        <Element Offset="3188" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000C74" DisplayMethod="unsigned integer"/>
        <Element Offset="3200" Vartype="Pointer" Bytesize="8" OffsetHex="00000C80" DisplayMethod="unsigned integer"/>
        <Element Offset="3208" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000C88" DisplayMethod="unsigned integer"/>
        <Element Offset="3212" Vartype="4 Bytes" Bytesize="4" RLECount="14" OffsetHex="00000C8C" DisplayMethod="unsigned integer"/>
        <Element Offset="3268" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000CC4" DisplayMethod="hexadecimal"/>
        <Element Offset="3280" Vartype="4 Bytes" Bytesize="4" RLECount="12" OffsetHex="00000CD0" DisplayMethod="unsigned integer"/>
        <Element Offset="3328" Vartype="Pointer" Bytesize="8" OffsetHex="00000D00" DisplayMethod="unsigned integer"/>
        <Element Offset="3336" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000D08" DisplayMethod="unsigned integer"/>
        <Element Offset="3340" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000D0C" DisplayMethod="unsigned integer"/>
        <Element Offset="3352" Vartype="Pointer" Bytesize="8" OffsetHex="00000D18" DisplayMethod="unsigned integer"/>
        <Element Offset="3360" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000D20" DisplayMethod="unsigned integer"/>
        <Element Offset="3364" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000D24" DisplayMethod="unsigned integer"/>
        <Element Offset="3376" Vartype="Pointer" Bytesize="8" OffsetHex="00000D30" DisplayMethod="unsigned integer"/>
        <Element Offset="3384" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000D38" DisplayMethod="unsigned integer"/>
        <Element Offset="3388" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000D3C" DisplayMethod="unsigned integer"/>
        <Element Offset="3400" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000D48" DisplayMethod="unsigned integer"/>
        <Element Offset="3412" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000D54" DisplayMethod="unsigned integer"/>
        <Element Offset="3424" Vartype="Double" Bytesize="8" OffsetHex="00000D60" DisplayMethod="unsigned integer"/>
        <Element Offset="3432" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D68" DisplayMethod="unsigned integer"/>
        <Element Offset="3436" Vartype="Double" Bytesize="8" OffsetHex="00000D6C" DisplayMethod="unsigned integer"/>
        <Element Offset="3444" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000D74" DisplayMethod="unsigned integer"/>
        <Element Offset="3456" Vartype="Float" Bytesize="4" OffsetHex="00000D80" DisplayMethod="unsigned integer"/>
        <Element Offset="3460" Vartype="4 Bytes" Bytesize="4" RLECount="5" OffsetHex="00000D84" DisplayMethod="unsigned integer"/>
        <Element Offset="3480" Vartype="Pointer" Bytesize="8" OffsetHex="00000D98" DisplayMethod="unsigned integer"/>
        <Element Offset="3488" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000DA0" DisplayMethod="unsigned integer"/>
        <Element Offset="3492" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000DA4" DisplayMethod="unsigned integer"/>
        <Element Offset="3504" Vartype="Pointer" Bytesize="8" OffsetHex="00000DB0" DisplayMethod="unsigned integer"/>
        <Element Offset="3512" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000DB8" DisplayMethod="unsigned integer"/>
        <Element Offset="3516" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="00000DBC" DisplayMethod="unsigned integer"/>
        <Element Offset="3544" Vartype="Pointer" Bytesize="8" OffsetHex="00000DD8" DisplayMethod="unsigned integer"/>
        <Element Offset="3552" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000DE0" DisplayMethod="unsigned integer"/>
        <Element Offset="3556" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="00000DE4" DisplayMethod="unsigned integer"/>
        <Element Offset="3584" Vartype="Pointer" Bytesize="8" OffsetHex="00000E00" DisplayMethod="unsigned integer"/>
        <Element Offset="3592" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000E08" DisplayMethod="unsigned integer"/>
        <Element Offset="3596" Vartype="4 Bytes" Bytesize="4" RLECount="20" OffsetHex="00000E0C" DisplayMethod="unsigned integer"/>
        <Element Offset="3676" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000E5C" DisplayMethod="hexadecimal"/>
        <Element Offset="3688" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000E68" DisplayMethod="unsigned integer"/>
        <Element Offset="3696" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000E70" DisplayMethod="unsigned integer"/>
        <Element Offset="3712" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000E80" DisplayMethod="unsigned integer"/>
        <Element Offset="3716" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000E84" DisplayMethod="unsigned integer"/>
        <Element Offset="3728" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000E90" DisplayMethod="unsigned integer"/>
        <Element Offset="3732" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000E94" DisplayMethod="hexadecimal"/>
        <Element Offset="3736" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000E98" DisplayMethod="unsigned integer"/>
        <Element Offset="3744" Vartype="Pointer" Bytesize="8" OffsetHex="00000EA0" DisplayMethod="unsigned integer"/>
        <Element Offset="3752" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000EA8" DisplayMethod="unsigned integer"/>
        <Element Offset="3756" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="00000EAC" DisplayMethod="unsigned integer"/>
        <Element Offset="3784" Vartype="Pointer" Bytesize="8" OffsetHex="00000EC8" DisplayMethod="unsigned integer"/>
        <Element Offset="3792" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000ED0" DisplayMethod="unsigned integer"/>
        <Element Offset="3796" Vartype="4 Bytes" Bytesize="4" RLECount="5" OffsetHex="00000ED4" DisplayMethod="unsigned integer"/>
        <Element Offset="3816" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000EE8" DisplayMethod="unsigned integer"/>
        <Element Offset="3832" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000EF8" DisplayMethod="unsigned integer"/>
        <Element Offset="3836" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000EFC" DisplayMethod="unsigned integer"/>
        <Element Offset="3848" Vartype="Pointer" Bytesize="8" OffsetHex="00000F08" DisplayMethod="unsigned integer"/>
        <Element Offset="3856" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F10" DisplayMethod="unsigned integer"/>
        <Element Offset="3864" Vartype="Pointer" Bytesize="8" OffsetHex="00000F18" DisplayMethod="unsigned integer"/>
        <Element Offset="3872" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000F20" DisplayMethod="unsigned integer"/>
        <Element Offset="3876" Vartype="4 Bytes" Bytesize="4" RLECount="5" OffsetHex="00000F24" DisplayMethod="unsigned integer"/>
        <Element Offset="3896" Vartype="Pointer" Bytesize="8" OffsetHex="00000F38" DisplayMethod="unsigned integer"/>
        <Element Offset="3904" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000F40" DisplayMethod="unsigned integer"/>
        <Element Offset="3908" Vartype="4 Bytes" Bytesize="4" RLECount="5" OffsetHex="00000F44" DisplayMethod="unsigned integer"/>
        <Element Offset="3928" Vartype="Pointer" Bytesize="8" RLECount="3" OffsetHex="00000F58" DisplayMethod="unsigned integer"/>
        <Element Offset="3952" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F70" DisplayMethod="unsigned integer"/>
        <Element Offset="3960" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000F78" DisplayMethod="unsigned integer"/>
        <Element Offset="3976" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F88" DisplayMethod="unsigned integer"/>
        <Element Offset="3984" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000F90" DisplayMethod="unsigned integer"/>
        <Element Offset="4000" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000FA0" DisplayMethod="unsigned integer"/>
        <Element Offset="4008" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000FA8" DisplayMethod="unsigned integer"/>
        <Element Offset="4024" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000FB8" DisplayMethod="unsigned integer"/>
        <Element Offset="4032" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000FC0" DisplayMethod="unsigned integer"/>
        <Element Offset="4048" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000FD0" DisplayMethod="unsigned integer"/>
        <Element Offset="4056" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000FD8" DisplayMethod="unsigned integer"/>
        <Element Offset="4072" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000FE8" DisplayMethod="unsigned integer"/>
        <Element Offset="4080" Vartype="Pointer" Bytesize="8" OffsetHex="00000FF0" DisplayMethod="unsigned integer"/>
        <Element Offset="4088" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000FF8" DisplayMethod="unsigned integer"/>
        <Element Offset="4092" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000FFC" DisplayMethod="hexadecimal"/>
      </Elements>
    </Structure>
    <Structure Name="unnamed structure 2" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
      <Elements>
        <Element Offset="0" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000000" DisplayMethod="unsigned integer"/>
        <Element Offset="4" Vartype="Pointer" Bytesize="8" OffsetHex="00000004" DisplayMethod="unsigned integer"/>
        <Element Offset="12" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000000C" DisplayMethod="unsigned integer"/>
        <Element Offset="20" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000014" DisplayMethod="unsigned integer"/>
        <Element Offset="36" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000024" DisplayMethod="unsigned integer"/>
        <Element Offset="44" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000002C" DisplayMethod="unsigned integer"/>
        <Element Offset="60" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000003C" DisplayMethod="unsigned integer"/>
        <Element Offset="68" Vartype="Byte" Bytesize="1" OffsetHex="00000044" DisplayMethod="unsigned integer"/>
        <Element Offset="69" Vartype="String" Bytesize="4" OffsetHex="00000045" DisplayMethod="unsigned integer"/>
        <Element Offset="73" Vartype="Byte" Bytesize="1" RLECount="3" OffsetHex="00000049" DisplayMethod="unsigned integer"/>
        <Element Offset="76" Vartype="Pointer" Bytesize="8" OffsetHex="0000004C" DisplayMethod="unsigned integer"/>
        <Element Offset="84" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000054" DisplayMethod="unsigned integer"/>
        <Element Offset="92" Vartype="Byte" Bytesize="1" OffsetHex="0000005C" DisplayMethod="unsigned integer"/>
        <Element Offset="93" Vartype="String" Bytesize="4" OffsetHex="0000005D" DisplayMethod="unsigned integer"/>
        <Element Offset="97" Vartype="Byte" Bytesize="1" RLECount="3" OffsetHex="00000061" DisplayMethod="unsigned integer"/>
        <Element Offset="100" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000064" DisplayMethod="unsigned integer"/>
        <Element Offset="116" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="00000074" DisplayMethod="unsigned integer"/>
        <Element Offset="132" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000084" DisplayMethod="hexadecimal"/>
        <Element Offset="136" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000088" DisplayMethod="unsigned integer"/>
        <Element Offset="140" Vartype="Pointer" Bytesize="8" OffsetHex="0000008C" DisplayMethod="unsigned integer"/>
        <Element Offset="148" Vartype="4 Bytes" Bytesize="4" RLECount="10" OffsetHex="00000094" DisplayMethod="unsigned integer"/>
        <Element Offset="188" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000000BC" DisplayMethod="unsigned integer"/>
        <Element Offset="204" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000000CC" DisplayMethod="unsigned integer"/>
        <Element Offset="212" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000000D4" DisplayMethod="unsigned integer"/>
        <Element Offset="228" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000000E4" DisplayMethod="unsigned integer"/>
        <Element Offset="236" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000000EC" DisplayMethod="unsigned integer"/>
        <Element Offset="252" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000000FC" DisplayMethod="unsigned integer"/>
        <Element Offset="260" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000104" DisplayMethod="unsigned integer"/>
        <Element Offset="276" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000114" DisplayMethod="unsigned integer"/>
        <Element Offset="284" Vartype="Byte" Bytesize="1" OffsetHex="0000011C" DisplayMethod="unsigned integer"/>
        <Element Offset="285" Vartype="String" Bytesize="4" OffsetHex="0000011D" DisplayMethod="unsigned integer"/>
        <Element Offset="289" Vartype="Byte" Bytesize="1" RLECount="3" OffsetHex="00000121" DisplayMethod="unsigned integer"/>
        <Element Offset="292" Vartype="Pointer" Bytesize="8" OffsetHex="00000124" DisplayMethod="unsigned integer"/>
        <Element Offset="300" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000012C" DisplayMethod="unsigned integer"/>
        <Element Offset="308" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000134" DisplayMethod="unsigned integer"/>
        <Element Offset="324" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000144" DisplayMethod="unsigned integer"/>
        <Element Offset="332" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000014C" DisplayMethod="unsigned integer"/>
        <Element Offset="348" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000015C" DisplayMethod="unsigned integer"/>
        <Element Offset="356" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000164" DisplayMethod="unsigned integer"/>
        <Element Offset="372" Vartype="4 Bytes" Bytesize="4" RLECount="12" OffsetHex="00000174" DisplayMethod="unsigned integer"/>
        <Element Offset="420" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000001A4" DisplayMethod="unsigned integer"/>
        <Element Offset="436" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="000001B4" DisplayMethod="unsigned integer"/>
        <Element Offset="452" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000001C4" DisplayMethod="unsigned integer"/>
        <Element Offset="468" Vartype="4 Bytes" Bytesize="4" RLECount="28" OffsetHex="000001D4" DisplayMethod="unsigned integer"/>
        <Element Offset="580" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000244" DisplayMethod="unsigned integer"/>
        <Element Offset="596" Vartype="4 Bytes" Bytesize="4" RLECount="6" OffsetHex="00000254" DisplayMethod="unsigned integer"/>
        <Element Offset="620" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000026C" DisplayMethod="unsigned integer"/>
        <Element Offset="636" Vartype="4 Bytes" Bytesize="4" RLECount="8" OffsetHex="0000027C" DisplayMethod="unsigned integer"/>
        <Element Offset="668" Vartype="Pointer" Bytesize="8" OffsetHex="0000029C" DisplayMethod="unsigned integer"/>
        <Element Offset="676" Vartype="Float" Bytesize="4" OffsetHex="000002A4" DisplayMethod="unsigned integer"/>
        <Element Offset="680" Vartype="4 Bytes" Bytesize="4" RLECount="39" OffsetHex="000002A8" DisplayMethod="unsigned integer"/>
        <Element Offset="836" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000344" DisplayMethod="unsigned integer"/>
        <Element Offset="852" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000354" DisplayMethod="unsigned integer"/>
        <Element Offset="860" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000035C" DisplayMethod="unsigned integer"/>
        <Element Offset="876" Vartype="4 Bytes" Bytesize="4" RLECount="18" OffsetHex="0000036C" DisplayMethod="unsigned integer"/>
        <Element Offset="948" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000003B4" DisplayMethod="unsigned integer"/>
        <Element Offset="964" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="000003C4" DisplayMethod="unsigned integer"/>
        <Element Offset="980" Vartype="Pointer" Bytesize="8" OffsetHex="000003D4" DisplayMethod="unsigned integer"/>
        <Element Offset="988" Vartype="4 Bytes" Bytesize="4" RLECount="8" OffsetHex="000003DC" DisplayMethod="unsigned integer"/>
        <Element Offset="1020" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000003FC" DisplayMethod="unsigned integer"/>
        <Element Offset="1036" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000040C" DisplayMethod="unsigned integer"/>
        <Element Offset="1044" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000414" DisplayMethod="unsigned integer"/>
        <Element Offset="1060" Vartype="4 Bytes" Bytesize="4" RLECount="18" OffsetHex="00000424" DisplayMethod="unsigned integer"/>
        <Element Offset="1132" Vartype="Pointer" Bytesize="8" OffsetHex="0000046C" DisplayMethod="unsigned integer"/>
        <Element Offset="1140" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000474" DisplayMethod="unsigned integer"/>
        <Element Offset="1148" Vartype="Pointer" Bytesize="8" OffsetHex="0000047C" DisplayMethod="unsigned integer"/>
        <Element Offset="1156" Vartype="4 Bytes" Bytesize="4" RLECount="17" OffsetHex="00000484" DisplayMethod="unsigned integer"/>
        <Element Offset="1224" Vartype="Float" Bytesize="4" RLECount="6" OffsetHex="000004C8" DisplayMethod="unsigned integer"/>
        <Element Offset="1248" Vartype="4 Bytes" Bytesize="4" OffsetHex="000004E0" DisplayMethod="unsigned integer"/>
        <Element Offset="1252" Vartype="Float" Bytesize="4" OffsetHex="000004E4" DisplayMethod="unsigned integer"/>
        <Element Offset="1256" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000004E8" DisplayMethod="unsigned integer"/>
        <Element Offset="1264" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="000004F0" DisplayMethod="unsigned integer"/>
        <Element Offset="1276" Vartype="4 Bytes" Bytesize="4" OffsetHex="000004FC" DisplayMethod="unsigned integer"/>
        <Element Offset="1280" Vartype="Float" Bytesize="4" OffsetHex="00000500" DisplayMethod="unsigned integer"/>
        <Element Offset="1284" Vartype="4 Bytes" Bytesize="4" RLECount="8" OffsetHex="00000504" DisplayMethod="unsigned integer"/>
        <Element Offset="1316" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000524" DisplayMethod="unsigned integer"/>
        <Element Offset="1332" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000534" DisplayMethod="unsigned integer"/>
        <Element Offset="1340" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000053C" DisplayMethod="unsigned integer"/>
        <Element Offset="1356" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000054C" DisplayMethod="unsigned integer"/>
        <Element Offset="1364" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000554" DisplayMethod="unsigned integer"/>
        <Element Offset="1380" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="00000564" DisplayMethod="unsigned integer"/>
        <Element Offset="1408" Vartype="Double" Bytesize="8" OffsetHex="00000580" DisplayMethod="unsigned integer"/>
        <Element Offset="1416" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000588" DisplayMethod="unsigned integer"/>
        <Element Offset="1420" Vartype="Pointer" Bytesize="8" OffsetHex="0000058C" DisplayMethod="unsigned integer"/>
        <Element Offset="1428" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000594" DisplayMethod="unsigned integer"/>
        <Element Offset="1436" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000059C" DisplayMethod="hexadecimal"/>
        <Element Offset="1440" Vartype="4 Bytes" Bytesize="4" RLECount="5" OffsetHex="000005A0" DisplayMethod="unsigned integer"/>
        <Element Offset="1460" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000005B4" DisplayMethod="unsigned integer"/>
        <Element Offset="1476" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000005C4" DisplayMethod="unsigned integer"/>
        <Element Offset="1484" Vartype="Pointer" Bytesize="8" OffsetHex="000005CC" DisplayMethod="unsigned integer"/>
        <Element Offset="1492" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000005D4" DisplayMethod="unsigned integer"/>
        <Element Offset="1500" Vartype="Pointer" Bytesize="8" OffsetHex="000005DC" DisplayMethod="unsigned integer"/>
        <Element Offset="1508" Vartype="4 Bytes" Bytesize="4" RLECount="8" OffsetHex="000005E4" DisplayMethod="unsigned integer"/>
        <Element Offset="1540" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000604" DisplayMethod="unsigned integer"/>
        <Element Offset="1556" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000614" DisplayMethod="unsigned integer"/>
        <Element Offset="1564" Vartype="Pointer" Bytesize="8" OffsetHex="0000061C" DisplayMethod="unsigned integer"/>
        <Element Offset="1572" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000624" DisplayMethod="unsigned integer"/>
        <Element Offset="1580" Vartype="Pointer" Bytesize="8" OffsetHex="0000062C" DisplayMethod="unsigned integer"/>
        <Element Offset="1588" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000634" DisplayMethod="unsigned integer"/>
        <Element Offset="1596" Vartype="Pointer" Bytesize="8" OffsetHex="0000063C" DisplayMethod="unsigned integer"/>
        <Element Offset="1604" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000644" DisplayMethod="unsigned integer"/>
        <Element Offset="1612" Vartype="Pointer" Bytesize="8" OffsetHex="0000064C" DisplayMethod="unsigned integer"/>
        <Element Offset="1620" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000654" DisplayMethod="unsigned integer"/>
        <Element Offset="1628" Vartype="Pointer" Bytesize="8" OffsetHex="0000065C" DisplayMethod="unsigned integer"/>
        <Element Offset="1636" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000664" DisplayMethod="unsigned integer"/>
        <Element Offset="1644" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000066C" DisplayMethod="unsigned integer"/>
        <Element Offset="1660" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000067C" DisplayMethod="unsigned integer"/>
        <Element Offset="1668" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000684" DisplayMethod="unsigned integer"/>
        <Element Offset="1684" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000694" DisplayMethod="unsigned integer"/>
        <Element Offset="1692" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000069C" DisplayMethod="unsigned integer"/>
        <Element Offset="1708" Vartype="4 Bytes" Bytesize="4" RLECount="118" OffsetHex="000006AC" DisplayMethod="unsigned integer"/>
        <Element Offset="2180" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000884" DisplayMethod="hexadecimal"/>
        <Element Offset="2184" Vartype="String" Bytesize="4" OffsetHex="00000888" DisplayMethod="unsigned integer"/>
        <Element Offset="2188" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000088C" DisplayMethod="hexadecimal"/>
        <Element Offset="2192" Vartype="Float" Bytesize="4" OffsetHex="00000890" DisplayMethod="unsigned integer"/>
        <Element Offset="2196" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000894" DisplayMethod="hexadecimal"/>
        <Element Offset="2200" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000898" DisplayMethod="unsigned integer"/>
        <Element Offset="2208" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000008A0" DisplayMethod="hexadecimal"/>
        <Element Offset="2220" Vartype="String" Bytesize="4" OffsetHex="000008AC" DisplayMethod="unsigned integer"/>
        <Element Offset="2224" Vartype="4 Bytes" Bytesize="4" OffsetHex="000008B0" DisplayMethod="hexadecimal"/>
        <Element Offset="2228" Vartype="Float" Bytesize="4" OffsetHex="000008B4" DisplayMethod="unsigned integer"/>
        <Element Offset="2232" Vartype="String" Bytesize="4" OffsetHex="000008B8" DisplayMethod="unsigned integer"/>
        <Element Offset="2236" Vartype="Float" Bytesize="4" OffsetHex="000008BC" DisplayMethod="unsigned integer"/>
        <Element Offset="2240" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000008C0" DisplayMethod="hexadecimal"/>
        <Element Offset="2252" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="000008CC" DisplayMethod="unsigned integer"/>
        <Element Offset="2260" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000008D4" DisplayMethod="hexadecimal"/>
        <Element Offset="2272" Vartype="Float" Bytesize="4" OffsetHex="000008E0" DisplayMethod="unsigned integer"/>
        <Element Offset="2276" Vartype="4 Bytes" Bytesize="4" OffsetHex="000008E4" DisplayMethod="hexadecimal"/>
        <Element Offset="2280" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="000008E8" DisplayMethod="unsigned integer"/>
        <Element Offset="2288" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000008F0" DisplayMethod="hexadecimal"/>
        <Element Offset="2300" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="000008FC" DisplayMethod="unsigned integer"/>
        <Element Offset="2308" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000904" DisplayMethod="hexadecimal"/>
        <Element Offset="2320" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000910" DisplayMethod="unsigned integer"/>
        <Element Offset="2324" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000914" DisplayMethod="hexadecimal"/>
        <Element Offset="2328" Vartype="Float" Bytesize="4" OffsetHex="00000918" DisplayMethod="unsigned integer"/>
        <Element Offset="2332" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="0000091C" DisplayMethod="hexadecimal"/>
        <Element Offset="2344" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000928" DisplayMethod="unsigned integer"/>
        <Element Offset="2352" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000930" DisplayMethod="hexadecimal"/>
        <Element Offset="2364" Vartype="Float" Bytesize="4" OffsetHex="0000093C" DisplayMethod="unsigned integer"/>
        <Element Offset="2368" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000940" DisplayMethod="hexadecimal"/>
        <Element Offset="2372" Vartype="Float" Bytesize="4" OffsetHex="00000944" DisplayMethod="unsigned integer"/>
        <Element Offset="2376" Vartype="Double" Bytesize="8" OffsetHex="00000948" DisplayMethod="unsigned integer"/>
        <Element Offset="2384" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000950" DisplayMethod="unsigned integer"/>
        <Element Offset="2392" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000958" DisplayMethod="hexadecimal"/>
        <Element Offset="2396" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="0000095C" DisplayMethod="unsigned integer"/>
        <Element Offset="2404" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000964" DisplayMethod="hexadecimal"/>
        <Element Offset="2416" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000970" DisplayMethod="unsigned integer"/>
        <Element Offset="2420" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000974" DisplayMethod="hexadecimal"/>
        <Element Offset="2424" Vartype="Float" Bytesize="4" OffsetHex="00000978" DisplayMethod="unsigned integer"/>
        <Element Offset="2428" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="0000097C" DisplayMethod="hexadecimal"/>
        <Element Offset="2440" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000988" DisplayMethod="unsigned integer"/>
        <Element Offset="2448" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000990" DisplayMethod="hexadecimal"/>
        <Element Offset="2460" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="0000099C" DisplayMethod="unsigned integer"/>
        <Element Offset="2464" Vartype="4 Bytes" Bytesize="4" OffsetHex="000009A0" DisplayMethod="hexadecimal"/>
        <Element Offset="2468" Vartype="Float" Bytesize="4" OffsetHex="000009A4" DisplayMethod="unsigned integer"/>
        <Element Offset="2472" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000009A8" DisplayMethod="hexadecimal"/>
        <Element Offset="2484" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="000009B4" DisplayMethod="unsigned integer"/>
        <Element Offset="2492" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000009BC" DisplayMethod="hexadecimal"/>
        <Element Offset="2504" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000009C8" DisplayMethod="unsigned integer"/>
        <Element Offset="2508" Vartype="4 Bytes" Bytesize="4" OffsetHex="000009CC" DisplayMethod="hexadecimal"/>
        <Element Offset="2512" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="000009D0" DisplayMethod="unsigned integer"/>
        <Element Offset="2524" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000009DC" DisplayMethod="hexadecimal"/>
        <Element Offset="2536" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="000009E8" DisplayMethod="unsigned integer"/>
        <Element Offset="2544" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000009F0" DisplayMethod="hexadecimal"/>
        <Element Offset="2556" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="000009FC" DisplayMethod="unsigned integer"/>
        <Element Offset="2560" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A00" DisplayMethod="hexadecimal"/>
        <Element Offset="2564" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000A04" DisplayMethod="unsigned integer"/>
        <Element Offset="2572" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000A0C" DisplayMethod="hexadecimal"/>
        <Element Offset="2584" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000A18" DisplayMethod="unsigned integer"/>
        <Element Offset="2592" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000A20" DisplayMethod="hexadecimal"/>
        <Element Offset="2604" Vartype="Float" Bytesize="4" OffsetHex="00000A2C" DisplayMethod="unsigned integer"/>
        <Element Offset="2608" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A30" DisplayMethod="hexadecimal"/>
        <Element Offset="2612" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000A34" DisplayMethod="unsigned integer"/>
        <Element Offset="2624" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000A40" DisplayMethod="hexadecimal"/>
        <Element Offset="2636" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000A4C" DisplayMethod="unsigned integer"/>
        <Element Offset="2644" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000A54" DisplayMethod="hexadecimal"/>
        <Element Offset="2656" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000A60" DisplayMethod="unsigned integer"/>
        <Element Offset="2660" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A64" DisplayMethod="hexadecimal"/>
        <Element Offset="2664" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000A68" DisplayMethod="unsigned integer"/>
        <Element Offset="2672" Vartype="Double" Bytesize="8" OffsetHex="00000A70" DisplayMethod="unsigned integer"/>
        <Element Offset="2680" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000A78" DisplayMethod="unsigned integer"/>
        <Element Offset="2688" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A80" DisplayMethod="hexadecimal"/>
        <Element Offset="2692" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000A84" DisplayMethod="unsigned integer"/>
        <Element Offset="2700" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000A8C" DisplayMethod="hexadecimal"/>
        <Element Offset="2712" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000A98" DisplayMethod="unsigned integer"/>
        <Element Offset="2716" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A9C" DisplayMethod="hexadecimal"/>
        <Element Offset="2720" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000AA0" DisplayMethod="unsigned integer"/>
        <Element Offset="2732" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000AAC" DisplayMethod="hexadecimal"/>
        <Element Offset="2744" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000AB8" DisplayMethod="unsigned integer"/>
        <Element Offset="2752" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000AC0" DisplayMethod="hexadecimal"/>
        <Element Offset="2764" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000ACC" DisplayMethod="unsigned integer"/>
        <Element Offset="2768" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000AD0" DisplayMethod="hexadecimal"/>
        <Element Offset="2772" Vartype="Float" Bytesize="4" OffsetHex="00000AD4" DisplayMethod="unsigned integer"/>
        <Element Offset="2776" Vartype="Byte" Bytesize="1" OffsetHex="00000AD8" DisplayMethod="unsigned integer"/>
        <Element Offset="2777" Vartype="String" Bytesize="4" OffsetHex="00000AD9" DisplayMethod="unsigned integer"/>
        <Element Offset="2781" Vartype="Byte" Bytesize="1" RLECount="3" OffsetHex="00000ADD" DisplayMethod="unsigned integer"/>
        <Element Offset="2784" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000AE0" DisplayMethod="hexadecimal"/>
        <Element Offset="2796" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000AEC" DisplayMethod="unsigned integer"/>
        <Element Offset="2804" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000AF4" DisplayMethod="hexadecimal"/>
        <Element Offset="2816" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000B00" DisplayMethod="unsigned integer"/>
        <Element Offset="2820" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B04" DisplayMethod="hexadecimal"/>
        <Element Offset="2824" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000B08" DisplayMethod="unsigned integer"/>
        <Element Offset="2832" Vartype="Double" Bytesize="8" OffsetHex="00000B10" DisplayMethod="unsigned integer"/>
        <Element Offset="2840" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000B18" DisplayMethod="unsigned integer"/>
        <Element Offset="2848" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B20" DisplayMethod="hexadecimal"/>
        <Element Offset="2852" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000B24" DisplayMethod="unsigned integer"/>
        <Element Offset="2860" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000B2C" DisplayMethod="hexadecimal"/>
        <Element Offset="2872" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000B38" DisplayMethod="unsigned integer"/>
        <Element Offset="2876" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B3C" DisplayMethod="hexadecimal"/>
        <Element Offset="2880" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000B40" DisplayMethod="unsigned integer"/>
        <Element Offset="2888" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000B48" DisplayMethod="hexadecimal"/>
        <Element Offset="2900" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000B54" DisplayMethod="unsigned integer"/>
        <Element Offset="2908" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000B5C" DisplayMethod="hexadecimal"/>
        <Element Offset="2920" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000B68" DisplayMethod="unsigned integer"/>
        <Element Offset="2924" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B6C" DisplayMethod="hexadecimal"/>
        <Element Offset="2928" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000B70" DisplayMethod="unsigned integer"/>
        <Element Offset="2936" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000B78" DisplayMethod="hexadecimal"/>
        <Element Offset="2948" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000B84" DisplayMethod="unsigned integer"/>
        <Element Offset="2956" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000B8C" DisplayMethod="hexadecimal"/>
        <Element Offset="2968" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000B98" DisplayMethod="unsigned integer"/>
        <Element Offset="2972" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B9C" DisplayMethod="hexadecimal"/>
        <Element Offset="2976" Vartype="Float" Bytesize="4" OffsetHex="00000BA0" DisplayMethod="unsigned integer"/>
        <Element Offset="2980" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000BA4" DisplayMethod="hexadecimal"/>
        <Element Offset="2992" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000BB0" DisplayMethod="unsigned integer"/>
        <Element Offset="3000" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000BB8" DisplayMethod="hexadecimal"/>
        <Element Offset="3012" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000BC4" DisplayMethod="unsigned integer"/>
        <Element Offset="3016" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000BC8" DisplayMethod="hexadecimal"/>
        <Element Offset="3020" Vartype="Float" Bytesize="4" OffsetHex="00000BCC" DisplayMethod="unsigned integer"/>
        <Element Offset="3024" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000BD0" DisplayMethod="hexadecimal"/>
        <Element Offset="3036" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000BDC" DisplayMethod="unsigned integer"/>
        <Element Offset="3044" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000BE4" DisplayMethod="hexadecimal"/>
        <Element Offset="3056" Vartype="Float" Bytesize="4" OffsetHex="00000BF0" DisplayMethod="unsigned integer"/>
        <Element Offset="3060" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000BF4" DisplayMethod="hexadecimal"/>
        <Element Offset="3064" Vartype="Float" Bytesize="4" OffsetHex="00000BF8" DisplayMethod="unsigned integer"/>
        <Element Offset="3068" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000BFC" DisplayMethod="hexadecimal"/>
        <Element Offset="3076" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="00000C04" DisplayMethod="unsigned integer"/>
        <Element Offset="3092" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C14" DisplayMethod="hexadecimal"/>
        <Element Offset="3096" Vartype="Double" Bytesize="8" OffsetHex="00000C18" DisplayMethod="unsigned integer"/>
        <Element Offset="3104" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000C20" DisplayMethod="hexadecimal"/>
        <Element Offset="3112" Vartype="Float" Bytesize="4" RLECount="4" OffsetHex="00000C28" DisplayMethod="unsigned integer"/>
        <Element Offset="3128" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C38" DisplayMethod="hexadecimal"/>
        <Element Offset="3132" Vartype="Float" Bytesize="4" RLECount="4" OffsetHex="00000C3C" DisplayMethod="unsigned integer"/>
        <Element Offset="3148" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C4C" DisplayMethod="hexadecimal"/>
        <Element Offset="3152" Vartype="Double" Bytesize="8" OffsetHex="00000C50" DisplayMethod="unsigned integer"/>
        <Element Offset="3160" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000C58" DisplayMethod="unsigned integer"/>
        <Element Offset="3168" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C60" DisplayMethod="hexadecimal"/>
        <Element Offset="3172" Vartype="Float" Bytesize="4" RLECount="4" OffsetHex="00000C64" DisplayMethod="unsigned integer"/>
        <Element Offset="3188" Vartype="Double" Bytesize="8" OffsetHex="00000C74" DisplayMethod="unsigned integer"/>
        <Element Offset="3196" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000C7C" DisplayMethod="unsigned integer"/>
        <Element Offset="3208" Vartype="Double" Bytesize="8" OffsetHex="00000C88" DisplayMethod="unsigned integer"/>
        <Element Offset="3216" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000C90" DisplayMethod="unsigned integer"/>
        <Element Offset="3228" Vartype="Double" Bytesize="8" OffsetHex="00000C9C" DisplayMethod="unsigned integer"/>
        <Element Offset="3236" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000CA4" DisplayMethod="unsigned integer"/>
        <Element Offset="3248" Vartype="Double" Bytesize="8" OffsetHex="00000CB0" DisplayMethod="unsigned integer"/>
        <Element Offset="3256" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000CB8" DisplayMethod="unsigned integer"/>
        <Element Offset="3268" Vartype="Double" Bytesize="8" OffsetHex="00000CC4" DisplayMethod="unsigned integer"/>
        <Element Offset="3276" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000CCC" DisplayMethod="unsigned integer"/>
        <Element Offset="3288" Vartype="Double" Bytesize="8" OffsetHex="00000CD8" DisplayMethod="unsigned integer"/>
        <Element Offset="3296" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000CE0" DisplayMethod="unsigned integer"/>
        <Element Offset="3308" Vartype="Double" Bytesize="8" OffsetHex="00000CEC" DisplayMethod="unsigned integer"/>
        <Element Offset="3316" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000CF4" DisplayMethod="unsigned integer"/>
        <Element Offset="3328" Vartype="Double" Bytesize="8" OffsetHex="00000D00" DisplayMethod="unsigned integer"/>
        <Element Offset="3336" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000D08" DisplayMethod="unsigned integer"/>
        <Element Offset="3348" Vartype="Double" Bytesize="8" OffsetHex="00000D14" DisplayMethod="unsigned integer"/>
        <Element Offset="3356" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000D1C" DisplayMethod="unsigned integer"/>
        <Element Offset="3368" Vartype="Double" Bytesize="8" OffsetHex="00000D28" DisplayMethod="unsigned integer"/>
        <Element Offset="3376" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000D30" DisplayMethod="unsigned integer"/>
        <Element Offset="3388" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D3C" DisplayMethod="hexadecimal"/>
        <Element Offset="3392" Vartype="Float" Bytesize="4" RLECount="4" OffsetHex="00000D40" DisplayMethod="unsigned integer"/>
        <Element Offset="3408" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D50" DisplayMethod="hexadecimal"/>
        <Element Offset="3412" Vartype="Float" Bytesize="4" RLECount="4" OffsetHex="00000D54" DisplayMethod="unsigned integer"/>
        <Element Offset="3428" Vartype="Double" Bytesize="8" OffsetHex="00000D64" DisplayMethod="unsigned integer"/>
        <Element Offset="3436" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000D6C" DisplayMethod="unsigned integer"/>
        <Element Offset="3448" Vartype="Double" Bytesize="8" OffsetHex="00000D78" DisplayMethod="unsigned integer"/>
        <Element Offset="3456" Vartype="Float" Bytesize="4" OffsetHex="00000D80" DisplayMethod="unsigned integer"/>
        <Element Offset="3460" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000D84" DisplayMethod="unsigned integer"/>
        <Element Offset="3464" Vartype="Float" Bytesize="4" OffsetHex="00000D88" DisplayMethod="unsigned integer"/>
        <Element Offset="3468" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D8C" DisplayMethod="hexadecimal"/>
        <Element Offset="3472" Vartype="Float" Bytesize="4" RLECount="4" OffsetHex="00000D90" DisplayMethod="unsigned integer"/>
        <Element Offset="3488" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000DA0" DisplayMethod="hexadecimal"/>
        <Element Offset="3492" Vartype="Double" Bytesize="8" OffsetHex="00000DA4" DisplayMethod="unsigned integer"/>
        <Element Offset="3500" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000DAC" DisplayMethod="unsigned integer"/>
        <Element Offset="3508" Vartype="Double" Bytesize="8" OffsetHex="00000DB4" DisplayMethod="unsigned integer"/>
        <Element Offset="3516" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="00000DBC" DisplayMethod="unsigned integer"/>
        <Element Offset="3528" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000DC8" DisplayMethod="hexadecimal"/>
        <Element Offset="3532" Vartype="Float" Bytesize="4" RLECount="38" OffsetHex="00000DCC" DisplayMethod="unsigned integer"/>
        <Element Offset="3684" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000E64" DisplayMethod="unsigned integer"/>
        <Element Offset="3688" Vartype="Float" Bytesize="4" RLECount="5" OffsetHex="00000E68" DisplayMethod="unsigned integer"/>
        <Element Offset="3708" Vartype="Double" Bytesize="8" OffsetHex="00000E7C" DisplayMethod="unsigned integer"/>
        <Element Offset="3716" Vartype="Float" Bytesize="4" OffsetHex="00000E84" DisplayMethod="unsigned integer"/>
        <Element Offset="3720" Vartype="Double" Bytesize="8" OffsetHex="00000E88" DisplayMethod="unsigned integer"/>
        <Element Offset="3728" Vartype="Float" Bytesize="4" RLECount="5" OffsetHex="00000E90" DisplayMethod="unsigned integer"/>
        <Element Offset="3748" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000EA4" DisplayMethod="unsigned integer"/>
        <Element Offset="3752" Vartype="Float" Bytesize="4" OffsetHex="00000EA8" DisplayMethod="unsigned integer"/>
        <Element Offset="3756" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000EAC" DisplayMethod="unsigned integer"/>
        <Element Offset="3760" Vartype="Float" Bytesize="4" RLECount="8" OffsetHex="00000EB0" DisplayMethod="unsigned integer"/>
        <Element Offset="3792" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000ED0" DisplayMethod="hexadecimal"/>
        <Element Offset="3796" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000ED4" DisplayMethod="unsigned integer"/>
        <Element Offset="3800" Vartype="Float" Bytesize="4" OffsetHex="00000ED8" DisplayMethod="unsigned integer"/>
        <Element Offset="3804" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000EDC" DisplayMethod="unsigned integer"/>
        <Element Offset="3808" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000EE0" DisplayMethod="unsigned integer"/>
        <Element Offset="3816" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000EE8" DisplayMethod="unsigned integer"/>
        <Element Offset="3820" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000EEC" DisplayMethod="unsigned integer"/>
        <Element Offset="3828" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000EF4" DisplayMethod="hexadecimal"/>
        <Element Offset="3832" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000EF8" DisplayMethod="unsigned integer"/>
        <Element Offset="3840" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F00" DisplayMethod="hexadecimal"/>
        <Element Offset="3844" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000F04" DisplayMethod="unsigned integer"/>
        <Element Offset="3852" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F0C" DisplayMethod="hexadecimal"/>
        <Element Offset="3856" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000F10" DisplayMethod="unsigned integer"/>
        <Element Offset="3864" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F18" DisplayMethod="hexadecimal"/>
        <Element Offset="3868" Vartype="Float" Bytesize="4" OffsetHex="00000F1C" DisplayMethod="unsigned integer"/>
        <Element Offset="3872" Vartype="Byte" Bytesize="1" RLECount="4" OffsetHex="00000F20" DisplayMethod="unsigned integer"/>
        <Element Offset="3876" Vartype="Double" Bytesize="8" OffsetHex="00000F24" DisplayMethod="unsigned integer"/>
        <Element Offset="3884" Vartype="Float" Bytesize="4" RLECount="7" OffsetHex="00000F2C" DisplayMethod="unsigned integer"/>
        <Element Offset="3912" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F48" DisplayMethod="unsigned integer"/>
        <Element Offset="3916" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000F4C" DisplayMethod="unsigned integer"/>
        <Element Offset="3924" Vartype="Double" Bytesize="8" OffsetHex="00000F54" DisplayMethod="unsigned integer"/>
        <Element Offset="3932" Vartype="Float" Bytesize="4" OffsetHex="00000F5C" DisplayMethod="unsigned integer"/>
        <Element Offset="3936" Vartype="Double" Bytesize="8" OffsetHex="00000F60" DisplayMethod="unsigned integer"/>
        <Element Offset="3944" Vartype="Float" Bytesize="4" OffsetHex="00000F68" DisplayMethod="unsigned integer"/>
        <Element Offset="3948" Vartype="Double" Bytesize="8" OffsetHex="00000F6C" DisplayMethod="unsigned integer"/>
        <Element Offset="3956" Vartype="Float" Bytesize="4" RLECount="2" OffsetHex="00000F74" DisplayMethod="unsigned integer"/>
        <Element Offset="3964" Vartype="4 Bytes" Bytesize="4" RLECount="33" OffsetHex="00000F7C" DisplayMethod="hexadecimal"/>
      </Elements>
    </Structure>
    <Structure Name="unnamed structure 3" AutoFill="0" AutoCreate="1" DefaultHex="0" AutoDestroy="0" DoNotSaveLocal="0" RLECompression="1" AutoCreateStructsize="4096">
      <Elements>
        <Element Offset="0" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000000" DisplayMethod="unsigned integer"/>
        <Element Offset="12" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000000C" DisplayMethod="unsigned integer"/>
        <Element Offset="28" Vartype="4 Bytes" Bytesize="4" RLECount="10" OffsetHex="0000001C" DisplayMethod="unsigned integer"/>
        <Element Offset="68" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000044" DisplayMethod="unsigned integer"/>
        <Element Offset="84" Vartype="4 Bytes" Bytesize="4" RLECount="30" OffsetHex="00000054" DisplayMethod="unsigned integer"/>
        <Element Offset="204" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000000CC" DisplayMethod="unsigned integer"/>
        <Element Offset="220" Vartype="4 Bytes" Bytesize="4" RLECount="6" OffsetHex="000000DC" DisplayMethod="unsigned integer"/>
        <Element Offset="244" Vartype="Float" Bytesize="4" RLECount="3" OffsetHex="000000F4" DisplayMethod="unsigned integer"/>
        <Element Offset="256" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000100" DisplayMethod="unsigned integer"/>
        <Element Offset="268" Vartype="Double" Bytesize="8" OffsetHex="0000010C" DisplayMethod="unsigned integer"/>
        <Element Offset="276" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000114" DisplayMethod="unsigned integer"/>
        <Element Offset="280" Vartype="Double" Bytesize="8" OffsetHex="00000118" DisplayMethod="unsigned integer"/>
        <Element Offset="288" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000120" DisplayMethod="unsigned integer"/>
        <Element Offset="292" Vartype="Pointer" Bytesize="8" OffsetHex="00000124" DisplayMethod="unsigned integer"/>
        <Element Offset="300" Vartype="Float" Bytesize="4" OffsetHex="0000012C" DisplayMethod="unsigned integer"/>
        <Element Offset="304" Vartype="4 Bytes" Bytesize="4" RLECount="21" OffsetHex="00000130" DisplayMethod="unsigned integer"/>
        <Element Offset="388" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000184" DisplayMethod="unsigned integer"/>
        <Element Offset="404" Vartype="4 Bytes" Bytesize="4" RLECount="22" OffsetHex="00000194" DisplayMethod="unsigned integer"/>
        <Element Offset="492" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000001EC" DisplayMethod="hexadecimal"/>
        <Element Offset="504" Vartype="4 Bytes" Bytesize="4" RLECount="15" OffsetHex="000001F8" DisplayMethod="unsigned integer"/>
        <Element Offset="564" Vartype="Byte" Bytesize="1" OffsetHex="00000234" DisplayMethod="unsigned integer"/>
        <Element Offset="565" Vartype="String" Bytesize="4" OffsetHex="00000235" DisplayMethod="unsigned integer"/>
        <Element Offset="569" Vartype="Byte" Bytesize="1" RLECount="3" OffsetHex="00000239" DisplayMethod="unsigned integer"/>
        <Element Offset="572" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="0000023C" DisplayMethod="unsigned integer"/>
        <Element Offset="588" Vartype="Pointer" Bytesize="8" OffsetHex="0000024C" DisplayMethod="unsigned integer"/>
        <Element Offset="596" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="00000254" DisplayMethod="unsigned integer"/>
        <Element Offset="612" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000264" DisplayMethod="unsigned integer"/>
        <Element Offset="628" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="00000274" DisplayMethod="unsigned integer"/>
        <Element Offset="644" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000284" DisplayMethod="unsigned integer"/>
        <Element Offset="660" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000294" DisplayMethod="unsigned integer"/>
        <Element Offset="668" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000029C" DisplayMethod="unsigned integer"/>
        <Element Offset="684" Vartype="4 Bytes" Bytesize="4" RLECount="20" OffsetHex="000002AC" DisplayMethod="unsigned integer"/>
        <Element Offset="764" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000002FC" DisplayMethod="unsigned integer"/>
        <Element Offset="780" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="0000030C" DisplayMethod="unsigned integer"/>
        <Element Offset="796" Vartype="String" Bytesize="5" OffsetHex="0000031C" DisplayMethod="unsigned integer"/>
        <Element Offset="801" Vartype="Byte" Bytesize="1" RLECount="3" OffsetHex="00000321" DisplayMethod="unsigned integer"/>
        <Element Offset="804" Vartype="String" Bytesize="5" OffsetHex="00000324" DisplayMethod="unsigned integer"/>
        <Element Offset="809" Vartype="Byte" Bytesize="1" RLECount="3" OffsetHex="00000329" DisplayMethod="unsigned integer"/>
        <Element Offset="812" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000032C" DisplayMethod="unsigned integer"/>
        <Element Offset="820" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000334" DisplayMethod="unsigned integer"/>
        <Element Offset="836" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000344" DisplayMethod="unsigned integer"/>
        <Element Offset="844" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000034C" DisplayMethod="unsigned integer"/>
        <Element Offset="860" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000035C" DisplayMethod="unsigned integer"/>
        <Element Offset="868" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000364" DisplayMethod="unsigned integer"/>
        <Element Offset="884" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000374" DisplayMethod="unsigned integer"/>
        <Element Offset="892" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000037C" DisplayMethod="unsigned integer"/>
        <Element Offset="908" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000038C" DisplayMethod="unsigned integer"/>
        <Element Offset="916" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000394" DisplayMethod="unsigned integer"/>
        <Element Offset="932" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000003A4" DisplayMethod="unsigned integer"/>
        <Element Offset="940" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000003AC" DisplayMethod="unsigned integer"/>
        <Element Offset="956" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000003BC" DisplayMethod="unsigned integer"/>
        <Element Offset="964" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000003C4" DisplayMethod="unsigned integer"/>
        <Element Offset="980" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000003D4" DisplayMethod="unsigned integer"/>
        <Element Offset="988" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000003DC" DisplayMethod="unsigned integer"/>
        <Element Offset="1004" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000003EC" DisplayMethod="unsigned integer"/>
        <Element Offset="1012" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000003F4" DisplayMethod="unsigned integer"/>
        <Element Offset="1028" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000404" DisplayMethod="unsigned integer"/>
        <Element Offset="1036" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000040C" DisplayMethod="unsigned integer"/>
        <Element Offset="1052" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="0000041C" DisplayMethod="unsigned integer"/>
        <Element Offset="1068" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000042C" DisplayMethod="unsigned integer"/>
        <Element Offset="1084" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000043C" DisplayMethod="unsigned integer"/>
        <Element Offset="1092" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000444" DisplayMethod="unsigned integer"/>
        <Element Offset="1108" Vartype="4 Bytes" Bytesize="4" RLECount="9" OffsetHex="00000454" DisplayMethod="unsigned integer"/>
        <Element Offset="1144" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000478" DisplayMethod="hexadecimal"/>
        <Element Offset="1156" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="00000484" DisplayMethod="unsigned integer"/>
        <Element Offset="1172" Vartype="Byte" Bytesize="1" OffsetHex="00000494" DisplayMethod="unsigned integer"/>
        <Element Offset="1173" Vartype="String" Bytesize="4" OffsetHex="00000495" DisplayMethod="unsigned integer"/>
        <Element Offset="1177" Vartype="Byte" Bytesize="1" RLECount="3" OffsetHex="00000499" DisplayMethod="unsigned integer"/>
        <Element Offset="1180" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="0000049C" DisplayMethod="unsigned integer"/>
        <Element Offset="1196" Vartype="Pointer" Bytesize="8" OffsetHex="000004AC" DisplayMethod="unsigned integer"/>
        <Element Offset="1204" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000004B4" DisplayMethod="unsigned integer"/>
        <Element Offset="1212" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000004BC" DisplayMethod="unsigned integer"/>
        <Element Offset="1228" Vartype="4 Bytes" Bytesize="4" RLECount="6" OffsetHex="000004CC" DisplayMethod="unsigned integer"/>
        <Element Offset="1252" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000004E4" DisplayMethod="unsigned integer"/>
        <Element Offset="1268" Vartype="4 Bytes" Bytesize="4" RLECount="6" OffsetHex="000004F4" DisplayMethod="unsigned integer"/>
        <Element Offset="1292" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000050C" DisplayMethod="unsigned integer"/>
        <Element Offset="1308" Vartype="4 Bytes" Bytesize="4" RLECount="16" OffsetHex="0000051C" DisplayMethod="unsigned integer"/>
        <Element Offset="1372" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000055C" DisplayMethod="unsigned integer"/>
        <Element Offset="1388" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="0000056C" DisplayMethod="unsigned integer"/>
        <Element Offset="1404" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000057C" DisplayMethod="unsigned integer"/>
        <Element Offset="1420" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="0000058C" DisplayMethod="unsigned integer"/>
        <Element Offset="1436" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000059C" DisplayMethod="unsigned integer"/>
        <Element Offset="1452" Vartype="4 Bytes" Bytesize="4" RLECount="13" OffsetHex="000005AC" DisplayMethod="unsigned integer"/>
        <Element Offset="1504" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000005E0" DisplayMethod="hexadecimal"/>
        <Element Offset="1516" Vartype="4 Bytes" Bytesize="4" RLECount="12" OffsetHex="000005EC" DisplayMethod="unsigned integer"/>
        <Element Offset="1564" Vartype="Byte" Bytesize="1" OffsetHex="0000061C" DisplayMethod="unsigned integer"/>
        <Element Offset="1565" Vartype="String" Bytesize="4" OffsetHex="0000061D" DisplayMethod="unsigned integer"/>
        <Element Offset="1569" Vartype="Byte" Bytesize="1" RLECount="2" OffsetHex="00000621" DisplayMethod="unsigned integer"/>
        <Element Offset="1571" Vartype="2 Bytes" Bytesize="2" OffsetHex="00000623" DisplayMethod="unsigned integer"/>
        <Element Offset="1573" Vartype="Byte" Bytesize="1" RLECount="2" OffsetHex="00000625" DisplayMethod="unsigned integer"/>
        <Element Offset="1575" Vartype="2 Bytes" Bytesize="2" OffsetHex="00000627" DisplayMethod="unsigned integer"/>
        <Element Offset="1577" Vartype="Byte" Bytesize="1" RLECount="3" OffsetHex="00000629" DisplayMethod="unsigned integer"/>
        <Element Offset="1580" Vartype="4 Bytes" Bytesize="4" OffsetHex="0000062C" DisplayMethod="hexadecimal"/>
        <Element Offset="1584" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000630" DisplayMethod="unsigned integer"/>
        <Element Offset="1588" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000634" DisplayMethod="hexadecimal"/>
        <Element Offset="1592" Vartype="4 Bytes" Bytesize="4" RLECount="5" OffsetHex="00000638" DisplayMethod="unsigned integer"/>
        <Element Offset="1612" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000064C" DisplayMethod="unsigned integer"/>
        <Element Offset="1628" Vartype="4 Bytes" Bytesize="4" RLECount="14" OffsetHex="0000065C" DisplayMethod="unsigned integer"/>
        <Element Offset="1684" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="00000694" DisplayMethod="unsigned integer"/>
        <Element Offset="1700" Vartype="4 Bytes" Bytesize="4" RLECount="10" OffsetHex="000006A4" DisplayMethod="unsigned integer"/>
        <Element Offset="1740" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000006CC" DisplayMethod="unsigned integer"/>
        <Element Offset="1756" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="000006DC" DisplayMethod="unsigned integer"/>
        <Element Offset="1772" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000006EC" DisplayMethod="unsigned integer"/>
        <Element Offset="1788" Vartype="4 Bytes" Bytesize="4" RLECount="16" OffsetHex="000006FC" DisplayMethod="unsigned integer"/>
        <Element Offset="1852" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000073C" DisplayMethod="unsigned integer"/>
        <Element Offset="1868" Vartype="4 Bytes" Bytesize="4" RLECount="8" OffsetHex="0000074C" DisplayMethod="unsigned integer"/>
        <Element Offset="1900" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="0000076C" DisplayMethod="unsigned integer"/>
        <Element Offset="1916" Vartype="4 Bytes" Bytesize="4" RLECount="7" OffsetHex="0000077C" DisplayMethod="unsigned integer"/>
        <Element Offset="1944" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="00000798" DisplayMethod="hexadecimal"/>
        <Element Offset="1956" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000007A4" DisplayMethod="unsigned integer"/>
        <Element Offset="1964" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000007AC" DisplayMethod="unsigned integer"/>
        <Element Offset="1980" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="000007BC" DisplayMethod="unsigned integer"/>
        <Element Offset="1996" Vartype="Pointer" Bytesize="8" OffsetHex="000007CC" DisplayMethod="unsigned integer"/>
        <Element Offset="2004" Vartype="Float" Bytesize="4" OffsetHex="000007D4" DisplayMethod="unsigned integer"/>
        <Element Offset="2008" Vartype="4 Bytes" Bytesize="4" RLECount="3" OffsetHex="000007D8" DisplayMethod="unsigned integer"/>
        <Element Offset="2020" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000007E4" DisplayMethod="unsigned integer"/>
        <Element Offset="2036" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000007F4" DisplayMethod="unsigned integer"/>
        <Element Offset="2044" Vartype="Pointer" Bytesize="8" RLECount="2" OffsetHex="000007FC" DisplayMethod="unsigned integer"/>
        <Element Offset="2060" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000080C" DisplayMethod="unsigned integer"/>
        <Element Offset="2068" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000814" DisplayMethod="hexadecimal"/>
        <Element Offset="2072" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000818" DisplayMethod="unsigned integer"/>
        <Element Offset="2076" Vartype="Pointer" Bytesize="8" OffsetHex="0000081C" DisplayMethod="unsigned integer"/>
        <Element Offset="2084" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000824" DisplayMethod="hexadecimal"/>
        <Element Offset="2092" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000082C" DisplayMethod="unsigned integer"/>
        <Element Offset="2100" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000834" DisplayMethod="hexadecimal"/>
        <Element Offset="2104" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000838" DisplayMethod="unsigned integer"/>
        <Element Offset="2108" Vartype="Pointer" Bytesize="8" OffsetHex="0000083C" DisplayMethod="unsigned integer"/>
        <Element Offset="2116" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000844" DisplayMethod="hexadecimal"/>
        <Element Offset="2124" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000084C" DisplayMethod="unsigned integer"/>
        <Element Offset="2132" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000854" DisplayMethod="hexadecimal"/>
        <Element Offset="2136" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000858" DisplayMethod="unsigned integer"/>
        <Element Offset="2140" Vartype="Pointer" Bytesize="8" OffsetHex="0000085C" DisplayMethod="unsigned integer"/>
        <Element Offset="2148" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000864" DisplayMethod="hexadecimal"/>
        <Element Offset="2156" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000086C" DisplayMethod="unsigned integer"/>
        <Element Offset="2164" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000874" DisplayMethod="hexadecimal"/>
        <Element Offset="2168" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000878" DisplayMethod="unsigned integer"/>
        <Element Offset="2172" Vartype="Pointer" Bytesize="8" OffsetHex="0000087C" DisplayMethod="unsigned integer"/>
        <Element Offset="2180" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000884" DisplayMethod="hexadecimal"/>
        <Element Offset="2188" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000088C" DisplayMethod="unsigned integer"/>
        <Element Offset="2196" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000894" DisplayMethod="hexadecimal"/>
        <Element Offset="2200" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000898" DisplayMethod="unsigned integer"/>
        <Element Offset="2204" Vartype="Pointer" Bytesize="8" OffsetHex="0000089C" DisplayMethod="unsigned integer"/>
        <Element Offset="2212" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000008A4" DisplayMethod="hexadecimal"/>
        <Element Offset="2220" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000008AC" DisplayMethod="unsigned integer"/>
        <Element Offset="2228" Vartype="4 Bytes" Bytesize="4" OffsetHex="000008B4" DisplayMethod="hexadecimal"/>
        <Element Offset="2232" Vartype="4 Bytes" Bytesize="4" OffsetHex="000008B8" DisplayMethod="unsigned integer"/>
        <Element Offset="2236" Vartype="Pointer" Bytesize="8" OffsetHex="000008BC" DisplayMethod="unsigned integer"/>
        <Element Offset="2244" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000008C4" DisplayMethod="hexadecimal"/>
        <Element Offset="2252" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000008CC" DisplayMethod="unsigned integer"/>
        <Element Offset="2260" Vartype="4 Bytes" Bytesize="4" OffsetHex="000008D4" DisplayMethod="hexadecimal"/>
        <Element Offset="2264" Vartype="4 Bytes" Bytesize="4" OffsetHex="000008D8" DisplayMethod="unsigned integer"/>
        <Element Offset="2268" Vartype="Pointer" Bytesize="8" OffsetHex="000008DC" DisplayMethod="unsigned integer"/>
        <Element Offset="2276" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000008E4" DisplayMethod="hexadecimal"/>
        <Element Offset="2284" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000008EC" DisplayMethod="unsigned integer"/>
        <Element Offset="2292" Vartype="4 Bytes" Bytesize="4" OffsetHex="000008F4" DisplayMethod="hexadecimal"/>
        <Element Offset="2296" Vartype="4 Bytes" Bytesize="4" OffsetHex="000008F8" DisplayMethod="unsigned integer"/>
        <Element Offset="2300" Vartype="Pointer" Bytesize="8" OffsetHex="000008FC" DisplayMethod="unsigned integer"/>
        <Element Offset="2308" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000904" DisplayMethod="hexadecimal"/>
        <Element Offset="2316" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000090C" DisplayMethod="unsigned integer"/>
        <Element Offset="2324" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000914" DisplayMethod="hexadecimal"/>
        <Element Offset="2328" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000918" DisplayMethod="unsigned integer"/>
        <Element Offset="2332" Vartype="Pointer" Bytesize="8" OffsetHex="0000091C" DisplayMethod="unsigned integer"/>
        <Element Offset="2340" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000924" DisplayMethod="hexadecimal"/>
        <Element Offset="2348" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000092C" DisplayMethod="unsigned integer"/>
        <Element Offset="2356" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000934" DisplayMethod="hexadecimal"/>
        <Element Offset="2360" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000938" DisplayMethod="unsigned integer"/>
        <Element Offset="2364" Vartype="Pointer" Bytesize="8" OffsetHex="0000093C" DisplayMethod="unsigned integer"/>
        <Element Offset="2372" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000944" DisplayMethod="hexadecimal"/>
        <Element Offset="2380" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000094C" DisplayMethod="unsigned integer"/>
        <Element Offset="2388" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000954" DisplayMethod="hexadecimal"/>
        <Element Offset="2392" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000958" DisplayMethod="unsigned integer"/>
        <Element Offset="2396" Vartype="Pointer" Bytesize="8" OffsetHex="0000095C" DisplayMethod="unsigned integer"/>
        <Element Offset="2404" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000964" DisplayMethod="hexadecimal"/>
        <Element Offset="2412" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000096C" DisplayMethod="unsigned integer"/>
        <Element Offset="2420" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000974" DisplayMethod="hexadecimal"/>
        <Element Offset="2424" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000978" DisplayMethod="unsigned integer"/>
        <Element Offset="2428" Vartype="Pointer" Bytesize="8" OffsetHex="0000097C" DisplayMethod="unsigned integer"/>
        <Element Offset="2436" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000984" DisplayMethod="hexadecimal"/>
        <Element Offset="2444" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="0000098C" DisplayMethod="unsigned integer"/>
        <Element Offset="2452" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000994" DisplayMethod="hexadecimal"/>
        <Element Offset="2456" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000998" DisplayMethod="unsigned integer"/>
        <Element Offset="2460" Vartype="Pointer" Bytesize="8" OffsetHex="0000099C" DisplayMethod="unsigned integer"/>
        <Element Offset="2468" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000009A4" DisplayMethod="hexadecimal"/>
        <Element Offset="2476" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000009AC" DisplayMethod="unsigned integer"/>
        <Element Offset="2484" Vartype="4 Bytes" Bytesize="4" OffsetHex="000009B4" DisplayMethod="hexadecimal"/>
        <Element Offset="2488" Vartype="4 Bytes" Bytesize="4" OffsetHex="000009B8" DisplayMethod="unsigned integer"/>
        <Element Offset="2492" Vartype="Pointer" Bytesize="8" OffsetHex="000009BC" DisplayMethod="unsigned integer"/>
        <Element Offset="2500" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000009C4" DisplayMethod="hexadecimal"/>
        <Element Offset="2508" Vartype="4 Bytes" Bytesize="4" RLECount="4" OffsetHex="000009CC" DisplayMethod="unsigned integer"/>
        <Element Offset="2524" Vartype="Pointer" Bytesize="8" OffsetHex="000009DC" DisplayMethod="unsigned integer"/>
        <Element Offset="2532" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000009E4" DisplayMethod="hexadecimal"/>
        <Element Offset="2540" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="000009EC" DisplayMethod="unsigned integer"/>
        <Element Offset="2548" Vartype="4 Bytes" Bytesize="4" OffsetHex="000009F4" DisplayMethod="hexadecimal"/>
        <Element Offset="2552" Vartype="4 Bytes" Bytesize="4" OffsetHex="000009F8" DisplayMethod="unsigned integer"/>
        <Element Offset="2556" Vartype="Pointer" Bytesize="8" OffsetHex="000009FC" DisplayMethod="unsigned integer"/>
        <Element Offset="2564" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000A04" DisplayMethod="hexadecimal"/>
        <Element Offset="2572" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000A0C" DisplayMethod="unsigned integer"/>
        <Element Offset="2580" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A14" DisplayMethod="hexadecimal"/>
        <Element Offset="2584" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A18" DisplayMethod="unsigned integer"/>
        <Element Offset="2588" Vartype="Pointer" Bytesize="8" OffsetHex="00000A1C" DisplayMethod="unsigned integer"/>
        <Element Offset="2596" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000A24" DisplayMethod="hexadecimal"/>
        <Element Offset="2604" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000A2C" DisplayMethod="unsigned integer"/>
        <Element Offset="2612" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A34" DisplayMethod="hexadecimal"/>
        <Element Offset="2616" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A38" DisplayMethod="unsigned integer"/>
        <Element Offset="2620" Vartype="Pointer" Bytesize="8" OffsetHex="00000A3C" DisplayMethod="unsigned integer"/>
        <Element Offset="2628" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000A44" DisplayMethod="hexadecimal"/>
        <Element Offset="2636" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000A4C" DisplayMethod="unsigned integer"/>
        <Element Offset="2644" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A54" DisplayMethod="hexadecimal"/>
        <Element Offset="2648" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A58" DisplayMethod="unsigned integer"/>
        <Element Offset="2652" Vartype="Pointer" Bytesize="8" OffsetHex="00000A5C" DisplayMethod="unsigned integer"/>
        <Element Offset="2660" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000A64" DisplayMethod="hexadecimal"/>
        <Element Offset="2668" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000A6C" DisplayMethod="unsigned integer"/>
        <Element Offset="2676" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A74" DisplayMethod="hexadecimal"/>
        <Element Offset="2680" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A78" DisplayMethod="unsigned integer"/>
        <Element Offset="2684" Vartype="Pointer" Bytesize="8" OffsetHex="00000A7C" DisplayMethod="unsigned integer"/>
        <Element Offset="2692" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000A84" DisplayMethod="hexadecimal"/>
        <Element Offset="2700" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000A8C" DisplayMethod="unsigned integer"/>
        <Element Offset="2708" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A94" DisplayMethod="hexadecimal"/>
        <Element Offset="2712" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000A98" DisplayMethod="unsigned integer"/>
        <Element Offset="2716" Vartype="Pointer" Bytesize="8" OffsetHex="00000A9C" DisplayMethod="unsigned integer"/>
        <Element Offset="2724" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000AA4" DisplayMethod="hexadecimal"/>
        <Element Offset="2732" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000AAC" DisplayMethod="unsigned integer"/>
        <Element Offset="2740" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000AB4" DisplayMethod="hexadecimal"/>
        <Element Offset="2744" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000AB8" DisplayMethod="unsigned integer"/>
        <Element Offset="2748" Vartype="Pointer" Bytesize="8" OffsetHex="00000ABC" DisplayMethod="unsigned integer"/>
        <Element Offset="2756" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000AC4" DisplayMethod="hexadecimal"/>
        <Element Offset="2764" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000ACC" DisplayMethod="unsigned integer"/>
        <Element Offset="2772" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000AD4" DisplayMethod="hexadecimal"/>
        <Element Offset="2776" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000AD8" DisplayMethod="unsigned integer"/>
        <Element Offset="2780" Vartype="Pointer" Bytesize="8" OffsetHex="00000ADC" DisplayMethod="unsigned integer"/>
        <Element Offset="2788" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000AE4" DisplayMethod="hexadecimal"/>
        <Element Offset="2796" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000AEC" DisplayMethod="unsigned integer"/>
        <Element Offset="2804" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000AF4" DisplayMethod="hexadecimal"/>
        <Element Offset="2808" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000AF8" DisplayMethod="unsigned integer"/>
        <Element Offset="2812" Vartype="Pointer" Bytesize="8" OffsetHex="00000AFC" DisplayMethod="unsigned integer"/>
        <Element Offset="2820" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000B04" DisplayMethod="hexadecimal"/>
        <Element Offset="2828" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000B0C" DisplayMethod="unsigned integer"/>
        <Element Offset="2836" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B14" DisplayMethod="hexadecimal"/>
        <Element Offset="2840" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B18" DisplayMethod="unsigned integer"/>
        <Element Offset="2844" Vartype="Pointer" Bytesize="8" OffsetHex="00000B1C" DisplayMethod="unsigned integer"/>
        <Element Offset="2852" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000B24" DisplayMethod="hexadecimal"/>
        <Element Offset="2860" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000B2C" DisplayMethod="unsigned integer"/>
        <Element Offset="2868" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B34" DisplayMethod="hexadecimal"/>
        <Element Offset="2872" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B38" DisplayMethod="unsigned integer"/>
        <Element Offset="2876" Vartype="Pointer" Bytesize="8" OffsetHex="00000B3C" DisplayMethod="unsigned integer"/>
        <Element Offset="2884" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000B44" DisplayMethod="hexadecimal"/>
        <Element Offset="2892" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000B4C" DisplayMethod="unsigned integer"/>
        <Element Offset="2900" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B54" DisplayMethod="hexadecimal"/>
        <Element Offset="2904" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B58" DisplayMethod="unsigned integer"/>
        <Element Offset="2908" Vartype="Pointer" Bytesize="8" OffsetHex="00000B5C" DisplayMethod="unsigned integer"/>
        <Element Offset="2916" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000B64" DisplayMethod="hexadecimal"/>
        <Element Offset="2924" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000B6C" DisplayMethod="unsigned integer"/>
        <Element Offset="2932" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B74" DisplayMethod="hexadecimal"/>
        <Element Offset="2936" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B78" DisplayMethod="unsigned integer"/>
        <Element Offset="2940" Vartype="Pointer" Bytesize="8" OffsetHex="00000B7C" DisplayMethod="unsigned integer"/>
        <Element Offset="2948" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000B84" DisplayMethod="hexadecimal"/>
        <Element Offset="2956" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000B8C" DisplayMethod="unsigned integer"/>
        <Element Offset="2964" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B94" DisplayMethod="hexadecimal"/>
        <Element Offset="2968" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000B98" DisplayMethod="unsigned integer"/>
        <Element Offset="2972" Vartype="Pointer" Bytesize="8" OffsetHex="00000B9C" DisplayMethod="unsigned integer"/>
        <Element Offset="2980" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000BA4" DisplayMethod="hexadecimal"/>
        <Element Offset="2988" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000BAC" DisplayMethod="unsigned integer"/>
        <Element Offset="2996" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000BB4" DisplayMethod="hexadecimal"/>
        <Element Offset="3000" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000BB8" DisplayMethod="unsigned integer"/>
        <Element Offset="3004" Vartype="Pointer" Bytesize="8" OffsetHex="00000BBC" DisplayMethod="unsigned integer"/>
        <Element Offset="3012" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000BC4" DisplayMethod="hexadecimal"/>
        <Element Offset="3020" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000BCC" DisplayMethod="unsigned integer"/>
        <Element Offset="3028" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000BD4" DisplayMethod="hexadecimal"/>
        <Element Offset="3032" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000BD8" DisplayMethod="unsigned integer"/>
        <Element Offset="3036" Vartype="Pointer" Bytesize="8" OffsetHex="00000BDC" DisplayMethod="unsigned integer"/>
        <Element Offset="3044" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000BE4" DisplayMethod="hexadecimal"/>
        <Element Offset="3052" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000BEC" DisplayMethod="unsigned integer"/>
        <Element Offset="3060" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000BF4" DisplayMethod="hexadecimal"/>
        <Element Offset="3064" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000BF8" DisplayMethod="unsigned integer"/>
        <Element Offset="3068" Vartype="Pointer" Bytesize="8" OffsetHex="00000BFC" DisplayMethod="unsigned integer"/>
        <Element Offset="3076" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000C04" DisplayMethod="hexadecimal"/>
        <Element Offset="3084" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000C0C" DisplayMethod="unsigned integer"/>
        <Element Offset="3092" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C14" DisplayMethod="hexadecimal"/>
        <Element Offset="3096" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C18" DisplayMethod="unsigned integer"/>
        <Element Offset="3100" Vartype="Pointer" Bytesize="8" OffsetHex="00000C1C" DisplayMethod="unsigned integer"/>
        <Element Offset="3108" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000C24" DisplayMethod="hexadecimal"/>
        <Element Offset="3116" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000C2C" DisplayMethod="unsigned integer"/>
        <Element Offset="3124" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C34" DisplayMethod="hexadecimal"/>
        <Element Offset="3128" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C38" DisplayMethod="unsigned integer"/>
        <Element Offset="3132" Vartype="Pointer" Bytesize="8" OffsetHex="00000C3C" DisplayMethod="unsigned integer"/>
        <Element Offset="3140" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000C44" DisplayMethod="hexadecimal"/>
        <Element Offset="3148" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000C4C" DisplayMethod="unsigned integer"/>
        <Element Offset="3156" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C54" DisplayMethod="hexadecimal"/>
        <Element Offset="3160" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C58" DisplayMethod="unsigned integer"/>
        <Element Offset="3164" Vartype="Pointer" Bytesize="8" OffsetHex="00000C5C" DisplayMethod="unsigned integer"/>
        <Element Offset="3172" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000C64" DisplayMethod="hexadecimal"/>
        <Element Offset="3180" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000C6C" DisplayMethod="unsigned integer"/>
        <Element Offset="3188" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C74" DisplayMethod="hexadecimal"/>
        <Element Offset="3192" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C78" DisplayMethod="unsigned integer"/>
        <Element Offset="3196" Vartype="Pointer" Bytesize="8" OffsetHex="00000C7C" DisplayMethod="unsigned integer"/>
        <Element Offset="3204" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000C84" DisplayMethod="hexadecimal"/>
        <Element Offset="3212" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000C8C" DisplayMethod="unsigned integer"/>
        <Element Offset="3220" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C94" DisplayMethod="hexadecimal"/>
        <Element Offset="3224" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000C98" DisplayMethod="unsigned integer"/>
        <Element Offset="3228" Vartype="Pointer" Bytesize="8" OffsetHex="00000C9C" DisplayMethod="unsigned integer"/>
        <Element Offset="3236" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000CA4" DisplayMethod="hexadecimal"/>
        <Element Offset="3244" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000CAC" DisplayMethod="unsigned integer"/>
        <Element Offset="3252" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000CB4" DisplayMethod="hexadecimal"/>
        <Element Offset="3256" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000CB8" DisplayMethod="unsigned integer"/>
        <Element Offset="3260" Vartype="Pointer" Bytesize="8" OffsetHex="00000CBC" DisplayMethod="unsigned integer"/>
        <Element Offset="3268" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000CC4" DisplayMethod="hexadecimal"/>
        <Element Offset="3276" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000CCC" DisplayMethod="unsigned integer"/>
        <Element Offset="3284" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000CD4" DisplayMethod="hexadecimal"/>
        <Element Offset="3288" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000CD8" DisplayMethod="unsigned integer"/>
        <Element Offset="3292" Vartype="Pointer" Bytesize="8" OffsetHex="00000CDC" DisplayMethod="unsigned integer"/>
        <Element Offset="3300" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000CE4" DisplayMethod="hexadecimal"/>
        <Element Offset="3308" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000CEC" DisplayMethod="unsigned integer"/>
        <Element Offset="3316" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000CF4" DisplayMethod="hexadecimal"/>
        <Element Offset="3320" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000CF8" DisplayMethod="unsigned integer"/>
        <Element Offset="3324" Vartype="Pointer" Bytesize="8" OffsetHex="00000CFC" DisplayMethod="unsigned integer"/>
        <Element Offset="3332" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000D04" DisplayMethod="hexadecimal"/>
        <Element Offset="3340" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000D0C" DisplayMethod="unsigned integer"/>
        <Element Offset="3348" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D14" DisplayMethod="hexadecimal"/>
        <Element Offset="3352" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D18" DisplayMethod="unsigned integer"/>
        <Element Offset="3356" Vartype="Pointer" Bytesize="8" OffsetHex="00000D1C" DisplayMethod="unsigned integer"/>
        <Element Offset="3364" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000D24" DisplayMethod="hexadecimal"/>
        <Element Offset="3372" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000D2C" DisplayMethod="unsigned integer"/>
        <Element Offset="3380" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D34" DisplayMethod="hexadecimal"/>
        <Element Offset="3384" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D38" DisplayMethod="unsigned integer"/>
        <Element Offset="3388" Vartype="Pointer" Bytesize="8" OffsetHex="00000D3C" DisplayMethod="unsigned integer"/>
        <Element Offset="3396" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000D44" DisplayMethod="hexadecimal"/>
        <Element Offset="3404" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000D4C" DisplayMethod="unsigned integer"/>
        <Element Offset="3412" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D54" DisplayMethod="hexadecimal"/>
        <Element Offset="3416" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D58" DisplayMethod="unsigned integer"/>
        <Element Offset="3420" Vartype="Pointer" Bytesize="8" OffsetHex="00000D5C" DisplayMethod="unsigned integer"/>
        <Element Offset="3428" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000D64" DisplayMethod="hexadecimal"/>
        <Element Offset="3436" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000D6C" DisplayMethod="unsigned integer"/>
        <Element Offset="3444" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D74" DisplayMethod="hexadecimal"/>
        <Element Offset="3448" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D78" DisplayMethod="unsigned integer"/>
        <Element Offset="3452" Vartype="Pointer" Bytesize="8" OffsetHex="00000D7C" DisplayMethod="unsigned integer"/>
        <Element Offset="3460" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000D84" DisplayMethod="hexadecimal"/>
        <Element Offset="3468" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000D8C" DisplayMethod="unsigned integer"/>
        <Element Offset="3476" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D94" DisplayMethod="hexadecimal"/>
        <Element Offset="3480" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000D98" DisplayMethod="unsigned integer"/>
        <Element Offset="3484" Vartype="Pointer" Bytesize="8" OffsetHex="00000D9C" DisplayMethod="unsigned integer"/>
        <Element Offset="3492" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000DA4" DisplayMethod="hexadecimal"/>
        <Element Offset="3500" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000DAC" DisplayMethod="unsigned integer"/>
        <Element Offset="3508" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000DB4" DisplayMethod="hexadecimal"/>
        <Element Offset="3512" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000DB8" DisplayMethod="unsigned integer"/>
        <Element Offset="3516" Vartype="Pointer" Bytesize="8" OffsetHex="00000DBC" DisplayMethod="unsigned integer"/>
        <Element Offset="3524" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000DC4" DisplayMethod="hexadecimal"/>
        <Element Offset="3532" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000DCC" DisplayMethod="unsigned integer"/>
        <Element Offset="3540" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000DD4" DisplayMethod="hexadecimal"/>
        <Element Offset="3544" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000DD8" DisplayMethod="unsigned integer"/>
        <Element Offset="3548" Vartype="Pointer" Bytesize="8" OffsetHex="00000DDC" DisplayMethod="unsigned integer"/>
        <Element Offset="3556" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000DE4" DisplayMethod="hexadecimal"/>
        <Element Offset="3564" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000DEC" DisplayMethod="unsigned integer"/>
        <Element Offset="3572" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000DF4" DisplayMethod="hexadecimal"/>
        <Element Offset="3576" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000DF8" DisplayMethod="unsigned integer"/>
        <Element Offset="3580" Vartype="Pointer" Bytesize="8" OffsetHex="00000DFC" DisplayMethod="unsigned integer"/>
        <Element Offset="3588" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000E04" DisplayMethod="hexadecimal"/>
        <Element Offset="3596" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000E0C" DisplayMethod="unsigned integer"/>
        <Element Offset="3604" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000E14" DisplayMethod="hexadecimal"/>
        <Element Offset="3608" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000E18" DisplayMethod="unsigned integer"/>
        <Element Offset="3612" Vartype="Pointer" Bytesize="8" OffsetHex="00000E1C" DisplayMethod="unsigned integer"/>
        <Element Offset="3620" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000E24" DisplayMethod="hexadecimal"/>
        <Element Offset="3628" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000E2C" DisplayMethod="unsigned integer"/>
        <Element Offset="3636" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000E34" DisplayMethod="hexadecimal"/>
        <Element Offset="3640" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000E38" DisplayMethod="unsigned integer"/>
        <Element Offset="3644" Vartype="Pointer" Bytesize="8" OffsetHex="00000E3C" DisplayMethod="unsigned integer"/>
        <Element Offset="3652" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000E44" DisplayMethod="hexadecimal"/>
        <Element Offset="3660" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000E4C" DisplayMethod="unsigned integer"/>
        <Element Offset="3668" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000E54" DisplayMethod="hexadecimal"/>
        <Element Offset="3672" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000E58" DisplayMethod="unsigned integer"/>
        <Element Offset="3676" Vartype="Pointer" Bytesize="8" OffsetHex="00000E5C" DisplayMethod="unsigned integer"/>
        <Element Offset="3684" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000E64" DisplayMethod="hexadecimal"/>
        <Element Offset="3692" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000E6C" DisplayMethod="unsigned integer"/>
        <Element Offset="3700" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000E74" DisplayMethod="hexadecimal"/>
        <Element Offset="3704" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000E78" DisplayMethod="unsigned integer"/>
        <Element Offset="3708" Vartype="Pointer" Bytesize="8" OffsetHex="00000E7C" DisplayMethod="unsigned integer"/>
        <Element Offset="3716" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000E84" DisplayMethod="hexadecimal"/>
        <Element Offset="3724" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000E8C" DisplayMethod="unsigned integer"/>
        <Element Offset="3732" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000E94" DisplayMethod="hexadecimal"/>
        <Element Offset="3736" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000E98" DisplayMethod="unsigned integer"/>
        <Element Offset="3740" Vartype="Pointer" Bytesize="8" OffsetHex="00000E9C" DisplayMethod="unsigned integer"/>
        <Element Offset="3748" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000EA4" DisplayMethod="hexadecimal"/>
        <Element Offset="3756" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000EAC" DisplayMethod="unsigned integer"/>
        <Element Offset="3764" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000EB4" DisplayMethod="hexadecimal"/>
        <Element Offset="3768" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000EB8" DisplayMethod="unsigned integer"/>
        <Element Offset="3772" Vartype="Pointer" Bytesize="8" OffsetHex="00000EBC" DisplayMethod="unsigned integer"/>
        <Element Offset="3780" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000EC4" DisplayMethod="hexadecimal"/>
        <Element Offset="3788" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000ECC" DisplayMethod="unsigned integer"/>
        <Element Offset="3796" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000ED4" DisplayMethod="hexadecimal"/>
        <Element Offset="3800" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000ED8" DisplayMethod="unsigned integer"/>
        <Element Offset="3804" Vartype="Pointer" Bytesize="8" OffsetHex="00000EDC" DisplayMethod="unsigned integer"/>
        <Element Offset="3812" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000EE4" DisplayMethod="hexadecimal"/>
        <Element Offset="3820" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000EEC" DisplayMethod="unsigned integer"/>
        <Element Offset="3828" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000EF4" DisplayMethod="hexadecimal"/>
        <Element Offset="3832" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000EF8" DisplayMethod="unsigned integer"/>
        <Element Offset="3836" Vartype="Pointer" Bytesize="8" OffsetHex="00000EFC" DisplayMethod="unsigned integer"/>
        <Element Offset="3844" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F04" DisplayMethod="hexadecimal"/>
        <Element Offset="3852" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F0C" DisplayMethod="unsigned integer"/>
        <Element Offset="3860" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F14" DisplayMethod="hexadecimal"/>
        <Element Offset="3864" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F18" DisplayMethod="unsigned integer"/>
        <Element Offset="3868" Vartype="Pointer" Bytesize="8" OffsetHex="00000F1C" DisplayMethod="unsigned integer"/>
        <Element Offset="3876" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F24" DisplayMethod="hexadecimal"/>
        <Element Offset="3884" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F2C" DisplayMethod="unsigned integer"/>
        <Element Offset="3892" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F34" DisplayMethod="hexadecimal"/>
        <Element Offset="3896" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F38" DisplayMethod="unsigned integer"/>
        <Element Offset="3900" Vartype="Pointer" Bytesize="8" OffsetHex="00000F3C" DisplayMethod="unsigned integer"/>
        <Element Offset="3908" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F44" DisplayMethod="hexadecimal"/>
        <Element Offset="3916" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F4C" DisplayMethod="unsigned integer"/>
        <Element Offset="3924" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F54" DisplayMethod="hexadecimal"/>
        <Element Offset="3928" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F58" DisplayMethod="unsigned integer"/>
        <Element Offset="3932" Vartype="Pointer" Bytesize="8" OffsetHex="00000F5C" DisplayMethod="unsigned integer"/>
        <Element Offset="3940" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F64" DisplayMethod="hexadecimal"/>
        <Element Offset="3948" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F6C" DisplayMethod="unsigned integer"/>
        <Element Offset="3956" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F74" DisplayMethod="hexadecimal"/>
        <Element Offset="3960" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F78" DisplayMethod="unsigned integer"/>
        <Element Offset="3964" Vartype="Pointer" Bytesize="8" OffsetHex="00000F7C" DisplayMethod="unsigned integer"/>
        <Element Offset="3972" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F84" DisplayMethod="hexadecimal"/>
        <Element Offset="3980" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000F8C" DisplayMethod="unsigned integer"/>
        <Element Offset="3988" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F94" DisplayMethod="hexadecimal"/>
        <Element Offset="3992" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000F98" DisplayMethod="unsigned integer"/>
        <Element Offset="3996" Vartype="Pointer" Bytesize="8" OffsetHex="00000F9C" DisplayMethod="unsigned integer"/>
        <Element Offset="4004" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000FA4" DisplayMethod="hexadecimal"/>
        <Element Offset="4012" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000FAC" DisplayMethod="unsigned integer"/>
        <Element Offset="4020" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000FB4" DisplayMethod="hexadecimal"/>
        <Element Offset="4024" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000FB8" DisplayMethod="unsigned integer"/>
        <Element Offset="4028" Vartype="Pointer" Bytesize="8" OffsetHex="00000FBC" DisplayMethod="unsigned integer"/>
        <Element Offset="4036" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000FC4" DisplayMethod="hexadecimal"/>
        <Element Offset="4044" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000FCC" DisplayMethod="unsigned integer"/>
        <Element Offset="4052" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000FD4" DisplayMethod="hexadecimal"/>
        <Element Offset="4056" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000FD8" DisplayMethod="unsigned integer"/>
        <Element Offset="4060" Vartype="Pointer" Bytesize="8" OffsetHex="00000FDC" DisplayMethod="unsigned integer"/>
        <Element Offset="4068" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000FE4" DisplayMethod="hexadecimal"/>
        <Element Offset="4076" Vartype="4 Bytes" Bytesize="4" RLECount="2" OffsetHex="00000FEC" DisplayMethod="unsigned integer"/>
        <Element Offset="4084" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000FF4" DisplayMethod="hexadecimal"/>
        <Element Offset="4088" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000FF8" DisplayMethod="unsigned integer"/>
        <Element Offset="4092" Vartype="4 Bytes" Bytesize="4" OffsetHex="00000FFC" DisplayMethod="hexadecimal"/>
      </Elements>
    </Structure>
  </Structures>
</CheatTable>
